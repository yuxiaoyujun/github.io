[{"title":"github pages 自定义域名","date":"2023-01-26T07:01:49.000Z","url":"/2023/01/26/cxy/other/dns/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" ping xxx.github.io找到域名 在购买域名的提供商为域名添加解析，如下设置（阿里云的） 在Github中，找到托管博客的xxx.github.io项目：setting - pages中，在Custom Domain填上刚刚添加解析的域名并保存即可。 完成，请点击"},{"title":"【vscode】vetur插件在vue3中报错","date":"2022-12-30T03:31:49.000Z","url":"/2022/12/30/cxy/other/vscode-vetur/","tags":[["开发效率","/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" vetur是vue2支持的插件，volar(vue language features)可以支持vue3。可以直接搜索安装然后禁用vetur，重启vscode即可。 如果不想禁用vetur，又想启用volar，可以在当前项目中的.vscode文件夹的settings.json文件中配置禁用如下： 重启即可。"},{"title":"【github】私有仓库如何避免每次pull都要输入用户名密码","date":"2022-12-24T22:21:49.000Z","url":"/2022/12/25/cxy/other/github-siyoucangku/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一. 使用https提交方式：1. 使用git config命令在本地全局设置用户名和邮箱git config --global user.name &quot;username&quot;：全局添加用户名git config --global user.email “someone@mail.com”：全局添加邮箱git config --global credential.helper store： 该命令用于为credential.helper设置值，避免重复输入用户名密码 2. 执行完成以上后，运行cat ~/.gitconfig会发现.gitconfig多出了以下代码 3. 再次git pull，只需输入一次密码，之后就可以不再输入密码了。 二、使用ssh提交方式：1. 生成秘钥执行ssh-keygen。如果原本没有秘钥，就一路回车。如果有秘钥且秘钥关联了其他网站的项目，比如gitlab什么的，那就需要重新指定目录。 2. 获取公钥执行 cat 你指定的目录/id_rsa.pub获取公钥（如果没指定，就是 ~/.ssh/id_rsa.pub） 3. github中，新建ssh 4. 复制公钥粘贴保存即可。"},{"title":"【人像】好久不画人像了","date":"2022-11-24T05:23:38.000Z","url":"/2022/11/24/paint/paint-picture1/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 小练一下素描~过程录屏在微信视频号中 "},{"title":"【prettier】vscode + prettier自动格式化","date":"2022-11-21T15:11:49.000Z","url":"/2022/11/21/vscode-prettier/","tags":[["babel","/tags/babel/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 1. 搜索并安装prettier，并确定该插件是启用状态 2. 在项目中安装prettier 3. 在项目根目录新建.prettierrc和.prettierignore文件 .prettierrc: 配置格式化规则，如以下配置 .prettierrc更多的配置内容可以点击这里 .prettierignore: 配置不需要格式化的文件，如下： 4.打开vscode的setting(快捷键command+,)，搜索Format，并勾选Editor: Format On Save 5. 随便打开一个项目中的js文件，右键，点击使用…格式化文档 6. 在顶部点击配置默认格式化程序…，选择Prettier 配置完成，改动文件并保存就可以生效了。"},{"title":"【blender】着色器基础","date":"2022-11-11T07:21:08.000Z","url":"/2022/11/11/jianmo/bl-zhuoseqi/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 着色器部分国内文档太少，这段时间翻了很久的国外文档，请教了几位油管及discord大神，自己也做了不少东西后做出的总结。 不同颜色节点的含义首先，着色器节点固定从左向右流动。绿色节点：着色器本身如各类bsdf黄色节点：颜色信息如：基础色、次表面色表面并不是一定只能连接一个颜色。新建一个平面，切换到shading，新建一个材质槽。shift a新建一个图像纹理，添加一张图片，连接到bsdf的基础色，就可以将这张彩色图片的颜色信息显示在平面上。（其实可以直接拖进去，但不知道为什么自从我更新了3.3我就再也拖不进去了。）灰色节点：值，bsdf的很多设置都是值着色器上的值与颜色一样，很多时候表面是不想用同一个值来设置所有位置的。如糙度，很多情况下表面的材质并不是同一糙度，所以这时候需要一张描述表面糙度的图，通过0（黑色）至1（白色）之间的值，使用黑白或灰度着色，将值映射到不同的表面位置。即：pbr贴图中的粗糙度文件。如以下这张就是一张粗糙度描述图片，它黑色的地方表示完全不粗糙（0）白色的地方表示粗糙度满点（1），其余灰色的地方，灰色越深，越接近于零，也就越不粗糙。 如图，将上面的粗糙度文件连接至糙度后，可以看到表面有不同程度的粗糙纹理。紫色节点：矢量信息。 蓝色节点：表示属性，多和几何节点结合使用，不属于这里的讨论范围。 当然，不同颜色节点之间可以互相转换，只是会丢失读取不出来的信息。将粗糙度图片连接到黄色节点，如基础色，由于粗糙度图片只有黑白灰的值，基础色无法读出其他颜色信息，所以无法显示彩色。次表面：光穿透过表面后，在其下方散射发生的情况。最常见的就是人体皮肤。 透射&amp;&amp;投射粗糙度透射：决定多少光可以通过材料，而不是从材料反射光。透射值越大，透过材料的光越多。透射粗糙度：透射光的粗糙度，只有cycles下可以使用，且分布为GGX。说简单点儿，透射粗糙度的高低差别就是镜面玻璃和磨砂玻璃的区别。 自发光（发射）：从材料实际发出的光，拥有自己的颜色和强度。alpha：材料透明度。 以上这些值都是可以通过为不同位置传入不同的值来做不同的设置，就如同上述说的粗糙度设置。 法向：用于法线贴图，在不用更改网格几何形状的情况下，伪造材质的深度与阴影。 ##着色器节点 不多叙述，分为表面着色器和体积着色器两类。原理化bsdf着色器理论是可以做出所有表面着色器的效果。但使用其他的表面着色器可以更快捷的实现想实现的效果。比如玻璃、透明、半透、毛发等。以玻璃bsdf举例 折射率：当bsdf为玻璃或半透明时，物体内部可以进行折射，折射的情况就由ior设置。水、不同厚度的玻璃、塑料瓶都有不同的折射率。粗糙度：物体表面粗糙度越高，越不容易进行折射。而这两个参数都是可以在原理化bsdf中进行设置，所以理论上来说原理化bsdf可以实现玻璃的效果，但使用玻璃bdsf来制作单纯的玻璃会更加的便捷。 体积着色器可以连接至体积输出，有原理化体积、体积散射、体积吸收。原理化体积理论上是可以实现体积散射和体积吸收，且可以综合二者进行设置，但直接使用体积散射和体积吸收可以更快捷的实现对应的效果。体积吸收：表示光线穿过物体时，体积会吸收光线体积散射：更接近于雾的效果，通过体积散射，光会撞击物体体积并进行反弹。 体积着色器经常用于实现一些场景的烟雾、或者表现场景的空气透视感时会很常用。如下面这张我建立了两个立方体，对外层大一些的立方体使用了体积散射，在两边设置了两个不同颜色的光源，就会有这种透光的烟雾效果。我做的这张小场景的练习，为了表现出远处的空气透视感，也在中间加了一个体积散射的平面。 体积bsdf的实际运用也可以和噪波纹理相结合，生成不同形状的烟雾，也可以用噪波纹理增加噪点等效果。 混合bsdf：现在我将两个原理化bsdf使用混合bsdf连接，混合bsdf拥有上下两个叫混合器的插槽和一个系数插槽。我将红色bsdf放在下面的混合器插槽，蓝色bsdf放在上面的混合器插槽，若系数为0.5，即上下着色器等比混合，正常情况下物体表面应该为紫色。如下图系数越大，混合结果越偏向于下面的着色器。 若混合bsdf系数给一个灰度描述，如马氏分形纹理，那么表面就会因为不同的系数而做不同的着色器显示。将顶部着色器放在有黑色的地方（0），将底部着色器放在有白色的地方（1）。而灰色的地方进行两个着色器颜色的混合 ##纹理节点blender自带的一些材质节点，可以根据不同材质节点生成不同的灰度纹理。 以马氏分形纹理做简单说明简单说一下3d和4d的区别，4d比3d多了一个w值，w可以使纹理随时间推移改变w，一般用于设置动画。（按i可以设置关键帧，或在节点上右键 - 插入关键帧）如果将纹理直接连接着色器的基础色，那么就是灰度显示，因为材质节点本质就是生成不同位置的灰度信息。如果想让其显示彩色，可以连接一个colorRamp，也就是渐变 沃罗诺伊纹理是一种很常用的纹理，可以生成漂亮的图案及形状。就我个人而言，连接颜色时感觉很像一堆马赛克做了变换的纹理 其他像砖墙纹理、棋盘格纹理就不再多说，纹理与纹理可以相互连接，组合生成不同的有意思的图案，需要多加尝试。除了纹理与纹理之间相互连接外，还有另一种方法，使用mixRgb（混合rgb）混合rgb与混合着色器的使用方法相当像，区别是混合rgb用于颜色输出，而混合着色器用于着色器输出。混合rgb可以控制灰度的信息，所以当两个纹理连接到混合rgb时，可以通过混合rgb去控制两个纹理的强弱。混合方式可以点击自己调节，不详细介绍了，如果用过ps应该是熟悉的。 还有一些不太常用于着色器表面信息的纹理节点，比如ies纹理（用于描述灯光）环境纹理（用于描述环境）等，之后我会再整理。 ##如何将纹理映射到对象上？与几个节点息息相关。 纹理坐标节点：用不同方式告诉纹理如何在blender中进行映射，不同的用途可以有不同的输出。常用的两个是物体和生成，生成是默认的形状，物体适合生成程序化的纹理。 映射节点，可以调节纹理的位置、旋转和缩放 运算节点，可以使两个值做对应运算 "},{"title":"【zbrush】曲线弯折","date":"2022-10-15T02:21:49.000Z","url":"/2022/10/15/jianmo/zb-quxianwanzhe/","tags":[["zbrush","/tags/zbrush/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 做头发的时候总在想如果zbrush有类似blender的硬表面操作就好了，然后摸了一下，录了一个视频。 "},{"title":"【画画】把心血来潮想画的东西扔在这里","date":"2022-10-11T05:23:38.000Z","url":"/2022/10/11/paint/paint-pictureall/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 有段时间很流行画各类月野兔的时候画的 不知道为什么，ipad画完导入手机再看，两边色偏还是挺大的 这破玩意儿我点点点了一周。 第一次画的水彩，没学任何技法，凭感觉瞎怼，那个树叶画的还真丑。 第二次画的水彩，画完之后就再也没动过水彩了。 第一次画的彩铅第二次画彩铅第三次画彩铅第四次画彩铅，一年多前的画，结果。。到现在彩铅找不到了都还没画完"},{"title":"zbrush/blender雕刻工作流gob交互","date":"2022-10-05T02:21:49.000Z","url":"/2022/10/05/jianmo/zb-bl-gob/","tags":[["blender","/tags/blender/"],["zbrush","/tags/zbrush/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 希望下次我再看我自己讲话能听懂。 "},{"title":"【人像】人像练习","date":"2022-10-03T07:23:38.000Z","url":"/2022/10/03/paint/paint-picture2%20copy/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 这次顺带录了屏嘿嘿~其实没画完拉 "},{"title":"【人像】画个刘亦菲","date":"2022-09-19T07:23:38.000Z","url":"/2022/09/19/paint/paint-picture2/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 画了个刘亦菲，四五个人都说是宋祖儿hhhhh，好好好那这个画的就是宋祖儿 "},{"title":"【blender】积累的一些杂七杂八","date":"2022-09-15T04:21:08.000Z","url":"/2022/09/15/jianmo/bl-zaqizaba/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" blender3.3更新了，毛发新增了编辑模式，但我没有找到。 只有原先的雕刻模式，在雕刻模式左侧有一些工具可以操作毛发 官网写开启实验功能后的调试后，在实验特性prototypes开启new curves tools我并没有这个选项。。 low poly相关 "},{"title":"【blender】给你跳段舞？","date":"2022-08-31T08:23:08.000Z","url":"/2022/08/31/jianmo/bl-vroid/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" vroid搞得基础模型大概花了一周时间在blender加的骨架然后搞了一段小动画~ "},{"title":"【blender+scatter5插件】两分钟做好一个漂亮的地形","date":"2022-07-31T22:21:49.000Z","url":"/2022/08/01/jianmo/bl-caoping/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 想录个随风摇摆的动画视频，结果粒子系统卡死我 因为这个插件本质是生成一堆粒子系统，所以要对自己的配置有自信。所需blender版本: 3.1及以上 ##1. 安装Landscape插件 ##2. 新建地形，在网格 - Landscape中。##3. 点击后，左侧下方有一个下拉菜单，点开后可以进行地形的详细设置##4. 物体 - 应用 - 全部变换或command + a 调出应用面板，也可以选择应用变换 。##5. 下载安装 Scatter5 插件并启用下载地址：点击查看下载后解压，通过插件引入，点击安装，导入解压后文件夹内的压缩包scatter5.2.zip，点击确定。点击展开，然后进入enter manager点击install a scatter package选择解压文件夹中的另外三个文件，，点击install即可。##6.右侧n面板中，选择该插件，点击吸管，选择创建好的地形。点击后面板变为以下模样子。然后点击图片，选择想要的预设。点击Biome Scatter，点击Open Biomes选择喜欢的地形。加载完成后，会有很多粒子系统被自动导入，默认不开启。点击每一个System List中的粒子系统，在下方wind中，开启Wind Waves 加载一个天空纹理点击渲染模式并播放即可。 ###说明：&ensp; &ensp; 1. 操作项预设&ensp; &ensp; &ensp; &ensp; 可以设置一些预设的地形，比如石头、湖泊、山等。 &ensp; &ensp; 2.SubdivisionsX / Y&ensp; &ensp; &ensp; &ensp; 细分，细分自然是越高细节越多。但渲染也越慢。 &ensp; &ensp; 3. mesh SizeX / Y&ensp; &ensp; &ensp; &ensp; 设置平面的尺寸。 其他的设置也有很多，可以多尝试 ##其他积累：&ensp; &ensp; 1. scale 平面，之前只知道是按s，但不知道按下数字键可以直接按比例缩放，比如按s，向外拖，再按2，就是放大两倍。按s，向内拖，再按下2，就是缩小两倍了。"},{"title":"blender各种光源的设置","date":"2022-07-24T22:21:49.000Z","url":"/2022/07/25/jianmo/bl-guangyuan/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 场景 - 世界自带光源与hdri光源。首先，场景 - 世界中的自带光源，与hdri光源是互斥的，二者只能有一个生效。当勾选 视图着色方式 - 场景世界 时，将强度/力度调为0，且没有建立其他光源的话，则世界场景完全无光源。将强度/力度调高世界场景也会亮。所以一般如果不需要这个的话，在渲染前需要调为0。 场景世界若不勾选，可以显示hdri，世界不透明度改为0的时候就可以只显示物体上的hdri效果。hdri图有360度的场景。相当于一个懒人全景打光，将场景中物体放入了已经定义好的一个360度的环境中。 各种光源的详细介绍1. 点光源颜色：调整颜色能量：调整瓦数半径：半径越大，向周围发送的光就越散点光源离物体越近，物体越亮。点光光源半径越大，阴影越散。 注：当沿点光源像物体两边作切线，离物体越近的光源切线范围越大。所以点光光源离物体越远时，阴影反而越硬朗， 2. 日光日光本身建立在什么位置都无所谓，完全无所谓。日光的位置不会影响影子的角度、影子的强度。比如下图，日光在物体正上方，影子依旧向右。就算日光放到物体底下，影子依旧不会受日光的位置影响。 影响日光角度的只有这个调节手杆儿 手杆儿角度越大，阴影越长 角度和强度： 太阳光强度一般1-3就很亮了。角度0-180度，和手柄调节的角度不是一个概念。试下来感觉角度越大阴影越散越亮。可以观察下面两张图的角度值，同时观察墙面的投影区别。 3. 聚光灯对物体的照射方式基本像点光，但它的角度可以调节，且只朝向一部分角度。就像是360度的点光截了几十度（1）光源半径光源半径越大，光越散，投影边缘越柔和，越暗。。（2）光斑尺寸越大的光斑尺寸，越大的光斑范围。光斑尺寸不影响边缘模糊与否。 混合，数值 0 - 1，聚光灯下两个圆环数值越接近1 ， 聚光灯底部在中间的小圆的半径越小，光的边缘越模糊，不怎么影响投影的边缘。 ###4. 面光不具体说了，像一个有方向可调节大小和尺寸的太阳光。 hdri切换到world，点击颜色前面的点，点击图像纹理。 勾选hdri后，就在左图设置hdri相关。右边的设置基本就没什么用了。 渲染时如果不想有hdri背景，勾上透明就不会渲染hdri了。 用物体自发光来打光。自发光的物体相当于一个点光源在场景内新建一个球，为球指定自发光颜色及强度切换到渲染模式，就会发现球成为了一个光源照亮了周围的物体。 ####补充：在cycles模式下如何设置辉光？现在只能在渲染层设置，没办法预览，所以需要渲染后才能看到效果。 四、使用ies 纹理进行打光ies纹理概念：ies纹理用于匹配基于IES文件(IES)的现实世界的灯光。IES文件存储光源的方向强度分布。常用的ies纹理免费下载网站：点击下载 下载的ies贴图对应的能量和建议的灯光类型。 举例：第一张没有ies纹理。第二张有纹理。可以看到普通点光是均匀过度的。而用了有ies纹理的灯光是有可能不均匀的。接近现实世界的光。着色器中有一个叫黑体节点，黑体值越大，越接近原本设置的颜色，越小，颜色越暖。 黑体温度为1111111和为1的对比。 "},{"title":"【菜谱】自己做的菜合集 + 简单描述的菜谱们","date":"2022-07-23T04:33:23.000Z","url":"/2022/07/23/caipu/","tags":[["菜谱","/tags/%E8%8F%9C%E8%B0%B1/"]],"categories":[["生活","/categories/%E7%94%9F%E6%B4%BB/"]],"content":" 日记本来一直在有道云写的，因为有道云太辣鸡吞了我好多图所以当做日记一样复制过来。所以图拍的不是那么讲究，背后很多杂物，甚至很多是吃了一半才想起来拍一张。。。好多图都被有道云吃了，现在只能找回这些了，真惨。 ##香辣鸡翅尖 鸡翅尖开水焯水，加一点点盐，两三分钟捞出备用。 切葱、蒜、干辣椒段、花椒、准备一点熟白芝麻。 锅中热油，放入蒜、干辣椒段（泡水）、花椒，炒香。 倒入一点点火锅底料，炒化后倒入鸡翅。 炒出香味后，倒入鸡翅尖，翻炒均匀后加生抽、糖、蚝油、孜然等尝味道。 撒入香葱翻均匀，撒入芝麻，留一点点香葱装盘后洒在表面做点缀。 ##炸鸡翅根 鸡翅洗净剪开，露出骨头。 酱油、糖、蚝油、花椒粉、辣椒粉、孜然粉、五香粉、蒜、葱、水淀粉进行腌制，二十分钟左右可以拿出。 低筋面粉+淀粉1:1进行混合，腌好的鸡翅根放入其中粘上粉末，捏紧实。搓一搓，再次裹上粉。 如果想脆皮厚一些，可以准备一个放了清水的碗，裹好粉的鸡翅放入水中浸一下就捞出，然后再重复裹上粉，搓一搓的步骤。 油温三成热下入鸡翅，小火炸一会儿翻一下面，炸八分钟到十分钟。用筷子插鸡翅如果可以插透表示熟了。 捞出鸡翅控油，大火让让油温十成热，下入鸡翅，炸制表面金黄且完全脱水，变为脆脆的感觉即可。 ##仿南大门米糕做的桂花糕比较麻烦，快赶上烤蛋糕那么麻烦了，但很好吃。 材料：粘米粉、糯米粉、糖粉，桂花糖，干桂花，还需要准备切刀，30+目筛子，最好是60目，最好备个电子秤，模具，我的是四寸方形慕斯蛋糕模具。 比例：粘米粉：糯米粉：糖粉 = 3:1:1，我用的是四寸方形模具，粘米粉：糯米粉：糖粉 = 150g:50g:50g。还多出一些，做了两次。水：约为糯米粉or糖粉的两倍，如糯米粉五十克，则水要一百克。 详细过程： 糯米粉、粘米粉混合，然后一点一点慢慢加水，搅成一个个松散的小坨坨。 过筛成细细的粉，不要按压细粉，多过几遍筛会让口感更细腻。 蒸锅垫布，模具放入蒸锅，倒入细细的粉，千万不要按压千万不要按压千万不要按压！用刮刀把表面刮平整，，，，，小心翼翼的切分为3*3的九宫格，如果这时候不切开，蒸好后切开就容易碎不好看。 水开后转小火，放上去东西蒸20分钟左右。蒸到五分钟左右的时候其实模具就可以拿掉了，不要等最后才拿模具，因为水会聚集在底部，底部会显得很湿。 蒸完后拿出来，每一块上挤上桂花糖，撒上桂花，趁热吃吧。 ##桂花蒸鸡蛋羹 普通的蒸鸡蛋，就是鸡蛋打了之后加水到鸡蛋一倍左右，然后加盐，把表面气泡用勺子或者别的撇干净。 裹保鲜膜扎洞小火蒸，出锅后表面撒上桂花，切一半圣女果摆上去，沿碗边加上酱油即可。 蒜蓉粉丝娃娃菜 至少一颗整蒜，切末，红尖椒，切碎，切葱、准备几颗花椒。 小火加入油三四成热，油多倒一点，下入花椒炸出香味，下入尖椒翻炒一下，加入蒜末炸至金黄。 倒入生抽、白糖、蚝油、一点点孜然，尝味道合适了备用。 娃娃菜洗净铺在盘底，上面放上泡软的粉丝，倒入炒好的蒜香油。 烧开水，上蒸锅蒸二十分钟。 端出来，加入香葱点缀即可。 鸡蛋杂菜薄饼太简单了，不写做法了。 当然也可以卷了切开做鸡蛋卷，中间加了些肉松。以前的我还真讲究摆盘。。 ##杂菜饭团 米饭煮好，香菇、火腿、玉米、肉松、海苔/裙带菜切碎，切葱蒜小米辣。 小火炒香蒜小米辣，下香菇碎、火腿碎、玉米粒、裙带菜/海苔，加盐、味精调味至合适倒入米饭中搅拌。捏成团摆入盘中，芝士切片铺在饭团上，蒸锅蒸化芝士即可。 ##麻辣鸭掌 鸭掌凉水下锅焯水，焯水后大火转小火，煮四十分钟以上，想要软烂则一小时以上最好。 捞出洗净，准备四五个蒜瓣切蒜末（or蒜瓣拍碎，喜欢吃蒜可以切蒜末），稍微多一些的干辣椒，三根香葱，花椒一小把，熟白芝麻。 大火热油，加入一小块火锅底料炒化，下入蒜末、干辣椒（泡水）、花椒翻炒出香味，下入鸭掌翻炒均匀，加入一点点老抽调色，加入生抽、蚝油、糖调味，（尝一下锅铲的味道。。。合适的话），翻炒几下即可出锅了，关火后加入香葱翻一下，再加入白芝麻翻一下，可以加一点点鸡精翻均匀。 装盘再在表面撒一些香葱和白芝麻即可。 ##蛋挞蛋挞皮是现成的，蛋挞液是炼乳+蛋黄+牛奶+白糖，过筛后倒入蛋挞皮，180度预热烤箱，然后放进去烤20分钟左右就好了，反正烤箱是可以看表面状态的。下次拿出来的时候要小心烫手，我把自己手指烫了。 ##麻辣花蛤 花蛤泡的久一点让他吐沙，然后剥出来。 开水加料酒焯水两三分钟让它熟了，捞出备用。 准备干辣椒花椒小葱蒜瓣拍碎，干辣椒蒜瓣花椒大火下锅炒出香味，加入花蛤翻几下，加生抽蚝油糖翻几下，加一点点孜然翻几下，嫌颜色不够可以加一点点老抽，然后就可以出锅了。 ##年年有余 吉利丁粉在热水中一点一点加，一定要一点一点加。慢慢融化慢慢融化，加入糖，加入枸杞。 倒入模具中冷藏一小时or更长，发现凝固了就拿出来脱模就完成了。如果是很薄的塑料膜可能会沾膜，拿根牙签稍微挑一下就行了。 周围撒上枸杞。说真的真好看，但口感一般，也就果冻的味道，却没有果冻的添加剂。平时我一个人过节的时候，或者还剩吉利丁消耗不掉的时候才会做一做，我是羞于拿它的口感出来招待客人的。 ##糖葫芦 - 小番茄版 圣女果洗净两两穿好备用 糖：水=2：1，放入小锅（重要）小锅中加热，先大火将糖融化至起大泡，然后小火至起小泡，继续加热，至用筷子蘸取糖液，若能拉丝，则放入冰水中，结成块且尝起来易脆则ok。全程不要搅动。 串好的圣女果在锅中沾满糖液，小心拿起避免拉丝，然后放入冰水中浸泡至定型，放入盘中即完成。 ##冒红薯粉 红薯粉开水下锅加一点盐煮20分钟，捞出凉水洗一下。 切小米辣、蒜末（多多多）、葱末（多多多）、香菜（半根）、辣椒面、准备白芝麻大半勺、花生酱一两勺（or花生碎+芝麻酱）、孜然、白糖、蚝油，混合，倒入热油（多一些）搅拌均匀，冷一会儿后加入鸡精、生抽再搅拌。 与粉混合均匀，完成。如果想更好看些，可以再混合后加入小葱香菜在表面做点缀。 ##自制钵钵鸡汤底炖鸡汤，一部分鸡汤放盐备用素菜开水加盐焯熟，荤菜凉水加盐焯熟魔芋要先泡水之后，再煮二十分钟，魔芋不熟有毒，不泡水会去不掉碱味的炒些辣椒油（孜然/辣椒面/花椒/糖/盐/味精/炸花生米/熟白芝麻/其他，热油泼进）干辣椒多些（稍微泡水再过水），花椒多些（稍微泡水再过水），八角，辣椒面，葱段，蒜瓣拍碎锅中稍多点油，放入两勺豆瓣酱，炒出红油，放入上述干辣椒等材料片炒出香味，然后加高汤，然后大火煮沸，转小火加盐调味。五分钟左右关火，捞出那些调料扔掉，加入炒好的辣椒油（一点一点加，防溅锅），然后加大量鸡精调味。汤底倒出汤碗中，放入食材浸泡越长时间越好即可。 ##鸡胸肉饼 鸡胸肉搅碎，加玉米粒、豌豆粒、葱、小米辣、二荆条辣椒，盐、鸡精、花椒粉、生抽。 锅中放入涂上油的圆形模具，倒入油，小火加热，加入鸡肉铺好，待定型取下圆形模具，盖上锅盖焖一下，开锅翻面煎。 怕碎可以加淀粉，但我是不加的，我也没碎，只要鸡胸肉处理的够筋道就不会碎，多摔打，多搅拌，像搅饺子馅那样。 ##牛奶桂花土豆泥 土豆洗净切块蒸熟，混合白糖用料理机打成泥，加入 牛奶拌匀，倒入碗中搅拌均匀，铺上桂花，铺上桂花蜜。 ##狼牙土豆 土豆用狼牙刀切成条状，浸泡去淀粉。 锅中水烧开加盐，土豆放入水中焯熟，不要煮太久，捞出控水。 碗中放辣子面、孜然、花椒（多）花椒粉、糖（灵魂）、白芝麻、葱、蒜末（一个都不要少）、味精、盐，油烧滚泼入，搅拌至盐融化。 土豆控水后，将调料倒入即可。 ##干煸辣子鸡. 鸡腿肉去骨，剪成小块儿 花椒粉+辣椒粉+生抽+一点点老抽+白糖+五香粉+孜然粉，腌制十五分钟。 干辣椒、花椒切段泡水，蒜切片，准备一小段大葱。 锅中入油，小火加热至三分热倒入鸡腿，加入大葱葱段、花椒、蒜片一起炸，鸡腿炸去水分微金黄捞出控油，油十分热再炸一遍。 油倒掉，锅中重新加入多一点的油，倒入辣椒段、花椒、蒜片翻炒出香味，加入鸡腿肉翻炒一分钟即可出锅。特别好吃！ ##红烧后腿肉五五分的肉，比较肥，感觉还是红烧比较有味道。就是普通红烧肉的做法，不说了。##香菇炖鸡腿汤 新！鲜！的鸡全腿用剪刀剪出露出骨头，放入锅中焯水，倒些料酒，放入花椒、大葱段一小段。 捞出洗净，炖锅中倒入许多凉水，放入鸡腿，加入三两颗花椒、一片姜片，放入两三朵新鲜香菇，大火烧开转小火，炖越久肉越烂。 其实更简单的方法就是放进电饭煲按煲汤模式。。火候不用自己看，到时间了就自然好了。 ##烤口蘑 口蘑小心去蒂，放入空气炸锅160度烤十分钟。 锅中放玉米油，蒜切碎（或打成蒜泥），切小米辣、蒜苗，炒蒜蓉酱，先小火加热油，倒入蒜末，小火炒制发黄，加入小米辣碎，搅几下，关火加入白糖、盐、味精搅化。 倒在烤好的口蘑上，撒上蒜苗和葱花即可。 ##清炖狮子头 五花肉/后腿肉/前腿肉/梅花肉洗净，切碎，加入葱、蒜末（要切的很碎很碎）、马蹄碎（建议加，没有也可以不加）、淀粉，反正别用纯瘦肉。 向一个方向搅搅搅，直到感觉有那种韧劲儿了，就比饺子馅还有韧劲儿的那种感觉，然后摔打，多摔几下。 做成大丸子，凉水烧一会儿大概有温度了就下炖锅，慢慢放下去小心碎了，然后大火烧开，小火四五十分钟就可以了。 ##鸡蛋饼裹生菜太简单了都不想说了就是鸡蛋+低筋面粉加了些调味料（盐、花椒粉、糖、孜然，反正根据自己口味加。），搅拌至没有面粉沉淀，然后加入自己喜欢的配菜搅拌成均匀的糊糊，比如玉米粒、香葱、小米辣碎、火腿等等热锅凉油下入上面说的糊糊，小火小火小火，均匀撒上黑芝麻，一面定型后翻至另一面煎熟，然后拿出裹上生菜，表面挤上番茄酱即可。 ##炸香菇 一勺淀粉一勺低筋面粉一个鸡蛋，搅拌均匀，加一些花椒粉、五香粉、盐、孜然、糖。 香菇放里面裹上糊糊，然后小火加热油，油温三成热下香菇，炸至油温七成热熟了捞出。 大火加热油温到十成热，快速放入刚刚炸好的香菇，把表面水分彻底炸干，炸一会儿就捞出，然后表面撒上椒盐，就行了。 ##娃娃菜粉丝汤没啥说的，奶白色汤的秘诀是，加入的配料比如火腿或者皮蛋是要先炒一下的，用除了菜籽油之外的油炒一下然后再加水炖，就会有奶白色的汤了。菜籽油其实也可以用，但炖出来的汤是黄的~味道没有太大差别。 #油炸花生没啥说的，小火凉油倒入花生不停的翻炒，噼噼啪啪的声音出来就是好了。酥脆的秘诀就是捞出之后加入料酒然后用筷子不停的搅，加入料酒会有刺啦的声音，搅拌的时候也会冒烟 ##好看不好吃的空气炸锅杏鲍菇 一个淀粉一个鸡蛋混合均匀加入花椒粉生抽孜然粉五香粉调味调味 面包糠放入另一个碗中备用。 杏鲍菇切条，放入淀粉鸡蛋液中滚一滚，再裹上面包糠，再放入鸡蛋液滚一滚，再裹一次面包糠，放入空气炸锅刷一层油，200度烤十分钟即可。 因为是面包糠，再加上空气炸锅虽说叫炸锅实际上是烤，所以表面很干很干，并没有那么好吃。无奈我只能就这个形态又去油炸了 一遍，味道才变得好吃， 注：面包糠的特性是虽然脆，但不会像淀粉+面粉那样油炸之后边的膨胀，所以要想好看的话面包糠是要裹至少两遍的。 ##烤豆腐 - 空气炸锅版 豆腐横刀一刀，竖刀三四刀将豆腐切块。 空气炸锅平铺锡纸，豆腐摆入空气炸锅，180十分钟翻面，再烤十五分钟（或更长），考好拿出摆盘。 调酱汁，蚝油+糖（天下无双）加自己炒的特辣辣椒油和辣椒面，加一点孜然粉，加小葱和蒜和一点醋（这个料绝了，味道超级好）也可以加一点小米辣，我没加懒得切，倒在豆腐表面，完成。 ##烤苕皮酱汁：辣椒面、花椒面、孜然、熟白芝麻、韩式烧烤酱或糖各一勺，搅拌后淋上热油。炒些花生。刷上酱汁，苕皮一点油小火煎，煎至起泡，翻面刷上酱汁，煎至两面起泡，撒上香葱、韭菜、花生、榨菜，折三折，用竹签穿好即可。 ##烤五花肉片选新鲜的五花肉，新鲜的五花肉，新鲜的五花肉，腌个十来分钟，然后锅里小火煎熟就行。 ##烤鸡腿腌料腌半小时–三小时，烤二十分钟中途翻面。我的腌料：花椒粉、生抽蚝油糖、孜然粉、辣椒粉、蒜末、葱烤的时候表面刷蜂蜜 ##娃娃菜豆腐汤豆腐煎一下，加入水烧开，加入娃娃菜小火炖十几分钟，捞出撒入香葱。这个豆腐使用菜籽油煎的，所以汤变成了黄色。如果用玉米油煎就不会是黄色而是奶白色。 ##拔丝土豆简单但麻烦，麻烦的点在于，锅如果当时做完不洗干净，等锅里的糖凉了就很难洗干净。。做菜五分钟洗锅一晚上。 水糖1:2熬糖，大火冒大泡转小火，熬一会儿拉丝了加入炸好的土豆块搅拌均匀即可。 炸土豆块就不说了，土豆块焯水七八成熟控水，下入三分热油锅炸熟，大火十成热油复炸就行了。 ##圆圆的煎鸡蛋~让它圆圆的秘诀在于不要用平底锅，要用普通炒锅，因为普通炒锅打鸡蛋下去不会跑偏。平底锅就容易跑偏。 ##月饼装到盒子里也很好看啵 酸菜鱼酸菜切了，加葱姜蒜花椒泡椒炒一炒鱼片成片，加花椒粉淀粉盐腌，鱼头骨炖汤。炒后的酸菜加鱼汤煮，煮到沸腾转小火，放入鱼片煮熟（一般鱼是熟的很快的）。碗底铺焯好水的豆芽和金针菇，然后捞出鱼片放在表面，倒入汤。表面再放花椒、干辣椒段、蒜末、香葱。热油淋上去表面撒上香葱即可。"},{"title":"平面构成入门","date":"2022-07-02T05:23:38.000Z","url":"/2022/07/02/paint/paint-color%20copy/","tags":[["构成","/tags/%E6%9E%84%E6%88%90/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 先把思维导图放好，之后慢慢配图 "},{"title":"【2022-10-09】前几天在咖啡厅画速写","date":"2022-07-02T05:23:38.000Z","url":"/2022/07/02/diary/diary-1009/","tags":[["生活","/tags/%E7%94%9F%E6%B4%BB/"],["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["日记","/categories/%E6%97%A5%E8%AE%B0/"]],"content":" 还被画的小姐姐发现了，但她坐了很长时间之后，默默的走了，走之前和同行小姐姐说“看不看？”最后也没过来看。 "},{"title":"blender的cycles引擎如何使用辉光效果","date":"2022-07-01T08:23:04.000Z","url":"/2022/07/01/jianmo/bl-cycles/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 一般辉光是只在eevee引擎下如果cycles下也想用的话照我下面这样设置就可以拉"},{"title":"色彩构成入门","date":"2022-06-22T20:57:38.000Z","url":"/2022/06/23/paint/paint-color/","tags":[["构成","/tags/%E6%9E%84%E6%88%90/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 思维导图 1. 基本概念首先，有光线才有色彩。物体表面会吸收一部分光线，反射另一部分光线，反射的光线到达我们的眼睛，被视锥细胞（感知颜色的细胞）和视杆细胞（感知明暗的细胞）所接收，再通过神经传输到大脑，我们就产生了颜色的映像，从而具有色彩感。 我们已经知道，牛顿用三棱镜将光分成了七色，从红到紫正是我们人眼能感知到的颜色范围，从光学的角度看，就是波长从 380 纳米到 780 纳米的光线。低于 380 纳米的，叫做紫外线，高于 780 纳米的，叫做红外线，都是我们人眼无法看到的。 我们已经知道，光线具有波长和振幅，其中，光波的波长反映光波的频率，给人色彩感，光波的振幅反映光的强弱，给人明暗感。人眼中的两种细胞正是分别感知这两种参数，其中，视锥细胞感知波长，视杆细胞感知振幅。所以，我们看到的颜色，其实就是不同波长、不同振幅和不同比例的光线在人眼中的反映。 通常，我们所称的自然光都是指太阳光，物体在自然光下呈现的颜色我们称为物体的固有色。但是，自然界中还有其它的光源，比如月光、闪电、灯光、烛光等，而在其它光源的照射下，物体颜色会发生改变，所以，我们平常所看到的颜色都是物体固有色和光源色的结合。 如果照射到物体表面的全部光都被吸收，物体就呈现黑色，如果全部光都被反射，物体就呈现白色，不过，纯粹的黑白只存在于理论中，现实中没有物体可以全部反射或吸收光线。 1.1 色彩的三要素就像度量衡一样，色彩也需要一个标定体系，像红、黄、蓝、绿这样的简单命名是模糊的，不足以区分不同的色彩。色彩的标定体系就是色彩的三要素：色相（Hue）、明度（Value）、纯度（Chroma）。 色相字面上理解，就是色彩的相貌，用来区分不同的颜色，比如牛顿分解的光谱色：红、橙、黄、绿、青、蓝、紫，就是七种不同的色相。在我们后面会学到的色相环中，色相包括三原色和由它们按不同比例混合成的各种间色和复色，理论上，色相的划分是没有极限的，但是人眼的感知有极限，人眼只能分辨出大约 180 种不同色相的颜色。还要注意的是，无论色相环包含的色块有多少，每两块之间都有本质的区别，色块越多，仅仅是色差越小。 从光学意义上讲，色相的不同是由光波波长的长短和不同光线的比例决定的。 明度简单的理解，就是色彩的明暗程度。每一种色相都有自己的明暗度变化，而且都以白为最高明度，黑为最低明度。色彩的明度受两个因素影响：一是光源色的强弱，光线越强，色彩明度越高；二是黑与白的介入强度，加入黑色可以降低色彩明度，反之，加入白色可以提升色彩明度。 明度在光学角度的本质是光的振幅（即强弱），所以黑和白的介入也可以这样理解，加入黑增强了物体吸收光线的能力，因此降低了它的明度，而加入白增强了物体反射光线的能力，因此提升了它的明度。 除了色相本身的明度变化外，不同色相本身就有明度的差别，其中，黄色明度最高，紫红色明度最低。纯粹的黑白色也有明度的变化，这就是不同级别的灰色。 纯度纯度指的是色彩的鲜灰程度或纯净程度，也叫做饱和度。意思是一个色彩包含该种色素成分的多少，当该色素成分为 100% 时，就是该色相的纯色，所以加入其它任何颜色都会导致纯度的下降，不过，通常降低某色彩的纯度，都是通过混入无彩色系列的黑白灰或混入该色的补色完成的。 从物理的角度讲，一个色相的纯色就是单一波长的光。 黑白灰这三种颜色没有纯度的概念，因此叫做无彩色，其它有纯度的颜色叫做有彩色。 1.2 色彩混合大部分的色彩都可以通过混合其它的色彩得到，但是，一定有几种是最基本的颜色，是不可拆分的，这就是原色。光的三原色是红、绿、紫，颜料的三原色是红、黄、蓝。 任意两种原色混合得到的颜色叫间色，颜料的三间色是橙、绿、紫。 将间色彼此混合，就形成了复色。由于间色本身就是原色混合而成的，复色就意味着是不同比例的原色混合，原色混合的不同比例加上纯度和明度的变化，就构成了我们所看到的丰富的颜色世界。 光线彼此混合，亮度会不断提升，最后形成白色光，这叫做加色混合，计算机的显卡就属于 RGB 加色配色系统。通过改变每种原色电子光束的强度，得到深浅不同的色彩，从而合成丰富的色彩； 颜料彼此混合，亮度会不断降低，最后形成黑色，这叫做减色混合。最后一种混合叫做中性混合，是利用人眼对空间的感知产生的一种混合方式，包括两种，一种是具有运动特点的旋转混合，比如具有两种颜色的陀螺旋转会呈现这两种颜色的复色，另一种是具有静止距离特点的空间混合，例如马赛克镶嵌画和点彩画。 1.3 色相环色相环也称色环，是将色相以一定的变化规律顺序排列形成的一个环，反映了色相之间的数理关系，对色彩的使用具有很大的指导意义。常用的是 RGB 的 3 色相环、瑞士约翰内斯·伊顿的 12 色相环、德国奥斯特瓦尔德和日本色彩研究所的 PCCS 色彩体系的 24 色相环、美国孟赛尔的 100 色相环。所有的色相环都是以 120⁰ 的三原色为基础，在一个完整的圆内等量分割，形成变化均匀的等量过渡色。 下面是伊顿的十二色相环，在 120° 的位置上是 3 个原色，每对原色中间加入一个间色，每对间色中间再加入一个复色，180° 的直径两端叫做互补色。 1.4 色立体色立体是色彩理论的数学模型，是色相、明度和纯度三元素借助三维空间的表达，也是唯一区别每个颜色的标准。 目前，主要的色立体体系有美国的孟赛尔色立体、德国的奥斯瓦尔德色立体、日本色彩研究所 PCCS 色立体、国际照明委员会 CIE 色立体等。虽然各自之间有一定的区别，但是理解了其中一种，剩下的就都很容易理解了。 以如下的孟塞尔色立体为例，水平的圆环等量分成 10 份，分别是红、黄、绿、蓝、紫 5 个基色和它们的 5 个间色，共构成 10 个基础色域，每个色域再等分成 10 分，总计 100 个色相，这个圆环就是我们之前说的色相环；纯色在圆环的最外层，从最外层到圆心，纯度不断降低，直到变成圆心的灰色，纯度一共有 12 个等级；中间的轴代表无彩色，最下方是黑色，最上方是白色，黑白之间还有按明度变化的 9 个灰色，因此，纵轴就代表了明度的变化，每一种色相和纯度确定的色彩在纵向上都有明度的变化。 下面是构造出的完整孟塞尔色立体。 2. 色彩的对比色彩的对比是将两个以上的色彩放到一起，由于相互作用和相互影响而显现出差异的现象。事实上，对比是构成色彩的必要因素，如果整个世界只有一种颜色，没有彼此的对比，那也就失去了色彩的意义。 根据前面所学的一些概念，色彩的对比可以分为：明度对比、色相对比、纯度对比、冷暖对比、面积对比等。 2.1 色相对比因色相差别而形成的色彩对比称为色相对比。将不同色相的色彩并置在一起，可以使对方的特征更加突出。 根据各色相在色相环上距离远近的不同，可以形成不同的色相对比，距离越远，对比效果越强烈，相距 180° 的两个色相对比最为强烈 同类色对比：色相环上距离在 15° 以内的两个色相的对比，对比的效果一般比较弱，通常还需要拉大明度和纯度来进行区别； 邻接色对比：色相环上距离在 15°-30° 之间的两个色相的对比，这样的两个色相就有了一定的区别，对比效果一般比较统一、和谐、柔和，适合背景处理； 类似色对比：色相环上距离在 60°-90° 之间的两个色相的对比，类似色对比一般显得丰满、活泼，即保持了随和统一的优点，又克服了视觉上不够饱满的缺点； 中差色相对比：色相环上距离在 90° 的两个色相的对比，由于差别比较明确，对比效果比较明快； 对比色相：色相环上距离在 120° 左右的两个色相的对比，对比效果比较强烈、鲜明，但过于刺激易产生视觉疲劳，处理不好容易出现烦躁和不安定的感觉； 互补色相：色相环上距离在 180° 左右的两个色相的对比，是最强烈的对比关系，更富于刺激性，但是画面比较直白，不够含蓄和雅致，同意易导致视觉疲劳。 在我所阅读的几个材料中，对色相对比的分类和称呼各有不同，比如，在有的书籍中同类色指的就是距离 15° 的两个色相对比，因此，上述分类只能作为参考，唯一确定的是，距离越远，对比效果就越强烈。 除了以上的色相对比外，还有两种特殊的色相对比 全色相对比：指的是色相环上所有色相都出现，由于人的视觉系统需要全色刺激，这种对比比较协调； 有彩色和无彩色的对比：无彩色又可以称为万能色，无论什么样的有彩色，和无彩色对比都可以呈现和谐的视觉效果。 2.2 明度对比指因明度差别而形成的色彩对比。两种不同明度的色彩并列时，会使明色更亮，暗色更暗。 根据孟塞尔色立体，由黑到白等差分为 9 个等级，加上黑白两色一共 11 个等级。0 级为纯黑，明度最低，10 级为纯白，明度最高。 我们将明度在 0-3 级的色彩称为低明度，明度在 4-6 级的色彩称为中明度，明度在 7-10 级的色彩称为高明度。以低明度色彩为主的构成低明度基调，以中明度色彩为主的构成中明度基调，以高明度色彩为主的构成高明度基调。 注：“……为主” 指该色彩在画面上的面积超过 70%，占绝对优势。 同时，我们将明度差在 5 个级别以外的对比称为强对比（长调对比），将明度差在 3-5 个级别内的对比称为中对比（中调对比），将明度差在 3 个级别以内的对比称为弱对比（短调对比）。 这样，不同的基调和明度对比程度就构成了一个 9 种明度对比方案，称为明度 9 调，分别是：高长调、高中调、高短调、中长调、中中调、中短调、低长调、低中调、低短调。举个例子，高长调指的就是主色调为中明度，明度差在 5 级以上的对比。一个明度 9 调的例子如下图： 2.3 纯度对比因纯度差别形成的色彩对比叫纯度对比，不同纯度的色彩并置，鲜的更鲜，浊的更浊。 和明度相似，纯度也有 3 种色调和 3 中等级差： 高纯度色彩占 70% 左右叫鲜调（高彩对比） 中纯度色彩占 70% 左右叫中调（中彩对比） 低纯度色彩占 70% 左右叫低调（低彩对比） 纯度差为 8 级以上叫强对比 纯度差在 5-8 级叫中对比 纯度差在 4 级以内叫弱对比 因此，纯度也有九调，分别是：鲜强、鲜中、鲜弱、中强、中中、中弱、灰强、灰中、灰弱。 2.4 冷暖对比冷暖色形成的对比，关于冷暖色的定义可参考本文番外部分。根据孟塞尔色相环的十个主要色相，以最暖色橙为暖极，以最冷色蓝为冷极，可划分为 6 个冷暖区 其中，两个冷暖极的对比是最强的，剩下的分三种 强对比：冷极和暖色，暖极和冷色； 中等对比：暖极、暖色和中性微冷，冷极、冷色和中性暖色； 弱对比：暖极和暖色；冷极和冷色；暖色和中性微暖色；冷色和中性微冷色；中性微暖色和中性微冷色。 以暖色为主可构成暖色基调，以冷色为主可构成冷色基调，两者给人不同的感觉，如下表 冷 暖 阴影 阳光 透明 不透明 镇静 刺激 稀薄 稠密 空气感 土质感 远的 近的 轻的 重的 潮湿的 干燥的 理智的 感情的 流动的 静止的 冷静的 热烈的 2.5 面积位置对比形态作为视觉色彩的载体，总有一定的面积，因此面积也会对色彩的表达产生重要影响。 色彩对比与面积的关系有： 色调组合，只有相同面积的色彩次啊能比较出实际的差别，互相之间产生抗衡，对比效果强烈； 对比双方的属性不变，一方增大面积，取得面积优势，而另一方缩小面积，将会削弱色彩的对比； 色彩属性不变，随着面积的增大，对视觉的刺激力量加强，反之削弱。因此，色彩的大面积对比可造成炫目效果； 相同性质与面积的色彩，大面积色稳定性较高，在对比中对它色的错视影响大，反之受它色的错视影响小。 色彩对比和位置的关系有： 对比双方的色彩距离越近，对比效果越强，反之越弱； 双方互相呈接触、切入状态时，对比效果强烈； 一色包围另一色时，对比效果最强； 在作品中，一般将重点色彩设置在视觉中心部位，最易引入注目，如井字形构图的四个交叉点。 注意，色彩对比从不是单一方面的，而是多个方面共同作用。 3. 色彩的调和 对比是手段，调和是目的 色彩的调和是指两种或两种以上的色彩，有秩序、协调和谐的组织在一起，形成和谐统一的色彩搭配。色彩调和是色彩设计的基本法则，色彩调和有两层含义 使有明显差别的色彩经过调整，形成和谐而统一的完美整体； 合理的组织选择色彩搭配，使其形成具有目的性的美的色彩关系。 调和方式包括：同一调和、类似调和和对比调和。 3.1 同一调和同一调和指在色彩的三属性中保持一种属性相同，将另外两种属性进行变化，因此又可以分为同色相调和、同明度调和、同纯度调和，还有一种特殊的无彩色调和。 [图片上传失败…(image-b5b89-1674499821595)] 3.2 类似调和类似调和是类似要素的结合，与同一调和相比，具有稍多的变化，但并没脱离以统一为主的配色原则。 [图片上传失败…(image-518ad2-1674499821595)] 3.3 对比调和对比调和是以强调变化而组成的和谐色彩搭配。在对比调和中，明度、色相、纯度三种要素都处于对比的状态，因此色彩更富于活泼、生动、鲜明的效果。 对比调和的方法有：秩序调和、混入调和、分割调和、呼应调和和面积调和。 秩序调和指在画面组织时时多种色彩呈现一定的秩序规律，常见的有 在伊顿色相环中选择位于等腰三角形、等边三角形、长方形、正方形等几何图形顶点上的色相来组织； 对色彩的色相、明度、纯度做渐变推移处理，使最强和最弱的色彩间呈多个梯次的等差、等比关系，弱化对比强度； 九宫调和，将 9 个按顺序排列好的色块放入九宫格中，源自我国传统的「明堂九室」，是多年累积的视觉经验。 混入调和指遇到不和谐的色彩组合时，选择一个同化元素（色彩要素中的任何一个），将其加入到所有的不同色彩中，使之都含有共同的因素，从而达到和谐的目的。 对于色相，应使所有色彩都具有共同的色彩倾向，比如夕阳下的所有色彩都带有暖暖的橙色，可以看作色相混入的结果；对于纯度，可使所有色彩降低自己的纯度，形成统一的色彩饱和度，比如雨雾中的所有色彩都变得灰蒙蒙的；对于明度，可使所有色彩同时降低或提升明度。 混入调和一般用在色彩调配阶段。 分割调和指遇到不和谐的色彩组合时，在它们之间嵌入金、银、黑、白、灰任何一种颜色，或者嵌入这几种对比色的中间色，使之产生过渡，从而缓解直接对比的强度，使配色达到调和。 分割调和主要用在画面的色彩组织中。 呼应调和指将合适的色彩添加到原画面中，使新色彩和原有色彩达成彼此呼应的调和关系。呼应的内容同样可以从色彩各要素触发，最常用的是色相的呼应。 注意，呼应的色彩对象多为画面中的主体、中心色，起到呼应作用的色彩多在面积、位置、数量、形状等方面处于弱势。 面积调和使某种色彩的面积占据支配地位，可以削弱对比关系。另外，伊顿根据歌德的色彩面积研究成果提出：相等面积比例的红色和绿色能够产生中性的灰色，而黄色和紫色、橙色和蓝色则需要不同的配色比例。用数学比例来显示它们的配比关系为红色:绿色=1:1、黄色:紫色=1/4:3/4、橙色:蓝色=1/3:2/3，这也是著名的“面积对比调和色轮图”。 红色和绿色，黄色和紫色、橙色和蓝色，不论哪一方超过这个比值，都将破坏两者间的调和关系，将两者转化到对比关系中。越接近这种调和比例，对比就越强烈，最终回到最熟悉的红花与绿叶的对比关系之中。 番外冷暖色从色相环的分布看，红橙色类为暖色系，蓝紫色类为冷色系，黄绿色类为中性，黑色感觉为暖色，白色感觉为冷色。色彩明度和纯度的改变也会影响色彩的冷暖感，明亮色偏冷，深暗色偏暖，纯色保持原色的冷暖感，而纯度的降低会使冷暖感趋于中性化。对于太阳光而言，时间也是影响冷暖的因素，一般来讲，早晨的阳光色彩偏冷，傍晚的阳光色彩偏暖。各种不同的光源提供的颜色本身就有偏向，比如，白炽灯的光源色偏暖黄，荧光灯的光源色偏冷蓝。 色调我们常说一幅画、一张照片或一个场景是什么色调的，色调其实指的是占主导地位的一种视觉因素，色彩的三元素：色相、明度和纯度都可以作为色调，比如，从色相上，可以有红色调、蓝色调、黄色调、绿色调等；从色彩明度上，可以有明亮色调、暗色调等；从色彩纯度上，可以有清色调、浊色调、纯色调、灰色调；甚至从色彩的特性上，可以有暖色调、冷色调、中性色调。 一般情况下，当某种类型色彩占据超过 70% 时，就称为该色调。"},{"title":"【chrome调试】使用chrome调试已发布页面的文件代码","date":"2022-03-12T07:01:49.000Z","url":"/2022/03/12/cxy/other/chrome-tiaoshi/","tags":[["开发效率","/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 让这个脚本跑了一晚上，并顺便水了一个视频，骗了两个硬币。熬了一整夜剧都没掉下去 已经编译上线的代码，在需要进行浏览器调试的时候，改文件会相当不方便，有时候只是改一些小条件也需要繁杂的操作，并且浏览器一刷新就又要重新改。为了解决这个问题，可以使用chrome的snippets调试已发布页面的文件，通过拦截network 打开sources - Snippets 2. 点击Select folder for overrides，选择一个文件夹，用于存储需要调试的在线文件。 3. 上方点击“允许”，可以看见文件夹就显示在Overrides里了。 4. 比如在google首页，打开network，随便选择一张图，右键 - Save for Overrides5. 回到source，就可以在你的文件夹中看见这张图了6. 现在可以把它替换成其他logo，比如百度7. 也可以去调试代码，搞些有意思的小事情~比如很久之前有段时间很流行的b站风叶穿行游戏，我是用这种方法改脚本自动跑的成绩 使用chrome的Snippets比较省事的是，即使刷新很多次，只要勾选了Enable Local Overrides就会一直生效，有时候本地未经过编译的代码怎么测试都没有问题，但放到线上就是有奇奇怪怪的问题，如果能调试压缩后的代码也会比较直观~我是一直很喜欢这个方法拉。"},{"title":"【github】使用my-json-server建立线上测试api库","date":"2021-11-27T14:21:49.000Z","url":"/2021/11/27/cxy/other/git-my-json-server/","tags":[["api","/tags/api/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" my-json-server点击访问：my-json-server 1. 创建db.json文件并提交至master/main 2. 请求方式访问 [你的用户名]/[你的仓库名]，可以获取到api列表 比如，我的地址为： 点击页面提供的链接就可以访问到对应的api posts接口数据接口数据"},{"title":"babel配置","date":"2021-10-24T22:21:49.000Z","url":"/2021/10/25/cxy/framework/babel/","tags":[["babel","/tags/babel/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、使用安装 配置文件Babel 有两种并行的配置文件格式，可以一起使用，也可以独立使用。 全项目配置babel.config.json/babel.config.js文件 注：可以是js文件，可以是json文件 Babel在项目根目录中自动搜索babel.config.json文件，或使用受支持扩展名的等效文件 文件相关配置.babelrc.json/.babelrc.js文件 注：可以是js文件，可以是json文件Babel通过从正在编译的“文件名”开始搜索目录结构来加载.babelrc.json文件，直至找到包含package.json的目录下。 二、预设预设是指预先在babel内部设置好的插件，可以直接使用。 示例： 1. preset @babel/preset-env 用于编译 ES2015+ 语法 @babel/preset-typescript for TypeScript 编译ts，替代了ts-loader @babel/preset-react for React使用preset预设在配置文件中添加presets字段，执行顺序是从右到左。 2. targettargets 是需要兼容的浏览器版本 他的值有： android, chrome, deno, edge, electron, firefox, ie, ios, node, opera, rhino, safari, samsung 可以设置成一个string，比如 &gt; 0.5%, last 2 versions, not dead 意思是有大于百分之零点五的人使用，前两个版本，并且没有废弃 3. useBuildInsuseBuildIns需要安装corejs使用 比如： false： 默认值，不做任何语法转换 usage：Babel 将检查你的所有代码，以便查找targets环境中缺失的功能，然后只把必须的 polyfill 包含进来 entry：引入所有的polyfill包，必须在入口文件加入 import &quot;core-js/stable&quot; 才会生效 4. corejs安装的corejs版本号 ####什么是corejs?babel编译只能针对浏览器行为，es6语法规定的，如promise、async/await则无法转义。这种情况下则需要配置corejs。之前这个操作通过babel-polyfill插件，但在7.4之后该插件已被废弃。"},{"title":"坐在那里用仓颉和粤拼打字的练习","date":"2021-09-27T00:25:49.000Z","url":"/2021/09/27/other-yuewenzi/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 給 kap1及 kap6吸 kap1 西 sai1 攻 gung1良 loeng4 眼5體 tai2積 zik1狼狽爲奸gaan1 跟 gan1斤 gan1 鬆sung1綁bong2 h：w珊saan瑚wu4 安on1全cyun4 染jim5 明ming4白baak6 欧au阳joeng4克hak1 戰zin3國gwok3海hoi賊caak ji极kap端dyun qi騎 ke4 海hoi2洋joeng4 契kai3機gei1 源jyun4頭tau4 蓉jung4兒ji4 終身監禁gaamgam"},{"title":"粤拼总结笔记","date":"2021-09-25T00:25:49.000Z","url":"/2021/09/25/other-yueping/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 粤拼教学：点击访问 七个主要元音：aa e i o u yu oe粤语可以多个韵母组合 双元音元音和元音的组合 除了元音与元音的互相组合外，元音一般可以加：m/n/p/t/k/ng 19个声母b p m f d t n l g k h gw kw w z c s j ng 七个主要元音 + maameimouyuoe 七个主要元音 + naaneinonunyunoe 不存在加n 七个主要元音 + ng iu也有后面介绍。 七个主要元音 + p 七个主要元音 + t 七个主要元音 + k iu也有后面介绍。 aa和a长aa 短a oe和eooe发音长（🤮）eo发音短 （鹅噢）eo发音类似拼音（e）粤语里的e发音和拼音e不一样 前面说要补充的ng和k的两个ing ik ung uk"},{"title":"我的喵有时候超级聪明,有时候又超级笨","date":"2021-09-23T04:00:38.000Z","url":"/2021/09/23/diary/diary-sxh%20copy/","categories":[["生活","/categories/%E7%94%9F%E6%B4%BB/"]],"content":" 可撸可抱可亲亲。怎么样都不生气。通人性，很多情况下知道我在说什么。很粘人，我上厕所因为要在浴室，总担心我淹死，只要不让它进来在我脚边蹲着，它就叫的相当凄惨。然后我站起来冲水的时候，它听见冲水的声音，就站起来往外走。明明自己超级害怕浴室。 对人如春风般和睦，对其他物种们如饿狼般凶残。我养了喵之后，屋里再也没有虫了。。自从我亲眼见到。。。算了，有些东西不能细想。 喜欢撒娇娇，我睡觉手摊在旁边，第二天起来手掌上一定会多个喵头。可以明白我的指令，如果我把它摆成一个姿势，它不喜欢就喵喵的反抗，但如果我重复五六次，它就明白了我是想让它保持这个姿势。 熟悉我的说话口气，知道我什么时候生气什么时候不生气。我普通生气的时候赶紧卖萌撒娇娇打滚滚，我生大气的时候就躲起来，可是它不知道我很生气的时候它越躲起来我越生气，特别是往特别脏的床底下钻的时候。 每天喜欢和我玩捉迷藏，它的捉迷藏理念就是我看不见你，那你肯定也看不见我。所以它总是把头藏起来，把身子露在外面，就当藏好了。唔 还有笨的情况就是可能因为从没出过门，是个路痴。我住在七楼左边，如果把它放六楼，或者五楼，或者四楼，它就会对着四五六楼左边一直喵。 每天我回来喜欢在门口迎接，以至于有一次太久不见，我半夜回来之后提着大包小包的行李，它窜到门口来接我，结果不小心给它关外面了。。我还没有意识到，然后收拾东西到四五点，听见外面一直有喵在凄惨的叫，我还想这谁家的喵大半夜的搁这儿叫，结果又收拾了一会儿才发现，吖！原来是大喵在叫。 大喵年纪比较大了，有时候我会很害怕，它的后槽牙也开始出问题了，感觉眼睛好像最近会过敏。 因为断网玩这个东西玩了半个多小时 "},{"title":"【Midjourney】用ai绘画生成的图","date":"2021-08-03T07:23:38.000Z","url":"/2021/08/03/paint/paint-picture2%20copy%202/","tags":[["ai绘画","/tags/ai%E7%BB%98%E7%94%BB/"],["Midjourney","/tags/Midjourney/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 今天在discord玩了特别有意思的ai绘图，生成的图有些很糟糕，有些还是挺好看的~但基本不会生成你脑海中的图，觉得可能适合策划用吧，和设计沟通时可以更具象的去描述他自己想要的那种什么五彩斑斓的黑啥的。。。 记一下我的描述关键字There are many flowers on a skull,32k, 3D shading, Tone Mapping, elaborated, Procreate, the last of us look alike scene, Cinema 4D, ROMM RGB, color grading, retouch, blender, V-ray 下面是两张discord看到感觉比较好的。lake boat blackduck bluesky one pumpkins , intricate, elaborate, by artgerm and greg rutkowski and alphonse mucha, cinematic lighting, 32k, 3D shading, Tone Mapping, Ray Traced, Diffraction Grating, Crystalline, Lumen Reflections, Super-Resolution, gigapixel, color grading, retouch, Blender, V-ray, Procreate, zBrush, UE5, Cinema 4D, ROMM RGB, Adobe After Effects, tight shot, sharp focus –ar 16:9 –test –creative –upbeta santa claus guitarist of the death metal band , HD, ultra detailed, hyper realistic, fine detail etc, cinematic high detailed, octane render, ultra realistic, unreal engine, 8k –ar 9:16 –test –creative –upbeta a 20m-long flying dragon attacking HMS Warrior in the ocean, detailed, cinematic, 4k –ar 16:9 lake boat blackduck bluesky one pumpkins , intricate, elaborate, by artgerm and greg rutkowski and alphonse mucha, cinematic lighting, 32k, 3D shading, Tone Mapping, Ray Traced, Diffraction Grating, Crystalline, Lumen Reflections, Super-Resolution, gigapixel, color grading, retouch, Blender, V-ray, Procreate, zBrush, UE5, Cinema 4D, ROMM RGB, Adobe After Effects, tight shot, sharp focus –ar 3:5 –test –creative –upbeta –upbeta –upbeta one pumpkins , intricate, elaborate, by artgerm and greg rutkowski and alphonse mucha, cinematic lighting, 32k, 3D shading, Tone Mapping, Ray Traced, Diffraction Grating, Crystalline, Lumen Reflections, Super-Resolution, gigapixel, color grading, retouch, Blender, V-ray, Procreate, zBrush, UE5, Cinema 4D, ROMM RGB, Adobe After Effects, tight shot, sharp focus –ar 3:5 –test –creative a knight holding a longsword downward on purple wasteland, dark night with heavy rain and lightening, gloomy, dark, horror –ar 16:9 "},{"title":"【npm】常见参数的区别","date":"2021-07-17T08:01:08.000Z","url":"/2021/07/17/cxy/npm-dependencies/","tags":[["node","/tags/node/"],["npm","/tags/npm/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" dependencies 与 devDependencies的区别：dependencies：它包含的依赖包是需要发布到生产环境中的，是项目正常运行必须依赖的包。devDependencies：它包含的依赖包只在开发时使用，不用于生产环境，如果只需要项目正常运行，则不必安装这里面的包。 ## npm install packageName：安装某个包到项目中 默认情况下，不加参数。会安装包，并将依赖包的名称添加`package.json`中的`dependencies`字段。 1. --save参数 添加--save参数，与默认情况效果相同。会安装包，并将依赖包的名称添加到package.json中的dependencies字段。 2. --save-dev参数 添加--save-dev参数，会安装包，并将依赖包的名称添加到package.json中的devDependencies字段。 npm install： 初始化项目####1. 无参数： 直接初始化 我们常用npm install初始化项目，安装项目所需的依赖。但更深入的细节是：直接使用npm install时，项目package.json中dependencies字段和devDependencies字段中的依赖包都会被安装。 2. –production参数 添加--production安装项目所需的依赖时，只有dependencies字段中的依赖包会被安装，devDependencies中的依赖包不会被安装。 3. –only=dev参数 添加--only=dev安装项目所需依赖时，只有devDependencies字段中的依赖包会被安装，dependencies字段中的依赖包不会被安装。与添加--production的效果刚好相反。"},{"title":"【webpack5】进阶部分总结（一）","date":"2021-05-31T00:31:49.000Z","url":"/2021/05/31/cxy/webpack/webpack2/","tags":[["webpack","/tags/webpack/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" SourceMap1. 解决问题：报错时，报错的是编译后的代码，不好调试。 2. SourceMap是什么：源代码映射，包含源代码和构建后代码每一行每一列的代码映射关系。它会生成一个xxx.map，当构建后代码出错了，会通过xxx.map从构建后代码出错位置，找到映射后源代码出错位置。 3. 使用方法：在webpack的devTool文档中，souceMap的值有很多种情况，但实际开发只关心两种情况 · 开发环境：cheap-module-source-map只包含行映射，打包编译速度快。 · 生产环境：source-map包含行列映射，打包编译速度慢 生产环境下必须得关注列，因为生成模式下代码就压缩成一行了，不关注列根本不知道在哪里报错。 HMR：热模块替换hot module replacement：提升打包构建速度解决痛点：如果只修改了某个模块代码，webpack会将所有模块重新打包，那会很慢。当项目很大的时候，打包速度会越来越慢，所以需要更快些。配置方法：其实是默认的，不需要去写hot:true也可以。 当设置了hot: false时，那么在修改文件时（css），其实整个文件是会重新打包的（浏览器会刷新）。js即使开启了热模块替换（HMR），修改了还是会整个重新加载 one of：每个文件只能被其中一个loader处理webpack的loader会被每个文件匹配一遍，性能会很慢。当确认某个文件只会被一种loader处理时，那么设置匹配到一个loader之后，就不再处理下面的loader。这样也可以提升性能。写法： include exclude开发时会使用第三方的库或插件，比如echarts、lodash等。他们是已经编译好的，在node_modules中，所以处理js文件时，要排除node_modules的文件。 ESlint和Babel的缓存：每次打包都要重新检查eslint和babel编译会损耗性能，所以可以开启缓存。只有第一次打包需要检查eslint和编译babel，之后再次修改只检查和编译修改过的文件即可了。 Thread 多进程现在处理js文件，基本都是用eslint先检查，在用babel编译，再用terser压缩。文件大的时候会比较慢。现在的cpu都是多核的，可以启动多进程。###1. 安装threadsudo cnpm i thread-loader###2. 引入thread-loader位置放在需要处理的loader的前面，比如babel-loader前面。works: threads eslint 中 压缩代码使用的terser虽然是默认的，但如果想用多线程处理，就也需要写出来 optimization中（or plugins中） 文件少的时候没有必要开启，反而更慢的。因为进程启动也是需要时间的。 Tree Shakingtree shaking依赖js模块化，不能用于commonjs，用于描述和移除没有用到的js代码自动配置，无需手动配置。 减少Babel生成文件的体积 babel-runtime点击查看babel对一些公共方法使用了辅助代码，默认情况下辅助代码会被添加到每一个需要它的文件中，这样会使打包体积非常大。为了避免这样的情况，可以将这些辅助函数提出到一个npm包中，然后在用到的时候，再单独引入，这样就做到了复用。这个包就是@babel/runtime，之后每次需要用辅助代码转换时，require进去这个包，就可以减少代码体积。 如：下面这段代码是class语法被转译时加入的辅助代码，如果每个需要转译的class就这么长，代码体积就会很大。 下面是使用@babel/runtime包后，用require引入的方式，替代了上面的辅助代码片段，可以看到使用这种方式代码比较简洁。 但如果每个用到的地方都去手动替换这个包引入，出错几率大，所以就有了@babel/plugin-transform-runtime这个包。可以帮我们自动在需要的地方引入。@babel/plugin-transform-runtime：禁用了babel自动对每个文件的runtime注入，并且使所有辅助代码从这个包引入 压缩图片一个插件。 CodeSplit多入口1. 配置方法entry改为对象，output的filename换成[name].js 2. 提取公共模块如果所有的js都在一个文件中，体积太大了。如果只需要渲染首页js，其他文件不应该加载。所以进行代码分割，生成多个js文件，渲染哪个文件就用哪个js。 单入口： 多入口： 打包出来如图： 3. 按需加载js有些暂时不需要加载的文件，如果一出来就加载，会阻塞之后的资源。所以可以在需要的时候再加载。 我新建了一个count文件，内容如下： 在入口文件中动态加载count。 效果：原本是七个js文件####点击后加载第八个js文件 ####内容是count 如果动态导入的是函数的话，用res.函数名调用4. 为动态导入的模块在编译时重命名webpack默认是可以给动态模块命名的，但有点丑。如果想自己命名的话可以使用内联注释 具体的方法：（1） 动态引入的时候这样写 （2） 在output中配置chunkFilename （3）再次打包，名字就会变成自己的命名了 5. codesplit 统一命名对入口文件来说，可以叫main.js，为了方便开发，像chunk文件可以加一个.chunk.js，然后所有的媒体文件，如果每一个loader里面都去单独指定一遍，会比较麻烦。此时可以在output中配置 6. preload与prefetch共同点： 两者的概念都是预加载，缓存下来资源 只加载不执行 都有缓存 兼容性都很差####区别： preload：告诉浏览器立即加载资源 prefetch：告诉浏览器在空闲时加载资源 preload优先级高，prefetch优先级低。 preload只能加载当前页面用的，prefetch可以加载之后页面用的。现阶段使用preload-webpack-plugin插件 7. network cache8. Core.jsbabel可以转箭头函数、…这样的，但无法转换async、await、promise，这时就需要core.js。 1. 什么是corejs?core-js 它是JavaScript标准库的 polyfill（垫片/补丁）, 新功能的es’api’转换为大部分现代浏览器都可以支持运行的一个’api’ 补丁包集合。 2. 使用方法（1）直接引进首先安装corejs 然后在入口引入import ‘core-js’这种方法的坏处是会将core-js全部引入，会使得包体积很大。所以一般不会这样引。 （2）按需引进将需要的引进去即可。比如用promise，那么就写 安装后是有提示的，不用背。 （3）智能引进配合babel使用。在babel.config.js中配置 PWA 渐进式网络应用程序基于serviceworker实现，但也有很严重的兼容性问题点击访问官网项目离线时候也可以访问。 1. 安装 2. 在入口文件引入 3. 配置webpack插件 4. 重新打包会自动在dist目录下生成service相关文件如图 5. 看效果（1）由于service在dist目录下，所以需要在dist目录部署时才能使用。（2）使用http-server在dist目录下可以模拟启动一个服务器。（3）在network这里调成ofline，可以模拟断网，刷新后，会发现页面还是会加载。由于兼容性差，所以现在的普及率不大。 module chunk bundle的区别Module：能被import的文件，都是模块，无论是js、图片或者别的。在webpack中一切都是模块。Chunk：是多个模块组合而成的，如entry、splitChunk。entry是入口文件，入口文件中import的模块可能不止一个，所以是多个模块组合而成。splitChunk是提取公共代码，很多需要提取的代码被import，所以是多个模块组合而成的。Bundle：最终的输出文件。"},{"title":"【webpack5】基础部分总结","date":"2021-05-24T22:21:49.000Z","url":"/2021/05/25/cxy/webpack/webpack1/","tags":[["webpack","/tags/webpack/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、五大核心概念mode：开发模式development/生产模式productionentry：入口，从哪个文件开始编译output：出口plugin：插件loader：写在module中，加载器 二、基本配置固定在根目录，新建一个文件名为webpack.config.js内容如下： 新建src文件夹，在src文件夹下建立main.js，然后执行npx webpack就会自动打包。 三、处理资源注：多个loader配合使用时，处理顺序是：从下到上，从右到左 的顺序 1. css因为webpack只能识别js资源，所以要处理css需要用loader如加一个css-loader，先安装css-loader在开发环境中，然后在module中加载rules 对于一条规则，也可以使用多个loader，在use中配置。 常见的处理样式文件的loader：css-loader ：处理css文件less-loader sass-loader style-loader：处理style标签内的样式stylus-loader：使用模块化的方法去写css代码stylus：是一种写css的方式，没有花括号没有分号，用缩进的方式去代替大括号，后缀名为styl 2. 图片资源webpack4使用file-loader和url-loader处理图片file-loader:将图片转换为webpack能识别的资源。url-loader:将小于某个大小的图片转换为base64处理图片并不需要loader，webpack5自带默认处理图片，只需要在loader中配置 3. 修改打包资源的路径像输出时，默认js、图片等等都会在一个目录中，现在想要配置成其他目录。 重新npx webpack就变成了这样######图片资源路径的修改：在module/rules的对应loader中配置generator 打包效果： 4. 自动清空上次打包资源webpack不会自动删除上次打包内容，可能会造成重叠，文件很多，可以配置每次打包自动删除之前的打包结果。配置方法：clean：true 5.处理其他资源如视频、字体、excel等等，想统一处理的话，可以如下配置： 官网对于type: assert的几个值的介绍： asset/resource 发送一个单独的文件到输入目录并导出 URL。之前通过使用 file-loader 实现。asset/inline 导出一个资源的 data URI（如，base64）。之前通过使用 url-loader 实现。asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。 6. ESLINTeslint：用来检测js和jsx语法，可以管理缩进、规则是否正确，让代码更加健壮。配置文件：eslintrc.js在webpack4中使用loader处理。在webpack5中使用plugins去处理。 如何使用？根目录新建eslintrc.js，然后在webpack.config.js中配置plugin官网文档：点击查看plugins要用require引入。 简单的eslintrc.js的配置 如果有不需要检查的文件，新建eslintignore可以不检查。 7. babel还是一样，webpack官网搜babel，就会出来babel-loader的配置，复制过来根据自己的需要做修改。根目录新建babel.config.json，其中配置babel 如果不写上面的options，那么会用babel.config.json中的配置去转换代码的。@babel/preset-env：智能预设，允许使用最新的js@babel/preset-react：用来编译jsx@babel/preset-typescript：用来编译ts。 targets：需要兼容的浏览器版本，可以用这些属性 ： android, chrome, deno, edge, electron, firefox, ie, ios, node, opera, rhino, safari, samsung也可以设置成一个string，比如 &gt; 0.5%, last 2 versions, not dead 意思是有大于百分之零点五的人使用，前两个版本，并且没有废弃 useBuiltIns有几个值false：默认值，不做任何语法转换usage Babel：将检查你的所有代码，以便查找targets环境中缺失的功能，然后只把必须的 polyfill 包含进来entry：引入所有的polyfill包，必须在入口文件加入 import “core-js/stable” 才会生效 useBuiltIns 需要搭配 core-js，并且需要在配置文件里面声明。目前core-js最新版本是3.x，也可以指定2.x。npm i core-js -S “corejs”: “3.6.5” 8. 处理html点击查看首先js打包文件可能名字是动态生成的，需要自动引入js到html，才会确保不出错的所以可以自动生成index.html文件，插件为HtmlWebpackPlugin 首先插件会自动生成一个index.html，template中写的index.html意思是通过template里的这个index.html生成一个index.html到dist目录中，所以两个不是一个意思。 三、搭建开发服务器安装webpack-dev-server 四、生产模式的搭建生产模式也就是线上实际使用的代码，会被压缩。因为体积小，加载就快。一般会新建一个config/webpack.dev.js做开发环境的搭建。一般会新建一个config/webpack.prod.js做线上环境的搭建。然后建立webpack.config.js，将两个配置引入。 改动的主要地方1、如果配置文件新建一个文件夹放起来，那么需要将所有绝对路径改为上层路径。2、mode的更改3、开发模式删除output，生产模式删除devServer 常见打包命令：npx webpack：自动打包命令npx webpack serve --config ./config/webpack.dev.js ：运行./config/目录下的webpack.dev.js配置文件，并启动服务npx webpack --config ./config/webpack.prod.js ： 运行./config/目录下的webpack.prod.js配置文件 五、css处理1. css单独提取之前处理css的方法：是将css用css-loader变为webpack可识别的文件后在入口文件main.js使用imort引入css再使用style-loader将css转换为网页中的style内联标签####使用MiniCssExtractPlugin：将style-loader生成的style标签内的css单独提取为css文件，注意必须要安装style-loader 入口文件main.js中： 注： 要生成页面内style标签的形式，那么css-loader和style-loader要同时使用。 要生成单独的css文件，那css-loader和miniCssExtractPlugin.loader要同时使用。（不用style-loader）2. 兼容性处理postcss-loader：兼容性处理，需要安装postcss与postcss-loader，配置在css-loader和style-loader之后，在less和sass的前面，这个是固定的噢在package.json中，配置 然后按照官网去配置loader 3.CssMinimizerPlugin压缩css一般来说，压缩操作在webpack5中都放进optimization中，虽然放在plugins中也可以，不太规范拉。~ 常见的loader总结： raw-loader 将文件导入为字符串 url-loader 将文件作为 data URI 内联到 bundle 中 file-loader 发送一个单独的文件并导出 URL 各种css-loader postcss-loader：兼容性处理，需要安装postcss与postcss-loader，配置在css-loader和style-loader之后，在less和sass的前面，这个是固定的噢##常见的plugin总结： MiniCssExtractPlugin：将style-loader生成的style标签内的css单独提取为文件，注意必须要安装style-loader CssMinimizerWebpackPlugin: 压缩css ESLintPlugin：eslint检查 terserWebpackPlugin：压缩代码 "},{"title":"Proxy略略略略记","date":"2021-05-21T01:03:38.000Z","url":"/2021/05/21/cxy/js/js-proxy/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、proxyproxy就是一个拦截器，拦截了原来的对象之后，可以对这个对象进行自己的更改，也可以防止别人对对象进行某种更改，然后可以输出修改后的monitor，且不影响原对象。 1. proxy的声明（1）可以声明后直接在handler里面写对象 （2）下面这种声明方式 2. get/set/has/等拦截方法 二、 reflect（1） 名称和用法与proxy一样（2） ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。（3） Reflect 对象对某些方法的返回结果进行了修改，使其更合理。（4） Reflect 对象使用函数的方式实现了 Object 的命令式操作。 为什么用reflect，要尽量避免用原生的Object方法，通过Reflect方法调用会比较合理和方便。 在vue3的源码中，原先的数据驱动视图的方法Object.defineProperty被替换成了Proxy来实现，在Proxy内部操作数据时就用了Reflect去调用对象方法。"},{"title":"【node】path.join和path.resolve的区别","date":"2021-05-11T04:01:08.000Z","url":"/2021/05/11/cxy/node-path/","tags":[["node","/tags/node/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 参数拼接 path.join([path1][, path2][, …])path.join()方法可以连接任意多个路径字符串。要连接的多个路径可做为参数传入。 path.join()方法的参数为string，可以加多个参数，最后会拼在一起形成一个地址，若不是string则报错 路径解析：path.resolve([from …], to)path.resolve()方法可以将多个路径解析为一个规范化的绝对路径。其处理方式类似于对这些路径逐一进行cd操作，但resolve在未执行时不会校验其合法性（就是可以不存在这个地址） 相当于 举例： "},{"title":"模块化之AMD和CommonJS","date":"2021-04-13T04:00:38.000Z","url":"/2021/04/13/cxy/js/js-amd/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、AMD概念：异步加载模块的规范，即，加载模块不会阻塞之后代码的执行。AMD是为浏览器环境所设计的，如requirejs。 用法：1. 定义模块AMD的模块，通过define函数定义在闭包中，格式如下： id: 模块名，可选，若不写，则模块为匿名模块。 dependencies: 所要依赖的模块列表，字符串数组类型，可选。若未指定dependencies，默认值为[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]。 factory: 模块的具体实现，类型为对象或函数。 2. 引入模块通过require引入 例子：下面通过requirejs写个例子： 1. 建立如下的目录结构： 2. 在index.html引入requirejs，并通过data-main标识入口文件要注意入口文件是唯一的。 3. 在moduleA、moduleB中定义模块moduleA.js moduleB.js main.js 也可以使用require.config去定义公用路径： 运行结果： 二、CommonJS同步加载模块的规范，即，只有加载完成，才能执行后续操作。CommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，如nodejs。 用法 CommonJS 是同步加载模块，但其实也有浏览器端的实现，其原理是将所有模块都定义好并通过 id 索引，这样就可以方便的在浏览器环境中解析了，可以参考 require1k 和 tiny-browser-require 的源码来理解其解析（resolve）的过程。 更多关于 CommonJS 规范的内容请查看 。 CommonJS的写法比AMD要简单明了很多，不举例了。"},{"title":"模块化之ES6","date":"2021-04-12T04:00:38.000Z","url":"/2021/04/12/cxy/js/js-mkh/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、export命令1. 基本使用 或 2. export也可以输出函数和类 3. as关键字 4. 下面这种写法是错的 正确写法： 二、importimport命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 三、export default1. 基本用法 export default 导出的一定是一个匿名的东西，即使接受的不是匿名函数或变量，因为从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。 2. export default的正确写法 在export default时，import导出不用大括号，除非是解构赋值。 从其他文件导入时： 四、其他注意点1. commonJS和import虽然通过babel转码，commonJS的require和import可以写在一起，可是由于import是静态解析阶段执行，所以在require引入前，import会先于它执行，这样有可能会导致错误。 2. import的简易写法当导出下面的文件时 引入可以这样写 或 3. import 和 export 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 五、import()import()用于动态加载，它返回一个 Promise 对象。下面是一个例子。 import可以用作1. 条件加载 2. 按需加载 3. 动态模块路径"},{"title":"[2021-04-07]水仙花观察日记","date":"2021-04-07T04:00:38.000Z","url":"/2021/04/07/diary/diary-sxh/diary-sxh2/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-06]水仙花观察日记","date":"2021-04-06T04:00:38.000Z","url":"/2021/04/06/diary/diary-sxh/diary-sxh4/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-05]水仙花观察日记","date":"2021-04-05T04:00:38.000Z","url":"/2021/04/05/diary/diary-sxh/diary-sxh5/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-04]水仙花观察日记","date":"2021-04-04T04:00:38.000Z","url":"/2021/04/04/diary/diary-sxh/diary-sxh7/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-03]水仙花观察日记","date":"2021-04-03T04:00:38.000Z","url":"/2021/04/03/diary/diary-sxh/diary-sxh3/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"【chrome插件】Ajax Interceptor修改 ajax 请求的响应文本","date":"2021-04-02T22:21:49.000Z","url":"/2021/04/03/cxy/other/chrome-ajax/","tags":[["开发效率","/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、介绍Ajax Interceptor是一个用于修改 ajax 请求响应的 chrome 扩展，修改ajax请求并返回结果的chrome插件。你可以用该插件修改页面上Ajax请求的返回结果。 二、安装Ajax Interceptor下载安装地址：点击跳转 三、使用 安装完成后，点击图标并展开 点击加号，在network中找到需要修改的请求 将从network获取到的地址和json数据粘贴至框中 点击JSON Editor，即可编辑需要修改的字段 刷新或重新请求后，即可生效。 ✨注意： 1. 第一次安装完，请刷新你需要使用的页面，或者重启浏览器。 2. 当你不需要使用该插件时，建议把开关关上（插件icon变为灰色），以免对页面正常浏览造成影响。 3. 该插件只会在JS层面上对返回结果进行修改，即只会修改全局的XMLHTTPRequest对象和fetch方法里的返回值，进而影响页面展现。而你在chrome的devtools的network里看到的请求返回结果不会有任何变化。"},{"title":"[2021-04-02]水仙花观察日记","date":"2021-04-02T04:00:38.000Z","url":"/2021/04/02/diary/diary-sxh/diary-sxh/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-01] 水仙花观察日记","date":"2021-03-31T20:57:38.000Z","url":"/2021/04/01/diary/diary-sxh/diary-sxh6/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"今天我种下了一朵水仙花，我为它浇了水，施了肥，把它放到了温暖的阳光下，阿~可爱的水仙花请快快长大吧！"},{"title":"react18基础知识梳理","date":"2021-03-25T05:03:49.000Z","url":"/2021/03/25/cxy/framework/react/","tags":[["react","/tags/react/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、jsxjsx中使用js表达式在jsx中js表达式是用&#123;&#125;括起来的，和vue一样。可以调用的有1.常规变量2.原生js3.三元运算符 列表渲染：map使用Object.keys去获取obj列表，再用map循环 style: 使用\\&#123;\\&#123;\\&#125;\\&#125; 条件渲染：三元表达式模版太长时，可以使用括号包裹，并可以换行。 模板精简将重合的部分提出放入函数中，在App()中可以调用 其他注意事项 jsx标签必须闭合，只有一个根节点 jsx标签换行，必须加小括号 jsx属性名采用驼峰命名法，如class-&gt;classNamefor-&gt;htmlfor二、组件1. 函数组件 组件名称必须首字母大写 组件必须有返回值，且返回值为jsx模板，什么jsx都不返回则为null 使用函数名作为组件标签名。 2. 类组件 类组件类组件中必须使用render()方法去返回一个jsx结构，render方法必须要有返回值 类组件必须继承React.Component，并引入react 3. 事件绑定 事件格式为on+事件，函数组件可以直接调用方法，类组件调用用this.xxx方法 传递自定义参数的话，如果同时需要使用事件对象e和自定义参数的话，需要在外层套一层箭头函数传入 三、组件状态1. 类组件中数据驱动视图的基本写法在react hook出来之前，函数组件是没有状态的，所以这里统一通过类组件来讲解。现在，类组件已经不太常用了 使用state，修改state通过setState实现，setState通过继承而来 this有指向问题，要当心。在指定onClick中的方法时，必须要用this.xxx，如果没有传，则为undefined 2. react的状态不可变不要直接去修改state，修改数组和对象要重新使用setState去整体赋值 四、表单处理（input）使用react处理表单，一般有两种方式 受控组件 非受控组件（不常用） 1. 受控表单组件 受控组件就是input框可以被react组件状态控制的组件，可以实现双向绑定 双向绑定的步骤 input绑定onChange或onInput事件 value指定某个变量 事件在类中写好，然后在事件中使用setState去将input的value赋值给变量 2. 非受控组件 组件的状态和表单控件状态不同步(只是表单控件的初值和组件的state一致)。没有双向绑定使用createRef 五、组件通信1. 父子组件通信函数子组件通过参数props，类子组件通过this.props，函数组件可以通过参数解构接收， v也可以通过props接收的。父组件上定义传入子组件的变量 props：1. 只能单向，不能反过来修改。2. 可以解构赋值 如下，现在父组件的state种有一个message变量，想传入到子组件中父组件App.js： 子组件SonF（函数组件） 子组件SonC（类组件） 2. 通过子组件传递给父组件原理：子组件调用父组件传递过来的函数，并且将想要传递的数据当成函数的实参 不管是类组件或是函数组件都是以下步骤： 在父组件建立函数，传入子组件中 子组件用props接收父组件的函数，在函数中传递参数，然后在模板中执行函数 父组件形参接收子组件的传值即可。 以类组件举例： App.js中： 3.兄弟组件通信不想写了，反正就是两兄弟会通过父组件，进行数据的传递。一个子组件将数据传给父组件，父组件再将数据props给另一个子组件。 4.跨组件通信Context父组件像任意的子孙组件传值，可以使用Context。相当于vue的依赖传值。 步骤： 新建一个组件，专门用来导出Provider和Consumer，然后让需要Provider和Consumer的组件引入该组件。不可以在需要的文件中直接用React.createContext去新建，因为在不同文件中生成的是不同实例。 根组件App.js 需要引入的组件ContextComponent 中间组件SonA的内容 子孙组件内容 六、组件进阶1. children 属性（slot）children存在于props里面，所以可以通过解构赋值，也可以通过props.children去获取使用。表示该组件的子节点，只要组件内部有子节点，props中就有这个属性。类型包括： 普通文本 普通标签 jsx 函数 2. props校验有时候从父组件传过来的props，类型会不正确，比如子组件需要一个数组，而父组件传过来一个number，那么遍历就会出现问题。这种情况下，就需要props校验。相当于vue的 支持类型： 基础类型（array、bool、func、number、object、string） react元素类型： element 必填项： isRequired，也就是传属性时不能缺少这个属性。 特定的结构对象：shape 步骤： 安装prop-types 在需要的组件中导入prop-types 对应组件.propTypes = &#123;&#125;设定规则如下，表示名为ListItem的组件有一个lists被传进来，类型必须为array 完整代码： 七、组件生命周期只有类组件才有生命周期，因为类组件要实例化，而函数组件不需要。 初始化阶段：1. 执行顺序：constructor –&gt; render –&gt; componentDidMount2. 功能：constructor：创建组件时最先执行，初始化时只执行一次，现在用的不多了。render: 每次渲染时都会触发，所以不要在里面调用setState，有可能造成死循环。componetDidMount：组件挂载（dom渲染完成）后执行，初始化的时候只执行一次。所以一般进行网络请求和dom操作。 更新阶段：1. 执行顺序：render –&gt; componentDidUpdate2. 功能：render：每次渲染都会触发componentDidUpdate：组件更新后（dom渲染完成）触发。两个钩子里面都不要调用setState() 卸载阶段：componentWillUnmount：组件卸载（从页面中消失）时触发，一般用来执行清理工作（比如：清理定时器等） 三个阶段，五個鉤子 八、React HooksHooks：使函數組件更強大，更靈活的鉤子現在hooks暫時只能在函數組件中使用。因為它的作用就是為了讓hooks擁有狀態。 1. useStateuseState提供給變量修改數據的方法。 步驟： 從react中引入useState 使用useState聲明變量，聲明修改變量的方法[變量，修改變量的方法] 使用修改變量的方法修改數據注意：不能直接修改原值，必須調用修改變量的方法，在下面的例子就是setCount 2. useState數據的讀取和修改一句話：useState生成的初始值只在初次渲染生成，之後再次生成j都是用setstate修改得到的值！注意事項： 只能出現在函數組件中 不能用於if/for等嵌套結構中，只能寫在函數組件最外層處。3. useEffect 函數副作用對於react組件來說，祝作用時根據數據渲染ui，那麼副作用就是除此之外的全部操作。 常見的组件副作用 數據請求ajax發送 手動修改dom localStorage操作 4. 当watch用：useEffect有两个参数，第一个是函数，第二个参数是数组，用来存放变量，当数组存放变量发生改变时，第一个参数逻辑处理函数将会被执行（类似于监听）vue的watch不一定是在dom渲染完畢之後執行，而useEffect一定是在dom渲染完畢後執行。5. 可以作为生命周期钩子使用，在每次render後執行（dom渲染後觸發） + 没有第二个参数时,组件的初始话和更新都会执行 + 空数组时，初始化调用一次之后不再执行，相当于componentDidMount + 有一个值的数组时，该值有变化就执行 + 有多个值的数组时，只要有一个值有变化就执行 4. useRef 用於獲取真實dom的方法 函數組件的useRef相當於類組件的createRef綁定在元素上獲取該元素，綁定在組件上可以獲取該組件的所有屬性和方法。 步驟： 引入useRef 使用useRef新建一個變量，傳入參數為null，在其中有current可以獲取到組件信息或dom元素 將該變量通過ref綁定到元素或組件上 假設現在有一個Test組件 需要在App組件中獲取Test組件的方法和屬性 testRef可以獲取到Test組件的方法與屬性，h1Ref可以獲取到h1這個dom元素。 對比類組件的createRef的用法 4. useContext 函数组件中的通信在类组件中使用createContext进行后代组件通信。函数组件中也需要使用createContext，两者在祖先组件中的写法一致。但函数组件中Consumer的部分需要变成使用useContext 在SonB这个后代组件中，使用useContext去代替Consumer，就可以获取到App传过来的count数据 九、react-router1. 安装router ###1. BrowerRouter和HashRouter作用：包裹整个应用，一个react应用只需要使用一次两种常用的router: HashRouter和BrowerRouter HashRouter相当于vue的Hash模式地址域名后面会多一个#，比如 BrowerRouter相当于vue的History（html5）模式但这种模式需要后端配合，这个地址相当于前端为了好看生成的，不是真实的地址。如果直接访问某个二次跳转的链接，有可能404 2. Link用来指定导航链接 3. Routes符合Link条件的试图会渲染到Routes里。 4. Route用于指定导航链接，完成路由匹配。相当于vue的router-view 5. 编程式导航 - 跳转***react-router的跳转可以分为用Link跳转，和用useNavigate跳转两种。这里主要说useNavigate***的用法。 useNavigate直接跳转：对应vue的$router.push()，会在地址栈留下记录，可以回退。 useNavigate添加&#123; replace: true &#125;参数：对应vue的\\$router.replace()，不会在地址栈中留下记录，无法回退到该页面，一般用于登录后的回退。 步骤： 导入useNavigate 声明一个useNavigate方法 使用该方法，传入参数，第一个参数为地址，第二个参数为补充项，如上面说的是否要使用replace模式。 完整例子： 6. 跳转传参 searchParams &amp; paramssearchParams 和 params的区别：searchParams：地址为/index?name=xxx&amp;id=xxx的形式，可以获取问号后的参数params：地址为/index/111的形式，可以获取到111 #####步骤： 首先引入useSearchParams或useParams 初始化变量 通过变量获取参数若为searchParams，则使用以下的的形式获取： 若为params，则使用一下的形式获取： 7. 二级路由在route里面再配置route，然后在需要二级页面的地方导入outletApp.js中 Layout.js中 "},{"title":"typescript总结笔记","date":"2020-09-10T07:20:18.000Z","url":"/2020/09/10/cxy/other/typescript/","tags":[["typescript","/tags/typescript/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 什么是typescript？typescpt是一种静态类型语言。添加了类型的js，完全兼容js，写完后可以编译为js我觉得是用另一种更为严格和规范的方式去写js##静态类型语言静态类型语言中，变量的类型必须先声明，即在创建的那一刻就已经确定好变量的类型，而后的使用中，你只能将这一指定类型的数据赋值给变量。如果强行将其他不相干类型的数据赋值给它，就会引发错误。在静态语言中，一旦声明一个变量是int类型，之后就只能将int类型的数据赋值给它，否则就会引发错误，而动态类型则没有这样的限制，你将什么类型的数据赋值给变量，这个变量就是什么类型 强类型 VS 弱类型强弱之分，体现在对类型的检查严格程度上，弱类型语言对于变量类型的检查比较宽松，容忍隐式类型转换这种事情的发生。何为隐式类型转换，一般有两种形式： 相关类型之间隐式转换 不相关类型之隐式间转换一、基础类型1. ts有哪些基础类型？布尔、数字、字符串、数组、元祖、枚举、any、void、null、undefined、never、Object2. 定义数组： 3. 定义元组： 注意：访问越界元素会报错 4. 枚举：定义类型 5. nevernever是任何类型的子类型，可以复制给任何类型，但没有类型是never的子类型或可以赋值给never类型（除了never本身），即使是any也不能复制给never。never经常用于抛出异常的函数，或是死循环。 变量也可以是never类型，当他永不为真的类型保护所约束时。 6. voidvoid表示没有任何类型。和any完全相反。函数没有返回值时可以写void void变量没有什么作用，因为void变量只能赋值null或undefined。###7. 类型断言我可能有时候比ts更了解这个变量是什么类型，这时就可以用类型断言语法有两种第一种：尖括号 第二种：as 二、变量声明ts用const、let代替了var 三、接口1. 对象类型定义一个类型，让变量按照这个类型来具体实现 ###2. 函数类型 上面代码意思是，一个函数类型叫Square，它应该有两个参数，一个source类型string，一个subString类型string，返回boolean类型的值。 3. 类类型 接口亦可以继承 四、类 1. public、protected、private的区别：protected：可以继承，不可以在类外部使用private：不可以继承，不可以在类外部使用public：可以继承，可以在类外部使用 2. readonly： 3. getter、setter 4. 静态属性、静态方法使用static定义，只能用类名.方法/属性使用 5. 抽象类与抽象方法 6. 抽象类和接口的区别（1）abstract类abstract类是定义用来被继承的类。抽象类中可以有抽象方法，可以有普通方法。非抽象类也可以。但抽象类不能创建对象，普通类继承抽象类必须实现其方法，或将其定义为抽象方法。抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。 1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。2）抽象类不能用来创建对象；3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。4）非抽象类中可以有抽象方法，比如继承的时候，如果子类不想实现父类的抽象方法，则必须将该方法也定义为抽象方法(2) interface接口： 是对类的补充接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误） 而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现 抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。 五、函数 六、泛型（尖括号）1. 泛型变量一个函数在公用的时候，若同一个参数可能有多个类型or可能有多种返回值的情况下，如果写成any会不严谨 用下面这个就可以保证返回值与参数相同类型 2. 泛型类、泛型接口 七、枚举 八、高级类型1. 类型别名 2. 交叉类型也就是用’&amp;‘ 3. 联合类型也就是用’|’let arg: number | string = ‘sfsdfds’###4. 类型保护和类型断言typeof和instanceof （1）typeof （2）instanceof只对类有用。 九、Symbols十、迭代器for of 与for in 十一、模块（原：外部模块） “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 ECMAScript 2015里的术语保持一致，(也就是说 module X &#123; 相当于现在推荐的写法 namespace X &#123;)。 用法和js一致。 十二、命名空间（原：内部模块） “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 ECMAScript 2015里的术语保持一致，(也就是说 module X &#123; 相当于现在推荐的写法 namespace X &#123;)。 1. 命名空间的基本用法在一个文件中，有时候有些变量是不想定义为全局的，比如有ab两个类被c类引用，如果都定义为全局的变量，不好维护容易出错，可以只对外暴露出c类接口（export class C）给该文件其他部分使用。。 2. 复用将逻辑与业务分离，可以将一个namespace用另一个namespace引入如下面，用page引入components的命名空间components.ts文件： page.ts文件： 由于这种写法很难搞懂命名空间是在哪个文件中，所以最好在path.ts头部中用三斜线指定进行指定 ###3. 子命名空间 十三、三斜线指令三斜线指令仅可放在包含它的文件的最顶端。放在其他地方则会被当做注释去解析的。包括下面几个指令，去看官网吧 tsc -w 监听，自动编译tsc init 生成tsconfig.tsconfig的配置：outFileoutDirmodulerootDirtarget 十四、声明文件使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。说人话：就是第三方库定义的一些东西直接引进来ts识别不了，ts只能识别js有的和ts已经定义的东西。所以需要另外写一份声明文件告诉ts，然后ts就知道这个第三方库有这些变量就不会报错了。文件叫*.d.ts declare 就是用在声明文件中的。 全局变量 全局函数 带属性的对象 函数重载 可重用类型（接口） 可重用类型（类型别名） 组织类型 类 十五、项目配置tsconfig.json"},{"title":"【vue】生命周期","date":"2020-08-21T10:16:25.000Z","url":"/2020/08/21/cxy/vue/vue-defineProperty%20copy/","tags":[["vue","/tags/vue/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、vue2的生命周期vue生命周期分别有创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载利用钩子函数完成对应的项目效果####beforeCreate( 创建前 )在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据 created ( 创建后）在实例创建之后使用，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。完成了data 数据的初始化。因为未挂载，所以el不可用。 可以使用数据，更改数据，在这里更改数据不会触发updated函数。 beforeMount (挂载前)在挂载开始之前被调用,在这个阶段是获取不到dom操作的,把data里面的数据和模板生成html，完成了data等初始化,注意此时还没有挂在html到页面上 mounted (挂载后)用于挂载之后使用，这时 el 被新创建的 vm.$el 替换了。在这个时候可以获取到dom操作，也可以通过vm.$el获取元素。比如可以获取到ref等，操作dom，在这个时候只能调用一次ajax，在这个时候el和data都可以获取的到注意这个不能保证所有子元素挂载完成了！vm.$el：vue实例使用的dom根元素。 beforeUpdate (更新前)在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。 updated (更新后)在由于数据更改导致地虚拟DOM重新渲染并更新完毕之后会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，但是在服务器端渲染期间不被调用，可以用于监听某些数据的时候使用钩子 beforeDestroy（销毁前）实例销毁之前调用。在这一步，实例仍然完全可用。可以用于销毁计时器时候使用，为了防止跳转到其它页面该事件还在执行，还可以清除dom事件等 destroy（销毁后）实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。 activated被 keep-alive 缓存的组件激活时调用。 deactivated被 keep-alive 缓存的组件失活时调用。 二、vue3的生命周期大多相同，只是新增了renderTracked与renderTriggered，并且将destroy和beforeDestory改成了unmounted和beforeUnmounted renderTracked在一个响应式依赖被组件的渲染作用追踪后调用。这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。 renderTriggered在一个响应式依赖被组件触发了重新渲染之后调用。这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。 serverPrefetch当组件实例在服务器上被渲染之前要完成的异步函数。 父子组件生命周期的调用顺序created：先初始化父组件，再初始化子组件mounted：先渲染子组件，再渲染父组件beforeupdated：先调用父组件，再调用子组件updated：先更新子组件，再更新父组件beforedestroy：先调用父组件，再调用子组件destroy：先调用子组件，再调用父组件 实测的图"},{"title":"【vue】vue2和vue3分别实现数据侦听","date":"2020-08-21T10:16:25.000Z","url":"/2020/08/21/cxy/vue/vue-defineProperty/","tags":[["vue","/tags/vue/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" Object.defineProperty(obj, prop, descriptor)在js原生对象中，实现数据侦听的方法就是defineProperty。 使用示例如下： vue2中使用defineProperty中实现数据侦听建立一个html文件，dom结构如下 编写侦听函数 实现侦听的函数 当数据更改时，更新视图 proxy拦截代理，拦截对应的操作后，进行处理，会新生成一个对象，然后通过proxy生产的对象去改变原对象。 使用方法："},{"title":"class总结","date":"2020-07-21T05:03:15.000Z","url":"/2020/07/21/cxy/js/js-class/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、基本写法类的方法、属性、静态方法、静态属性、私有方法、私有属性继承、接口（没有）、抽象（没有）、final（这个有） 构造函数constuctor 实例属性可以使用this.xxx写在constructor方法中，也可以写在类的顶端。 实例属性不存在于原型链上，而是存在于单个实例中。如果constructor写了赋值，在创建实例时却没有赋值，那就会变成undefined拉 原型属性（使用prototype赋值）存在于原型链，用“类.prototype.属性名”可以调用到。 类的方法是默认定义在原型链上，供所有实例共享的。但在类内部定义的变量是属于单个实例的，不存在与原型链上。如果想在类外通过赋值的方法，定义属于原型链的属性，当然所有实例也都可以共享，但一旦修改所有实例的该属性都会修改，其实没有什么意义还容易出问题。所以虽然可以在原型链上定义实例，但一般来说没必要。除非真的确定这个属性在所有的实例上都是相同的。 getter、setter方法在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。get/set方法定义的变量不需要提前定义。set方法必须要传入value name在类内部，可以使用类名.name去调用，获取类的名字 Class表达式类可以用表达式的形式定义，在类外部调用时只能用表达式调用，如下面的例子，外部只能使用MyClass调用，但MyClass的实例还是属于Me 属性表达式类的属性名可以用表达式表示 ####静态属性静态属性定义在类上，不在实例上，所以只能用类名.属性名调用。定义静态属性的方法是在class外部，用类名.属性定义该属性 es6的规定，class内只有静态方法，没有静态属性，但现在有个提案是用static在内部定义静态属性，所以也可以如下定义 静态方法的定义： 私有方法和私有属性使用#定义私有属性。只能在类的内部使用(this.#count)，无法继承，无法在外部调用。暂时没有提供私有方法。 ####静态块有时候在类内部有一部分代码，是不用每次创建实例时都去调用的，比如静态属性的赋值。所以es2022规定了静态块，在类生成时只执行一次，主要用于对静态属性的赋值，之后新建实例就不再运行了。 new.target该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令，new.target会返回undefined ##二、类的继承 super方法与super关键字1. super方法super方法可以且只能在子类构造函数中调用，用来调用父类的constructor()，在子类的构造函数中必须要调用一次super() 2. super关键字super作为对象时，在普通方法中，指向父类的原型对象（Point.prototype）；在静态方法中，指向父类。由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。因为类中定义的方法本就是定义在原型链(prototype)上，所以super可以调用到类内的方法。但super没办法调用到类内的变量，因为类中定义的变量是存在于实例的。 在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。 在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。 "},{"title":"【练字】硬笔书法","date":"2020-05-24T05:23:38.000Z","url":"/2020/05/24/paint/paint-picture3/","tags":[["练字","/tags/%E7%BB%83%E5%AD%97/"]],"categories":[["练字","/categories/%E7%BB%83%E5%AD%97/"]],"content":" 字没几个，写都写了一天而且我发现即使练了字，我正儿八经写字还是那么难看虽然看起来没几个字，其实我写了一下午 "},{"title":"axios的基本使用","date":"2019-11-12T07:20:18.000Z","url":"/2019/11/12/cxy/other/axios/","tags":[["axios","/tags/axios/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、axios的发送类型和restful api一样axios基于promise，它支持promiseapi 1. 基本用法 或 注1：还有增（post）删（delete）改（patch/put）查（get）这些，以及head和option。 注2：OPTIONS方法返回有关API 的信息（方法/内容类型）: 2. 并发axios.all(iterable)###3. axios.create()###4. axios可以拦截请求和响应在请求和响应被then或catch之前做某些操作。比如请求前加入token，响应时如果返回数据错误，可以跳转到登录页 request的config里返回的，最后可以返回data以继续下面的请求 response里面返回的，最后也是return以用于响应 5.客户端支持xsrf防御6.axios常见的配置："},{"title":"微信小程序相关","date":"2019-07-21T11:39:12.000Z","url":"/2019/07/21/cxy/review/wechat/","tags":[["微信小程序","/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 初始化项目文件 根目录：app.json：项目配置文件，可以配置页面包括：page、tabbar、window、plugin等等app.js：每个页面都会去处理的方法。比如判断当前版本是否最新，还有是否有登录信息等等。app.wxss：全局的样式文件project.config.json：项目配置文件。可以设置一些编辑器的样式，设置一些js编译为es5是否禁用严格模式、上传时是否压缩、分包分不分等，是开发时的设置，在小程序侧边可以直接打钩设置。project.private.config.json：很多时候我们需要进行开发调试，利用微信开发者工具的预览功能在真机上查看实现效果。为了方便调试，我们会设置编译模式。但是编译模式的改动会写入 project.config.json 文件的 condition 字段中，而项目只有一份 project.config.json 文件。所以在团队协作的时候，每个人都在往里加入自己的编译模式，这给团队造成了一点麻烦。解决方案如下： 在 .gitignore 文件中添加 project.config.json、project.private.config.json 为项目引入 project.config.json.example 文件作为项目配置文件统一模板 团队成员使用 project.private.config.json 作为个人配置（此配置文件会优先使用） sitemap.json：是否允许微信索引（爬虫相关）pages文件夹：存储页面。##wxss wxml jsskyline WXSS和webview：skyline的性能更好些，不支持css animation###wxss的常用组件####视图容器swiperswiper-item moveable-areamoveable-view scroll-viewmatch-mediaroot-portal（position: fixed）viewblock 基础内容grid-viewlist-viewiconprogressrich-texttext 表单组件buttoncheckboxcheckbox-groupforminputslidepickerpicker-viewradioradio-groupswitchtextareaimagemap 小程序框架小程序生命周期点击查看文档onLaunch：全局app.js中的，他的触发比page中的onLoad要高onLoad：页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。onShow：页面显示/切入前台时触发。onReady：页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。onHide：页面隐藏/切入后台时触发。如 [wx.navigateTo]( api/route/wx.navigateTo.html) 或底部 tab 切换到其他页面，小程序切入后台等。onUnload：页面卸载时触发。如wx.redirectTo或wx.navigateBack到其他页面时。 其他page内的事件onPullDownRefreshonReachBottomonShareAppMessageonPageScroll##事件用bind或catch绑定（catch阻止向上冒泡）capture-bind（捕获）bindtapbind:touchstartbind: longpress还有一些单独组件的事件可以看看文档，比如swiper的bindtransitionbindanimationfinish等等等吖吖吖##常用api整理this.setDatawx.request wx.navigateTo：保留当前页面，跳转到应用内的某个页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。 wx.redirectTo：重定向。使用 wx.navigateBack 不可以返回到原页面 wx.createVideoContext(‘xxx’);xxx是video标签的id wx.showToast wx.getStoragewx.setStoragewx.clearStorage() wx.showShareMenu wx.canIUse wx.hideNavigationBarLoading() //在当前页面隐藏导航条加载动画wx.stopPullDownRefresh() //停止下拉刷新 面试题1、简单描述下微信小程序的相关文件类型?2、小程序的双向绑定和vue哪里不一样?3、小程序页面间有哪些传递数据的方法?使用全局变量实现数据传递app.js中定义globalData，然后在单独的文件中使用 使用navigateTonavigateTo的url后面跟?参数也可以实现数据传递，在新页面onLoad方法中使用 在新页面中 wxs定义公共工具类，比如叫utils，可以使用import引入 wxs也可以导出模块 使用getStorage本地缓存的清理时机跟代码包一样，只有在代码包被清理的时候本地缓存才会被清理。 4、小程序的生命周期5、如何下拉刷新在app.json中，或者在对应的json中设置 在钩子函数onPullDownRefresh中，监听下拉刷新，调用setData去更新数据，设置flag，让更新不会多次给重复触发中。请求成功后，调用wx.stopPullDownRefresh去停止下拉刷新。 6、bindtap和catchtap停止冒泡 7、wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别?wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面wx.redirectTo()：关闭当前页面，跳转到新的页面（类似重定向）。但是不允许跳转到 tabbar 页面wx.switchTab()：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面wx.navigateBack():关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层wx.reLaunch()：关闭所有页面，打开到应用内的某个页面###8、登录的流程点击查看：登录流程描述 9、app.json 全局配置文件描述pages : 用于存放当前小程序的所有页面路径window : 小程序所有页面的顶部背景颜色，文字颜色配置。tabBar : 小程序底部的Tab ,最多5个，最少2个。 10、小程序运行机制热启动 ：假如用户已经打开了某个小程序，在一定时间内再次打开小程序的话，这个时候我们就不再需要重新启动了，这需要把我们的后台打开的小程序切换到前台来使用。冷启动：用户首次打开小程序或被微信主动销毁再次打开的情况，此时小程序需要重新加载启动。 11、小程序什么时候会主动销毁？小程序在进入后台之后，客户端会帮我们在一定时间内维持我们的一个状态，超过五分钟后，会被微信主动销毁. 官方也没有明确说明 什么时候销毁， 在不同机型表现也不一样， 2019年开发时：时间官方文档没有说明，但是经过询问一般指5分钟内 2020年开发时：时间官方文档没有说明，实测安卓没有固定时间，内存足够情况下，有时候一天了还在，有时候几分钟就没了。 12、小程序怎么跟随事件传值在 页面标签上通过 绑定 dataset-key = value ， 然后绑定点击通过e.currentTarget.dataset.key 来获取标签上绑定的值。 13、小程序支付小程序有一个统一下单的api接口。点击查看：微信支付点击查看：云支付 小程序或公众号调用微信云托管，在微信云托管中调用统一下单接口，参数中带上接收异步支付结果的服务名称和其所在云环境ID 统一下单接口返回的成功结果对象中有 payment 字段，该字段即是小程序端发起支付的接口（wx.requestPayment）所需的所有信息 小程序端拿到后端结果，调用 wx. requestPayment 发起支付 支付完成后，在统一下单接口中配置的云托管服务将收到支付结果通知，具体详见结果回调开发中遇到的问题热启动和冷启动的问题。 "},{"title":"restfulAPI设计规范","date":"2019-07-10T07:20:18.000Z","url":"/2019/07/10/cxy/other/restfulApi/","tags":[["api","/tags/api/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 1.协议遵守https协议2.api应该有单独域名3.加上版本号4.由于restfulapi中url表示一种资源的集合，而不再是一个功能一个url，所以网址中不能有动词，应该全是名词，且与数据库的表名一一对应，也由于是一种集合，所以api的名词尽量为复数5.用http动词去表示资源的具体操作类型，如put/patch/post/get/delete/增删改查等6.如果涉及分页这种返回结果相当多的情况，api也可以提供一些参数，如?limit=10&amp;page=27.有单独的状态码"},{"title":"npm相关","date":"2019-06-03T03:11:11.000Z","url":"/2019/06/03/cxy/other/node-n/","tags":[["node","/tags/node/"],["npm","/tags/npm/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" -S和-D的区别npm i –save-dev xxx同npm i -D xxx安装到开发环境在package.json中： npm i –save xxx同npm i -S xxx安装到正式环境在package.json中： package-lock.json的作用比如你的packgae.json的依赖是”react”: “^17.0.2”，因为有标识符^，所以如果react模块有在17大版本下更新的小版本17.0.3，npm install时候会自动安装17下的最新版本17.0.3现象：在前景情况下，你本地是”react”: “^17.0.2”，如果这时候react更新”react”: “^17.0.3”，别人npm install的时候，安装就是”react”: “^17.0.3”。这样导致你们版本不一致，可能引起一些相关错误。解决：package-lock.json：简单来说就是锁定安装模块的版本号。就是在npm install的时候，记录各个模块的版本信息和下载路径，这样别人拉项目npm install时候， 就会依据packgae-lock.json去安装”react”: “^17.0.2”，保证大家依赖一致并且安装模块速度也能提高。"},{"title":"【第10章】运行环境","date":"2019-04-16T06:06:12.000Z","url":"/2019/04/16/cxy/js/js-enviro/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、从输入url到渲染出页面的整个过程 dns解析： 域名—&gt;IP 浏览器根据IP地址向服务器发起http请求 服务器处理http请求，并返回给浏览器 根据HTML生成Domtree，根据Css生成cssom，再整合dom树和cssom整合的rendertree 根据render tree渲染页面 遇到script标签则暂停渲染，优先加载并执行js代码，完成再继续，直至渲染完成。二、window.onload 和DOMContentLoaded的区别 三、性能优化的方案比如防抖、节流、懒加载，可以把面试官往这个方向引入####1. 原则（1）.多使用内存、缓存或其他方法（2）减少CPU计算量，减少网络耗时（空间换时间）####2. 方法（1）让加载更快：压缩代码（webpack mode production）服务端可以做打包（2）减少访问次数：合并代码（利用webpack、雪碧图）、ssr服务器端渲染，缓存（3）使用更快的网络： cdn ，cdn 内容分发网络，根据区域去访问不同地点的服务器。。。这样就会更快些（4）让渲染更快： css放在head js放在最下面 尽早开始执行js，用DOMContentLoaded触发事件 懒加载，图片上滑加载更多，如下7 对dom查询进行缓存，如下8 避免频繁DOM操作，合并到一起插入DOM结构 节流、防抖（体验性优化） 下面几条是对上面四条的补充 （5）缓存：5.1静态资源加hash后缀，根据文件内容计算hash 5.2文件内容不变，则hash不变，则url不变 5.3 url和文件不变，则会自动触发http缓存机制，返回304 （6）ssr：服务器端渲染：将网页和数据一起加载，一起渲染 | 非ssr（前后端分离）：先加载网页，在加载数据，再渲染数据 （7）懒加载 （8）缓存dom查询 4.防抖debouce在频繁输入时，监听输入事件会频繁触发，像google搜索时，如果每一次输入都触发请求，请求量会很大，影响性能了。所以设置一个在输入停止一小段时长后，再触发请求。会大量的减少请求量。 5.节流 封装这里用到了闭包，之前在作用域和闭包中说过：闭包是由函数以及声明该函数的词法环境组合而成的闭包的变量不会得到释放闭包会随着函数的创建而被同时创建所以下面的timer向外层查找到的是形成的闭包的词法环境中的timer 6.xss（1）. 问题：常见的web前端攻击方式有哪些？比如我写了一篇博客，博客里面有script标签，该代码执行获取用户cookie的操作，任何用户访问该博客后，就会执行该代码。被获取到cookie之后，将cookie发送到我的服务器，这样就会拿到用户的敏感信息（2）. xss预防：// 替换特殊字符（&lt; –&gt; &lt; &gt; –&gt; &gt;）前端后端都要替换。 7.xsrf（1）概念：用?带参数去访问服务器，得到服务器数据（2）预防方法： 使用post接口、增加验证：例如密码、短信验证码、指纹"},{"title":"【第9-1章】http缓存策略","date":"2019-04-14T04:23:21.000Z","url":"/2019/04/14/cxy/js/js-http11/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 懒得重写了，直接从笔记截图过来。"},{"title":"【第9-2章】http协议","date":"2019-04-14T04:23:21.000Z","url":"/2019/04/14/cxy/js/js-http22/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 懒得重写了，直接从笔记截图过来。"},{"title":"【第9章】http与restfulAPI","date":"2019-04-12T07:33:35.000Z","url":"/2019/04/12/cxy/js/js-http/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" const { get } = require(“http”); 状态码类型 1xx 服务器收到了请求 2xx请求成功 如200 3xx重定向 如302 4xx客户端错误 5xx服务端错误，如500 常见状态码：200 请求成功301 永久重定向（配合location，浏览器记住了该网址返回了301，然后浏览器之后会永久自动处理到新的网站，如域名到期换新域名的情况）302 临时重定向（配合location，浏览器记住了该网址返回了302，但下次访问浏览器还是会访问到旧地址，如百度首页搜索的二级跳转、短网址等）点击链接：为什么百度需要二级跳转重定向？简单说，是为了打点。点击链接：短网址的作用 简单说，微博字数那么长，再来个那么长的网址真心hold不住。304 资源未被修改（缓存了）请求过来的数据没有改变404 资源未找到401 用户未授权 比如密码错误、用户名错误403 用户得到授权，但访问时禁止的500 服务器错误504 网关超时 (服务器端的操作有超时) 新method可以写的状态码/* 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - []：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - []：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - []：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。*/// “幂等性”指的是 1 次或 N 次的副作用(对系统造成的影响)相同，而不是返回结果相同，因此 GET 请求总是幂等的。// 无论一个操作被执行一次还是多次，执行后的效果都相同。比如对某资源发送GET请求，如果访问一次和访问十次获得的数据一样，那么就说这个请求具有幂等性。 http methods1. 传统methodsget获取服务器数据post向服务器提交数据 2. 现在的methods点击链接：restful api 的设计方法（1）get获取服务器数据 ()（2）head 和get类似，但服务器在响应中只返回头部，不返回实体的主体部分，这就允许客户端在没获取资源时对资源首部进行检查（3）post新建数据 (新建blog)（4）patch/put更新数据 （更新blog）patch:局部更新资源，比如只更新某一字段 put：完整更新资源，对带宽会有影响 （5） delete删除数据 （删除blog）（6）options 获取信息，关于资源的哪些属性是客户端可以修改的的。 restfulApirestfulApi 是一种新的api设计方法。 1. 概念：RESTful API 就是REST风格的API。现在终端平台多样，移动、平板、PC等许多媒介向服务端发送请求后，如果不适用RESTful API，需要为每个平台的数据请求定义相应的返回格式，以适应前端显示。但是RESTful API 要求前端以一种预定义的语法格式发送请求，那么服务端就只需要定义一个统一的响应接口，不必像之前那样解析各色各式的请求。 2. restfulapi的设计（1）传统API 把每个url当做一个功能（2）restful api 把每个url当做一个唯一的资源(^o^)/~就比如获取博客和更新博客 /api/blog/create 创建博客 /api/blog/update?blog=100 更新博客 这是一种功能// 而新的restfulapi，获取博客、更新博客、创建博客，都可以用/api/blog去表示，唯一不同的是method，这是一种资源集合（3）在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 附：URI：Uniform Resource Identifier，统一资源标识符URL：Uniform Resource Location统一资源定位符 URL是URI的子集。点击链接：URI 和 URL 3. 如何把每个url设计成一个资源？（1）不使用url参数 ，即问号后面的部分，然后做一个url的唯一标识传统： /api/list?pageIndex=2restful api: /api/list/2 （2）使用method表示操作类型传统： restful api： 下面以动物园为例子： http headers1. 常见的request headers（客户端像服务端发送的）Accept: image/avif,image/webp,image/apng,text/html浏览器可接受的数据格式 Accept-Encoding: gzip, deflate, br浏览器可接受的压缩算法 Accept-Language: zh-CN,zh;q=0.9浏览器可接受的语言 Connection: keep-alive连接方式keep-alive：一次tcp连接可以重复使用 Cookie: BIDUPSID=8B5F551B8E92D363D2BF09A17F1787F0; BAIDUID=5ccc19b28fd87ed0af236b203e83021a什么是cookie：Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 [1] 。 Host: m.baidu.com域名 Content-type: application/json text-plain客户端像服务端请求时，告诉服务端我发送数据的格式，一般只有post请求有，get是获取数据一般没有 User-Agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.193 Mobile Safari/537.36浏览器信息 Cache-Control 2. 常见的response headers（服务端像客户端返回的）连接方式 Connection: keep-alive返回数据的大小 Content-Length: 0返回的数据的格式 Content-Type: text/plain; charset=utf-8返回的数据的压缩算法 Content-Encoding服务端改cookie的时候，需要发送 Set-Cookie: __bsi=10004501327375333328_00_32_N_R_10_0303_c02f_Y; max-age=3600; domain=m.baidu.com; path=/ 3. 缓存相关的headerscache-control （响应头，缓存时间）expires (响应头中，已被cache-control代替，有这个属性和cache-control一起兼容写法的情况)last-modified（响应头，资源的最后修改时间） if-modified-since （请求头，协商缓存时浏览器再次请求会带着这个值，这个值和响应头的laast-modified相同）etag （资源的唯一标识）if-none-match (请求头，值和响应头的etag相同，协商缓存中的唯一标识) header也可以自定义,axios插件就可以自定义header除了以上之外，可以自定义header，如果在客户端自定义在request中加，如果在服务端中自定义要后端在response中加常用场景：如服务端需要前端加上一个验证header做非法请求的验证 总结一下restful api的设计模式1.协议遵守https协议2.api应该有单独域名3.加上版本号4.由于restfulapi中url表示一种资源的集合，而不再是一个功能一个url，所以网址中不能有动词，应该全是名词，且与数据库的表名一一对应，也由于是一种集合，所以api的名词尽量为复数5.用http动词去表示资源的具体操作类型，如putpatchpostgetdelete增删改查等6.如果涉及分页这种返回结果相当多的情况，api也可以提供一些参数，如?limit=10&amp;page=27.有单独的状态码8.4xx错误时要返回出错信息，用统一的error作为键值9.返回结果应符合规范 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档10.Hypermedia API 返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 http缓存(见有道云)1. 什么是缓存？网页第二次访问时，有相同资源可以不用重新请求一遍。 2. 为什么需要缓存为了让页面加载更快，网络请求加载相比cpu计算等等会比较慢，所以要尽量减少网络请求的数量和体积，可以让加载更快一些 3. 哪些资源可以被缓存 —— 静态资源（js css img）html一般是不被缓存的，网页的业务数据（比如留言板列表、博客列表）一般也不能被缓存，因为有可能随时会更新。 2. http缓存策略(见有道云)（1）强制缓存 cache-control比如请求一个js资源浏览器初次请求服务器，服务器返回资源和cache-control，若服务端感觉这个资源可以被缓存，则加入cache-control（在response-headers中，因为在响应头中，所以客户端无法控制，服务端控制）如：cache-control：max-age=5184000 单位为秒浏览器再次请求时，之前服务端的cache-control本地缓存会缓存下js的内容，如果cache-control没过期，浏览器就请求本地缓存，不通过网络，由本地缓存返回资源。 （2）协商缓存服务端去判断客户端资源是否和服务端一致，一致则返回304（服务端判断客户端资源未改动），否则返回200和最新的资源。浏览器初次请求，服务端返回资源和资源标识给浏览器。浏览器再次请求会带上资源标识，服务端判断该资源标识的资源是否和服务端最新资源一致，则返回304，否则返回新资源和新资源标识。资源标识：在response-header中（因为是服务端返回的呗）last-Modified 资源的最后修改时间Etag资源的唯一标识（一个字符串，类似人类指纹） （3）刷新方式对缓存的影响https协议(见有道云)一、 http面试题 http常见状态码 http常见header 什么是restful 描述一下http缓存机制 "},{"title":"【第8章】localStorage、sessionStorage、cookie","date":"2019-04-12T07:33:35.000Z","url":"/2019/04/12/cxy/js/js-storage/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 内容：localStorage sessionStorage cookie 一、cookie1. 什么是cookie？cookie用来server端和浏览器端通信，并不是用来做本地存储，只是因为原先html5不普及所以借用来本地存储 2. 前端修改cookie的方式：document.cookie后端也可以修改cookie。 3. cookie的缺点：（1）存储大小最大只有4k（2）每次发送http请求，cookie都会被发送到服务端，会增加请求的数据量（3）只能用document.cookie来修改，很麻烦。 二、.localStorage和sessionStorage1. 优点：（1）localStorage和sessionStorage是html5专门为存储设计，最大存储5m（2）api简单易用（3）不会随着http请求被发送。 localStorage和sessionStorage可以在控制台application查看 2. api:getItem(key)setItem(key,value) 3. localStorage和sessionStorage、cookie区别(1) localStorage会永久存储，sessionStorage只存在于当前会话，如果浏览器关闭，该网站的sessionStorage会立即清除。 (2) cookie每次都会随着浏览器请求发送到服务端，localStorage和sessionStorage只存在于本地 (3) localStorage和sessionStorage的api简单，cookie只能通过document.cookie设置。"},{"title":"【第7章】ajax","date":"2019-04-11T04:13:35.000Z","url":"/2019/04/11/cxy/js/js-ajax/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、手写一个ajax promise ajax的写法 二、跨域1. 同源协议、域名、端口必须一致，叫做同源同源策略：ajax请求时，浏览器要求当前网页和服务器端必须同源 2. img、link、script 可以无视同源策略，即可以跨域由于img可以无视同源策略，所以可以用于使用第三方统计服务，如打点link script 可使用cdn，cdn一般是外域服script可以实现jsonp 3. 如何用jsonp实现跨域？上面说了script可以实现jsonp。现在假设我需要在下访问的文件，由于端口不一致所以跨域了。（1）首先，需要服务器进行配合。因为服务器可以拼接任意字段返回给服务器，所以让服务器将数据包装为js函数返回。 假设服务器给前端的数据为，该文件的内容让后端包装为callback方法，参数为真实要传递的数据，如： （2）然后，前端使用script标签引入该index文件 这样，在页面中就引入了一个名为callback的函数，因为是script全局引入，所以该方法位于window下。（3）再使用另一个script标签，处理数据： 4. cors实现跨域CORS 是纯服务器端操作，服务器端可以设置header根据下面方法设置响应头字段服务器端可以直接设置header，去允许某个地址的跨域访问。 5. 常用的ajax插件fetch() axios "},{"title":"事件捕获与冒泡相关","date":"2019-04-10T04:13:35.000Z","url":"/2019/04/10/cxy/js/js-event/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 描述事件冒泡的流程事件冒泡基于树形dom结构，事件可以一级一级的向上冒泡，若有多个事件，先响应内层，再响应外层。若一个事件在最外层绑定的，在最内层上依旧能监听到。 事件冒泡和事件捕获事件冒泡：事件可以一级一级的向上冒泡，若有多个事件，先响应内层，再响应外层。 事件捕获：从外向内触发事件，很少用于开发。xxx.addEventListener(‘xxx’,function(){},true) 第三个参数为true时，则触发事件捕获。 事件代理像瀑布流，无限加载图片，由于元素太多不好每一个元素都绑定事件，所以就将事件绑定在这些图片的父元素上，通过事件冒泡去相应事件好处是代码简洁，减少浏览器占用，但不要滥用。 面试题编写一个通用的事件监听函数为了解决事件代理（如瀑布流需要每个图片都有一个点击事件）将瀑布流事件绑定在父元素上，当点击父元素时，可以激发子元素的事件 "},{"title":"【第4-3章】async await","date":"2019-04-06T09:01:05.000Z","url":"/2019/04/06/cxy/js/js-await/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、generator的基本用法 1. for…of循环可以自动遍历generator函数运行时生成的iterator对象，且此时不需要调用next()方法。 3. g.throw(err) 在generator函数内部排除一个错误4. g.return() 可以返回特定的值，并且终结generator函数。5. yield* gen() 若是在generator函数内部需要调用其他generator函数，需要手动遍历，或直接使用yield*表达式。6. 如果一个对象的属性是generator函数，则可以简写，generator的返回值是iterator遍历器 二、async、await· async 可以用同步的方式写异步的代码，async返回的是promise对象，如果返回了普通变量则会被包装成promise· await后面一般追加异步操作，相当于promise.then()，如promise对象、其他async函数 1. async/await和Promise的关系，为什么要使用async async/await是消灭异步回调的方法，有了async/await，就可以使用同步的写法去写异步的程序，不需要再用回调函数，写起来也比promise简便。相当于promise.then promise.catch，但二者并不冲突promise捕获错误只能用promise.catch的方法，没办法用try…catch，但async/await可以，写法上会规范许多 2. async返回一个promise，可以用.then方法，await相当于promise.then(重点！)，但用法又有所不同async函数内部return语句返回的值，会成为then方法回调函数的参数。async自动执行、async函数返回一个 Promise 对象，可以使用then方法添加回调函数。await 后面跟promise对象或一个一个async 函数，相当于promise.then()async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 3. 正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。async函数return的则是一个promise对象 4. await后面可以跟promise或async函数，如果跟的是一个普通函数，那加不加await都是一样的 ###5. async内的catch相当于promise.catch() 若await后面的promise状态为reject，则之后代码均不执行 5.异步的本质：遵循event-loopasync/await只是语法糖，从语法层面将代码变为同步的写法，但实质是异步的，依旧基于event-loop去执行await 后面的内容全部都理解为放在回调函数中，所以他们都是异步操作，所以要放在同步操作的后面去执行（event-loop原理） 6.await后面加不加promise，很很很重要不加promise相当于一个同步函数，后面的代码也是同步代码了。 ```javascriptfunction timeout(ms) { return setTimeout(()=&gt;{}, ms); } async function asyncPrint(value, ms) { await timeout(ms); console.log(value); } asyncPrint(‘hello world’, 5000); console.log(1)// 立刻打1 hello world"},{"title":"【第4章】同步和异步","date":"2019-04-06T05:20:03.000Z","url":"/2019/04/06/cxy/js/js-progre/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 单线程和异步js是单线程语言，只能同时做一件事情，两段js不能同时执行，.原因就是避免DOM渲染的冲突（都修改DOM就冲突了）浏览器和nodejs已经支持js启动进程 如 web serverjs和dom渲染共用一个县城，所以可以操作dom##异步为了解决什么问题？因为js是单线程，异步为了解决遇到等待时，等待过程中不可能像alert一样阻塞程序进行，因此所有的“等待情况”都需要异步。 异步应用场景：定时任务：setTimeout、setInterval、网络请求：Ajax请求、动态加载、事件绑定：图片加载如onload，不用等待onload完毕再去执行onload后面的代码 回调地狱callback hell回调函数： 将一个函数作为参数传递给另个函数回调地狱用promise来解决 再如请求太多的时候，回调函数套回调函数 如果用promise去写，就会简洁很多。 常见的面试题：图片加载 单线程是什么前端使用异步的场景有哪些"},{"title":"【第4-2章】promise","date":"2019-04-05T08:22:15.000Z","url":"/2019/04/05/cxy/js/js-promise/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、promise的三种状态fuifilling reject pending，在没有获取到reject或者fulfilling时一直都是pending，直到有reject或resolve返回promise变为fufilling或reject之后，状态不可逆。pending状态，不会触发then和catch，resolved会触发then，reject会触发catch 二、then(res,rej)方法then(res,rej)方法的两个参数，第一个是resolve方法，第二个是reject方法，reject方法可以在后面用catch的方法调用then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 直接获取resolve状态或reject状态的方法： 三、then和catch的状态改变 then正常返回resolve，内部有报错（或throw err）则返回rejected。 catch正常返回resolved，内部有报错则返回rejected。 resolve触发then回调，rejected后续触发catch回调，注意resolve是不会触发catch回调的。 promise.resolve()和promise.reject()只要内部没报错，后续还是触发then回调。 最后的状态靠最后返回的结果为定 第五点我要单独说一下：最后的状态靠最后返回的结果为定在下面的代码中，promiseA本身是反悔了resolve，但由于它引入了另一个promiseB，而promiseB返回reject，所以最终执行结果会到catch方法中。 四. resolve和fufilledpromiseA如果resolved到了另一个promiseB中，那它不一定是pendding fulfilled reject,它的状态由promiseB执行完毕才决定。上面有代码示例。 (1) nothing happened yet(2) “locked in”to another promise(3) fulfilled(4) rejeted(1)(2) pedding (3)(4)settled (2)(3)(4)resolved (1)unresolved ##五. Promise.resolve() 和 Promise.reject() 如果Promise.resolve()有参数:（1）. 参数为promise，原封不动的返回该promise （2）参数为有then方法的对象，会立即执行then方法，并将执行结果封装为promise对象 （3）参数没有then方法，或根本就不是对象，则将值包装为promise对象并返回到then中，状态为resolved 六、promise定义时立即执行，而then相当于异步，所以执行完promise内的内容跳出去执行同步代码，再执行then 面试题：以下代码的执行结果？ "},{"title":"【第3-2章】作用域和闭包","date":"2019-04-05T04:00:00.000Z","url":"/2019/04/05/cxy/js/js-context/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、作用域和自由变量作用域:作用域就是一个变量的合法使用范围。作用域分为全局作用域、函数作用域及块级作用域（es6新增）。 函数作用域 块级作用域（es6新增） 自由变量：一个变量在当前作用域没有定义，（注意是当前作用域，哪怕上级作用域定义了只要当前作用域没定义就不行）但被使用了，沿上级作用域一级一级找，若到全局作用域还没有找到，就报错。 二、闭包·闭包就是作用域应用的一个特殊情况，闭包让开发者可以从内部函数访问外部函数的作用域，有两种情况：（1）函数作为参数被传递（2）函数作为返回值·自由变量的查找是在函数定义的地方！（重点，函数定义的地方是指函数体在哪里），向上级作用域查找注意：闭包中的变量会常驻在内存，得不到释放，因为判断不了闭包内的变量未来是否会用到闭包是由函数以及声明该函数的词法环境组合而成的。 （1）函数作为参数被传递 （2）函数作为返回值 （3）自执行函数 function 里可没传参数，看好了是data后面有参数，其实就算传了也没什么影响，因为i的值已经在调用时决定是3了，虽然函数定义时决定了变量所在的作用域，但调用时才能决定变量在该作用域实际的值。 重要！！！变量在定义时就确定了上级作用域，但需要在调用时才能确定变量定义时所在的上级作用域或当前作用域该变量的值，比如这里i在调用时的值为3，即使外部定义了i = 10，最终查找还是在定义时的当前作用域查找i，当前作用域的i为3，所以输出全为3 改进方法：形成自己的封闭的块级作用域。改进方法1：for内的var变为let，因为let具有块级作用域，它形成了三个私有作用域相互不会干扰。 改进方法2：自执行函数和闭包匿名函数定义也是在匿名函数声明的地方，这里即return后，有名字的函数定义就在有名字的函数那里，然后一层一层向上查找 自由变量的查找是在函数定义的地方，向上级作用域查找 ，而不是在执行的地方。 三、this详见3-1this取值是在函数执行的时候决定的，而不是函数定义的时候决定的。 箭头函数的this取值是取他的上级作用域的值（静态作用域），普通function的this取值是在函数执行时确认的。 分为以下几种情况：（1）作为对象方法被执行，this指向该对象。（2）class的this表示它当前的实例，在构造函数（函数用new调用）中，this指向要被constructed的新对象。（3）普通函数的this，在调用时才知道this的作用域。（4）箭头函数的this固定指向上级作用域（5）call apply函数内的this和函数在什么环境中定义没有关系，而只和自己的主体有关。 ####call、apply、bind的区别和使用：作用是在一个对象中调用另一个对象的方法和属性。 call、apply、bind的第一个参数均为需要调用属性或方法的对象，区别是apply的第二个参数为数组，而bind、apply参数不放入数组而是直接列出。 bing会返回一个函数，执行函数后才改变this，而call、apply会立即执行。 bind的执行： call的执行： apply的执行： 面试题：手写bind、call、apply闭包的实际使用场景"},{"title":"【第3-1章】this","date":"2019-04-05T04:00:00.000Z","url":"/2019/04/05/cxy/js/js-this/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、作用域与thisES5只有全局作用域和函数作用域，没有块级作用域作用域分为静态/词法作用域和动态作用域 0. 声明提升和暂时性死区(1).声明提升(var) (2).暂时性死区(let) 注意：在es5 strict mode，赋值给未声明的变量将报错。 1.静态作用域静态作用域指的是一段代码，在它执行之前就已经确定了它的作用域，简单来说就是在执行之前就确定了它可以应用哪些地方的作用域(变量)首先let和const声明的全局变量不再属于window变量的作用域，除了this以外，全部遵循词法作用域的原则。即JS引擎总会从最近的一个域，向外层域查找； 二、动态作用域动态作用域–函数的作用域是在函数调用的时候才决定的。在 JavaScript 中的仅存的应用动态作用域的地方：this 引用。动态作用域，作用域是基于调用栈的，而不是代码中的作用域嵌套；作用域嵌套：有词法作用域一样的特性，查找变量时，总是寻找最近的作用域； 三、声明函数的方法（1）.函数声明function a (a,b,c) { return a+b+c;}（2）.函数表达式var a = function (a,b,c) { return a+b+c;}（3）.Function构造函数语法： new Function(参数1, 参数2, 参数3, 方法体)var a = new Function(‘a’,’b’,’c’,’return a+b+c’) 四、变量进入作用域的方法1.Language-defined：所有的作用域默认都会给出 this 和 arguments 两个变量名（global没有arguments2.Formal parameters（函数形参）：函数有形参，形参会添加到函数的作用域中;3.Function declarations（函数声明）：如 function foo() {}4.Variable declarations（变量声明）：如 var foo，包括_函数表达式_ 除了上下文顺序声明之外，若声明提升符合。函数声明和变量声明总是会被移动到它们所在的作用域的顶部。而变量的解析顺序（优先级），与变量进入作用域的4种方式的顺序一致。 关于上下文： 五、this每个作用域都会有this。在全局上下文（任何函数以外），this指向全局对象。 this在具体位置的具体指向： 在函数内部时，this由函数怎么调用来确定。简单调用，即独立函数调用。由于this没有通过call来指定，且this必须指向对象，那么默认就指向全局对象。 严格模式下，this保持进入execution context时被设置的值。如果没有设置，那么默认是undefined。它可以被设置为任意值（包括null/undefined/1等等基础值，不会被转换成对象）。 在箭头函数中，this由词法/静态作用域设置（set lexically）。它被设置为包含它的execution context的this，并且不再被调用方式影响（call/apply/bind）。 当函数作为对象方法调用时，this指向该对象。 原型链上的方法根对象方法一样，作为对象方法调用时this指向该对象。 在构造函数（函数用new调用）中，this指向要被constructed的新对象。 Function.prototype上的call和apply可以指定函数运行时的this。 ES5引进了Function.prototype.bind。f.bind(someObject)会创建新的函数（函数体和作用域与原函数一致），但this被永久绑定到someObject，不论你怎么调用。它说创建新函数，可不是覆盖原函数，！！！！ 闭包中的this（挺绕的，但无论下次看到理不理解，都要记住闭包套的闭包有可能返回window，需要分析有没有自执行函数）为什么下面这段代码的结果是”The Window”？ object.getNameFunc是对象调用的方法，里面的this是指向object，但object里面return的闭包，有自己的this和arguments。在《Javascript高级程序设计》中有写 为什么匿名函数没有取得其包含作用域（外部作用域）的this对象呢？每个函数被调用时，其活动对象都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。 在作用域和闭包说过，闭包的情况有函数作为返回值及函数作为参数被传递。同样的，还有像操作dom函数的闭包。 再深层一些，比如clickEvent这个函数返回的也是闭包，那么无论多少层，只要执行了，都是window。 注意：当用call和apply而传进去作为this的不是对象时，将会调用内置的ToObject操作转换成对象。所以4将会装换成new Number(4)，而null/undefined由于无法转换成对象，全局对象将作为this。 六、JavaScript采用Lexical Scope。（静态范围作用域）于是，我们仅仅通过查看代码（因为JavaScript采用静态范围作用域），就可以确定各个变量到底指代哪个值。另外，变量的查找是从里往外的，直到最顶层（全局作用域），并且一旦找到，即停止向上查找。所以内层的变量可以覆盖外层的同名变量。 七、Function vs. Block Scope上面的内容有意无意似乎应该表明了，JS没有Block Scope。除了Global Scope，只有function可以创建新作用域（Function Scope）。 不过这已经是老黄历了，ES6引入了Block Scope。另外，with和try catch都可以创建Block Scope。"},{"title":"【第2章】原型和原型链","date":"2019-04-04T06:13:15.000Z","url":"/2019/04/04/cxy/js/js-prototype/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、原型的简单描述在一个类中：实例的隐式原型，指向类的显式原型类的方法定义于prototype中。son.__proto__ = Son.prototype 在继承关系中：子类的显式原型的隐式原型指向父类的显式原型，查找时就顺着这个链去查找，类的最顶端为object子类也有隐式原型，指向的是父类。Son.prototype.__proto__ = Parent.prototypeSon.__proto__ = Parent call、apply、bind的区别和使用：作用是在一个对象中调用另一个对象的方法和属性。 call、apply、bind的第一个参数均为需要调用属性或方法的对象，区别是apply的第二个参数为数组，而bind、apply参数不放入数组而是直接列出。 bing会返回一个函数，执行函数后才改变this，而call、apply会立即执行。 bind的执行： call的执行： apply的执行： class说白了还是语法糖，如果不用class，用原型链当然也可以定义继承关系。比如我现在有一个类A，有一个子类B 补充：in和hasOwnproperty的区别两个方法都是判断对象中是否存在某个key，但hasOwnproperty不判断原型链上的属性和方法。所以，依据上面的例子：‘aa’ in b // truejavascriptb.hasOwnProperty(‘aa’) // false"},{"title":"【第5章】dom、bom","date":"2019-04-03T05:03:15.000Z","url":"/2019/04/03/cxy/js/js-explore/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、dom前言：dom的本质html是一种特定的xml，html规定了语法，而xml可以自己规定标签dom的本质是一个树形的数据结构 1. document对象（1）document对象集合 all[]所有元素的集合anchors[]对所有href链接的引用，非常简单地返回文档中具有name属性值的所有锚点的集合。已被web标准删除。applets对所有applets（小应用程序）对象的引用forms[]对所有forms的引用images[]对所有img的引用links[]对所有area的href的引用，href （2）document对象属性 （3）document对象方法 2. document.element（1）节点操作 （2）节点属性操作 （3）节点属性 3.attribute 在属性节点上的可用的属性或方法 4.event（1）基本写法 （2）事件类型 二、bom（1）window下 history location以举例 Navigator：Navigator下的属性基本是浏览器的各种信息，如userAgent返回由客户机发送服务器的 user-agent 头部的值。 其他常用的： 面试题：如何提高dom性能？(1) 避免频繁的dom操作(2) 对dom查询做缓存(3) 将dom频繁操作改为一次性操作"},{"title":"【第1章】变量类型和计算","date":"2019-04-03T05:03:15.000Z","url":"/2019/04/03/cxy/js/js-let/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、值类型和引用类型1.js的类型一共六种数字（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（Object）。 其中对象类型包括：数组（Array）、函数（Function） 还有两个特殊的对象：正则（RegExp）和日期（Date） 值类型: number、string、boolean、undefined 引用类型: null、object(array function regexp date) 新类型：BigInt 是一种内置对象，它提供了一种方法来表示大于 253 - 1 的整数。 BigInt和Number的区别：不能用于 Math 对象中的方法；不能和任何 Number 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 BigInt 变量在转换成 Number 变量时可能会丢失精度。 2. 深入分析值类型和引用类型在内存中的存储方式值类型和引用类型有什么区别值类型在栈中存储，引用类型在堆中存储，值类型赋值多少就是多少，引用类型会被指针影响。 3. typeof能判断那些类型？typeof返回结果为字符串 4. 何时使用===何时使用==？除了 == null之外，全部用 === 先说 “===”，这个比较简单。下面的规则用来判断两个值是否===相等： 1、如果类型不同，就不相等 2、如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断） 3、如果两个都是字符串，每个位置的字符都一样，那么相等；否则不相等 。 4、如果两个值都是true，或者都是false，那么相等。 5、如果两个值都引用同一个对象或函数，那么相等；否则不相等。 6、如果两个值都是null，或者都是undefined，那么相等。 再说 “==” 如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： a、如果一个是null、一个是undefined，那么相等。 b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。像-1既不等于false也不等于true，2既不等于false也不等于true2 &gt; true, -1 &lt; false 都是成立的 d、如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。 js核心内置类，会尝试valueOf先于toString; e、任何其他组合，都不相等。 5. 手写深拷贝:递归,什么是深拷贝:浅拷贝如果遇到的是一个引用类型，那么拷贝的实际上是变量的地址，更改的时候会更改拷贝的原变量，深拷贝则会生成一个新地址方法1： 方法2： 改良 手写isEquals()函数 6. truly变量和falsely变量两步非运算为true，则为truly变量，两步非运算为false，则为falsely变量，即 以下为falsely变量，其他都为truly变量 if判断时的truly变量和falsely变量，若为falsely变量直接无法走入if循环 强制类型转换和隐式类型转换(1) 强制类型转换parseInt()和parseFloat() (2) 隐式类型转换 if 逻辑运算 == +、*拼接字符串//字符串和数字相加会转为字符串，字符串和数字相乘/除/减会转为数字 补：hasOwnProperty:对象方法，返回一个boolean，判断是否拥有此对象，且不是继承来的对象，也就是沿着原型链上查找到的。 map weakmap set weakset 区别:1.weakset值只能是对象2.weakset是弱引用，即如果其他对象都不引用该对象，那么垃圾回收机制会立即回收。weakmap键只能是对象，值可以任意。WeakMap的键名所指向的对象，不计入垃圾回收机制。WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。set方法：has() add() delete() clear() entries() keys() values() sizemap方法：add() delete() set(key,value) get()（增删改查） entries() keys() values() size settimeout(fun,ms,arg1,arg2…argN) 第三个-最后一个参数会作为传递参数传给fun"}]