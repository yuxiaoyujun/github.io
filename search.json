[{"title":"【SNK】レオナ・ハイデルン 莉欧娜","date":"2024-06-01T10:35:46.000Z","url":"/2024/06/01/dm-kw/","tags":[["拳皇","/tags/%E6%8B%B3%E7%9A%87/"],["遊戲","/tags/%E9%81%8A%E6%88%B2/"],["動漫","/tags/%E5%8B%95%E6%BC%AB/"]],"categories":[["動漫","/categories/%E5%8B%95%E6%BC%AB/"]],"content":"蕾欧娜（レオナ），也被称为Leona Heidern（レオナ・ハイデルン），是《拳皇 ‘96》中首次亮相的角色，是碇武士队的新成员。她的正式昵称是“沉默的战士”（サイレントソルジャー）。 除《拳皇》系列本体外，蕾欧娜还在外传漫画《拳皇：京》的单行本中登场，并拥有自己的角色形象相册。 人物概要婴儿时期，蕾欧娜在一场悲剧事件中失去了父母。她成为海德恩的养女，海德恩将她纳入碇武士团，与财富战士拉尔夫和克拉克一起服役，随后监督了她严格的军事教育（在Whip加入他的小队之前）。 莱昂娜扎着浅蓝色的马尾辫，眼睛是蓝色的。她穿着一件军绿色的军装夹克，剪得很短，露出了腹部。她还穿着用腰带系住的短裤、护膝、袜子和军靴来搭配她的服装。 当她的 Orochi 血液失控时，Leona 的头发会变成红色，她的眼睛没有瞳孔或虹膜，并且她的皮肤因缺血而变得苍白。 这位沉默寡言、性格孤僻的年轻女子很难与人进行日常社交，但她是一名优秀的士兵，下属中拥有一批忠实的追随者。在战斗中，她以许多人称之为“卓越”的高效方式完成任务，主要用她养父留下的匕首消灭敌人。她还认识 SPARROWS 特工Fio Germi，与她和 Clark 一起执行了一项任务，因此这三人建立了紧密的友谊。 她每年的少量休息时间大部分都花在了“工厂参观”这一不同寻常的活动上，据说，这是她恢复精力和精力的一种不同寻常的方式。在她为完成任务而参加的格斗比赛中，人们经常看到她表现出一种难以想象的可怕，而这种可怕性的来源和细节仍然令人难以捉摸…… 技能在*《合金彈頭 XX》*中，利昂娜是一個高於平均水準的角色，大概是因為她的可下載角色狀態。 她的具體能力包括以下： 她可以在站在地面上的任何時候（按住左肩+火力+向上）進行特殊的近戰攻擊，稱為斬月者（Moon Slasher），造成大約是手榴彈兩倍的傷害（但不需要任何彈藥或遭受任何酷炫）下降）。該技術還可以消除附近敵人的攻擊，但在執行該技術時不會增加分數。 提高了在蛞蝓內的傷害抗性 （在被摧毀之前可以承受四次攻擊，而不是通常的三次）。 從武器掉落中獲得 +20% 彈藥。 獲得 +20% 手榴彈（從一開始就是 10 個，而不是 12 個）。 當她失去生命時，她會保留她攜帶的武器。 发展在她首部作品开始制作之前，开发人员希望为 Heidern 创造一个合适的替代品，作为游戏大修的一部分。开发人员承认，他们想在 KOF ‘96 制作之前引入 Heidern 养女的故事元素。[3] 蕾欧娜在她首次亮相时就被认为是Orochi的后裔，她的设计师特别注意让她的行为反映出他们当时的兴趣。[3]她最近的设计是由Eisuke Ogura完成的，Nobuyuki Kuroki评论说，蕾欧娜的胸部最终比她之前的化身更结实。[4] 性格蕾欧娜性格内向，除了战斗或任务之外，她很难表达自己。由于过去的经历，她经常抑制自己的情绪，因为她害怕失去控制，并因为自己流淌的 Orochi 血统而伤害到朋友。 除了拉尔夫、惠普、克拉克和指挥官海德恩，蕾欧娜不和任何人说话。她经常感到孤独，但她在碇佣兵团找到了新家庭，这让她感到安慰。自从自杀未遂后，蕾欧娜决心控制自己的大蛇血统，只在情况需要时使用它，这是她在战前对话中告诉对手的。随着她对自己力量的理解和控制越来越强，即使作为八卦宗的一员，她也对自己的同类更加警惕，并结下个人恩怨，以阻止八卦宗的任何计划，就像三圣物所做的那样。 权力 切割 / 穿刺手- 莉奥娜可以用手切割或穿刺。 切割光环- 蕾欧娜可以在她的手和脚周围创造出切割光环。 切割球- 莱昂娜可以创造出一个由多个能量刀片包围的能量球。 血腥暴动 - 由于拥有 Orochi 血统，每当 Orochi 的存在感很强时，Leona 就会进入这种状态。 Orochi 力量- 只要 Orochi 的力量仍然很弱，Leona 就可以在一定程度上控制这种状态。使用这种力量时，她的头发会暂时变红或呈现一丝红色，就像她完全成熟的 Orochi 形态一样。 爆炸技术- 莱昂娜可以通过她的手套和耳环制造爆炸。 广告 格斗风格她与她的养父 Heidern 有许多共同的动作，而且她似乎也在模仿 Ralf 的动作。例如，她的 CD/Blowback 攻击几乎与 Ralf 相似。此外，随着游戏的进展，她的动作似乎变得更具爆发力，就像 Ralf 一样，她的跑步风格也从像 Heidern 的变成了像 Ralf 的，但同时仍然保持着 Heidern 教给她的更敏捷的技巧；然而，与 Heidern 不同的是，她的技巧有更多明显的差异，通过额外的变化，更注重速度和杂技。 作为盖德尔的女儿，她会使用一些类似爪子的砍击动作，后来这些动作被她养父的战斗风格所改进。然而，她不像她父亲那样拥有掌控水的力量，这可能是因为她之前的创伤一度阻碍了她的能力。 音乐 轰鸣的城市- 拳皇 96、98、R-1、R-2、SNK vs. Capcom：千禧之战 第三次世界大战- 拳皇 99 士兵- 拳皇 2000、EX、EX2 我的鞭子- 拳皇 2001 丛林保镖- 拳皇 2002 拳皇 2003内幕 不定期任务- 拳皇 XIII 火药味- 拳皇 XIII（当音乐设置为“Type B”时，仅限主机版，与Ralf Jones和Clark Still共享） 天空下的幸存者- 拳皇 XIV 大勇气-拳皇 XV 沙漠安魂曲 〜Operation ‘02UM〜 - 拳皇 2002 无限比赛 雷- 回忆的日子 (我与彼女与言情) 轰隆隆的城市〜SNK 女主角编辑〜 - SNK 女主角：双打狂潮 轰隆隆的城市 -KOF XV ver.- - 拳皇 XV（饰演 Heidern 的对手） 鏈接： snk-corp SNK網站關於蕾欧娜的介紹 圖圖是我用stable diffusion生成的，查實我主要都係為咗放圖。。覺得佢真係幾咁索幾咁靚。 ![00008-3462448666 (1)](/images/00008-3462448666 (1).png)"},{"title":"【2024-05-10】還是鍾意玩任天堂的遊戲","date":"2024-05-10T04:01:01.000Z","url":"/2024/05/10/about-game-view-point/","tags":[["任天堂","/tags/%E4%BB%BB%E5%A4%A9%E5%A0%82/"]],"categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"任天堂以其獨特的遊戲玩法而聞名，這種獨特性不僅體現在口碑上，更體現了他們的創新能力。 這種創新使得他們的遊戲備受好評，但卻鮮有人能夠模仿。 任天堂這麼多年都未倒下就係因為這樣。 遊戲必須首先要好玩，傳統的遊戲玩法自然有其魅力。 像泡泡龍，連連看，俄羅斯方塊幾十年來沒怎麼改變玩法，依然有人玩。 像moba遊戲，從星際爭霸（sing1 zai3 zang1 baa3）到魔兽战争（mo1 sau3 zin3 zang1）到而家王者榮耀（wong4 ze2 wing4 jiu6）平安京等等。。玩法未點變，同樣打的開心爽快（song2 faai3）。 所以好多人觉得只有画面進化科技技術（gei6 seot6）進化就够了。 原来是像素人，现在則（zak）變成超越（jyut）CG级别的逼真度。但实质上游戏性并没有增加多少，所以這種遊戲隨（ceoi4）著技術（seot）發展，非常之容易被其他公司模仿同取代。 所以，雖然技術的進步可以改進遊戲的玩法，但玩法的創新不一定依賴於技術。 任天堂的許多遊戲都以最簡單的2D畫面為特色，但其中的創新卻讓其他廠商無法模仿。 比如去年2D畫面的馬里奧驚奇，你有諗過食人花居然開始唱歌咩？ （同埋好多人而家都仲未注意到：你玩嗰陣有注意過自己個對joy con居然唱緊歌咩？） 再比如，不得不說的節奏天國系列（lit），推出咗咁多年，都未有公司可以模仿到。 遊戲的本質（zat）是好玩。上手快，同埋玩了覺得好好玩，你仲会計較個畫面好不好睇咩？ 製作3A大作的遊戲公司投入大量資源，自然出產大製作，但小製作同樣也有其市場空間。 只要有優秀（jau sau）的創新，小製作也能取得巨大成功。 比如： 之前看到有人話任天堂掌機配置低，價格（gaa gaak）高，不理解點解有人買遊戲，有錢不如買steam 3A大作什麼的。 。 。 。 。 。 其實3A大作不是不好，但一個遊戲好唔好嘅關鍵，我覺得唔應該淨係睇技術同畫面點。 3A製作一樣有垃圾（laap saapd）。 特別係嗰啲宣傳淨係宣傳用咗咩高科技製作，核心內容一點不提的遊戲。 就好似中國動畫某個好長好長嘅時期，淨係追求技術同畫面，內容好似垃圾咁。。 \"制作者们将更多精力投入在视觉层面，以掩盖内容上的短板。\" 係阿，我係講緊你阿，歡迎對號入座 任天堂多年未倒閉，依賴的就是創新啩。。。 "},{"title":"【stable_diffusion】使用通俗的語言解釋diffusion模型","date":"2024-05-09T08:36:24.000Z","url":"/2024/05/09/e_sd/","tags":[["ai繪畫","/tags/ai%E7%B9%AA%E7%95%AB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"],["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"呢個視頻係我理解嘅源泉，如果我說嘅話有咩唔啱嘅，都以下面個視頻為主，唔好聽我的： Base Model生成图片的基础模型，如Stable Diffusion v1.5和v2.0和Pony。 Checkpoint在深度学习中，Checkpoint可以理解为经过fine-tuning后的模型，是在基础模型的基础上微调得到的。这个过程能够生成更高质量的图片。通常，开发者会选择一个基础模型，然后在这个模型的基础上进行fine-tuning，调整模型的参数，使之适应新的任务或数据集。 在Stable Diffusion中，开发者会选择一个基础模型，然后通过fine-tuning调整模型的参数，以生成更高质量的图片。得到的这个经过fine-tuning的模型就称为Checkpoint。 为了获得Checkpoint，需要提供大量高质量的图片数据集进行训练。在训练过程中，模型会不断调整参数，尽可能地适应数据集，这就是fine-tuning的过程。 简而言之，Checkpoint是经过fine-tuning后基础模型的升级版，能够生成更高质量的图片。 類型 分为CHECKPOINT TRAINED以及CHECKPOINT MERGE，分别是别人训练好的和融合好的，它是大型模型，里面集合了模型参数、权重等，因此出图的的风格、画风已经相对固定。 好处就是可以直接拿来用，缺点就是想要再去微调十分麻烦，于是有了后面的lora、embedding等模型。这些属于附加模型，应用在checkpoint模型上，可以轻易对其进行微调，而且容易训练，十分方便。 Optional Model如Lora和Texture Inversion,等模型可以被看作是在基础模型同埋Checkpoint基础上，生成的图片增加了一些额外的效果，以增强或改变图片的风格。 这些可选模型也需要进行训练才能得到。它们的作用是在不修改Stable Diffusion（SD）模型的基础上，定制SD模型的生成风格或添加新的人物/知识产权（IP）。 比如，如果我们想要生成一系列具有某种特定风格的图片，例如水彩画风格、卡通风格或者古典油画风格，我们可以训练一个特定的模型，比如Lora模型，来实现这个目标。这个模型就会在SD模型生成的图片上添加相应的效果，使得生成的图片符合我们想要的风格。 同样地，如果我们想要在生成的图片中加入某个特定的人物或知识产权（比如漫画中的角色、电影中的场景等），我们可以训练一个特定的模型来实现这个目标。这个模型会根据给定的人物或IP的特征，在SD模型生成的图片中添加对应的内容。 总之，这些可选模型通过训练来定制Stable Diffusion模型的生成效果，而不需要修改SD模型本身。 Inpainting Model（VAE）修补模型（Inpainting Model）是用于修复图片中的某些部分的模型，例如修复人脸图片中的眼睛，或者可以理解为一种滤镜。这些修补模型依赖于训练。 Stable Diffusion框架可以被看作是一个“容器”，其中基础模型是这个容器的基石。其他模型和修补模型相当于可以自由拼接的“模块”，它们实现了不同的图片生成效果。但无论如何拼接，都需要基础模型作为生成图片的基础。 比如说，我们可以在基础模型上添加一个修补模型，用来修复图片中的缺失部分。这个修补模型可以是一个基于变分自动编码器（VAE）的模型，它会尝试预测缺失部分的像素，并用合适的内容填充。这样，我们就可以得到一张完整的图片，即使它的某些部分原本是缺失的。 LoRA什麼是LoRALoRA，即低秩适应模型，它的核心思想是在不大改变原有模型结构的情况下，通过添加一些简化的额外矩阵来调整模型的权重，从而提升模型的性能或适应性。 簡單解釋假设你有一辆车，可以满足你日常的通勤需求。但有一天，你要参加越野赛车比赛，你知道原车无法胜任这个任务，但你又不想换车。这时，你可以对车进行一些改装，比如换上越野轮胎、增强悬挂系统，这样车就能适应越野赛的环境。 在这个例子中，你的原车就像是一个已经训练好的神经网络模型，大多数情况下能很好地工作。但面对新的或特殊的任务（比如越野赛），它可能需要一些调整才能适应。LoRA模型的作用就像是对车进行的这些特定改装。通过在原模型上添加简化的额外部分，我们可以使模型更好地适应新的任务，而不需要重新设计或训练一个新模型。 这样做的好处是，与全面重新训练一个模型相比，LoRA模型的参数训练量少很多，也对硬件性能要求低很多，就像对车进行小改装就能应对新场景一样。 Embeddings什麼是EmbeddingsEmbeddings，中文翻译就是“嵌入”，在深度学习里面通常是指一种高维空间中的点，它能够代表输入数据的关键特征，比如文本或者图像。 簡單解釋Embeddings就像一个图鉴，帮助电脑理解各种事物。比如，我们想让电脑认识熊猫，我们会用词语“黑白相间的毛发”、“圆圆的脸”、“大大的黑眼圈”等来描述。这些描述就是熊猫的嵌入，把它们转换成了一组数字，这组数字包含了熊猫的关键特征。即使电脑以前没有见过熊猫，通过这些数字，它也能理解熊猫是什么样子。 Embeddings只是一种转换方法，它不能直接参与到绘画或者其他操作里面。所以，它不能改变模型的权重参数，只能用来固定元素或者画面特征。这也是它的局限性。 Hypernetwork什麼是Hypernetwork在传统的神经网络中，权重是通过随机初始化或者经过训练学习得到的。但是，如果我们想要设计一个具有特定结构或者功能的神经网络，可能需要手动调整权重，这是一项繁琐的任务。 Hypernetwork的想法是让另一个神经网络来生成这些权重。这个生成权重的神经网络就是Hypernetwork。而那个需要权重的神经网络就是目标网络。 簡單解釋假设我们要画一张图，但我们想要用一种特别的方式画。传统上，我们可能会手动选取颜色和笔刷来完成这个任务，但这可能会很耗时。 现在，我们有一个“画图机器”，它会根据我们给它的指示自动画图。但是，我们并不直接告诉机器每个像素应该是什么颜色，而是通过另外一个小机器来帮我们做这个任务。 这个小机器就是我们的“画图小助手”，我们给它输入一些简单的指示，比如“画一张太阳”，然后它会自动确定每个像素点的颜色和位置。 在这个例子中，画图机器就是我们的目标网络，而画图小助手就是Hypernetwork。Hypernetwork接受我们的指示（输入），然后生成出画图机器所需的具体指令（权重），从而帮助我们完成画图任务。这样，我们只需改变指示，就可以画出不同风格的图，而不必手动调整每一个像素。 （其實而家幾乎都冇人用這個生成LoRa取代咗） 用法簡單說一下用法先。 civitai去找一個鍾意的模型，跟住進入頁面會看到好多的描述 這裏可以找模型類型，下載想要的Base Modal，如果係都要再簡單點說的話，CheckPoint（train or merged）可以理解成同Base Modal是一個東西。 噉就知道需要下載啲咩模型，同埋擺係啲咩文件夾入便喇。 好多文章都介紹咗點將不同的模型放在不同的文件夾中，我之後有時間都會寫完這些內容。 其實如果同我一樣都係部署（bou6 cyu5）係雲端嘅話，可以看到目錄（muk luk6）比如： Base Model 目錄： 阿裏雲都幾完整嘅，除（ceoi4）咗VAE目錄冇寫，其他常用都寫埋tim。 同本地係一樣嘅，所有model都放係/mnt/auto/sd/models下，VAE都不例外 "},{"title":"【stable_diffusion】使用阿里雲遠程創建stable diffusion模型","date":"2024-05-06T07:36:24.000Z","url":"/2024/05/06/stable-diffusion/","tags":[["ai繪畫","/tags/ai%E7%B9%AA%E7%95%AB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"],["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"在同時學習粵拼所以打字會用粵語拼音輸入（jap6）法（faat3），有些文字唔識打，又或（waak6）者（ze2）唔係好明咩意思嘅詞語，之後會改（tabunn。。）。 stable diffusion 是什麼Stable Diffusion 3 是最先進的圖像模型，搭載了最新的文本圖像轉換技術，大幅提升了多主題提示、圖像質量和拼寫輸入的能力。 stable diffusion的原理就係利用緊一個大model同一個小model（微調model）共同生成一個圖片 使用阿里雲部署stable diffusion嘅步驟1. 開通函數計算FC打開阿里雲 - 函數計算FC - 立即開通 - 立即購買 購買完成後，進入控制台 2. 創建角色進入控制台後，點擊左側應用，提示沒有AliyunFcDefaultRole角色，點擊創建，同意授權。 3. 創建應用為了方便新手使用雲計算平台，所以阿里雲有創建模版應用的選項，此處使用模版應用，當然都可以通過github等將代碼部署過來的方式使用。 按照以下方式創建stable diffusion應用。 點擊“立即創建”，跳轉到項目配置，配置角色名為剛才創建的角色，完成後，點擊“創建應用”。 勾選同意，同意並繼續部署，等待部署成功。 部署成功後，可以查看部署日志。 3. 查看日誌在應用詳情中，可以查看日誌 在這個地方點擊查看日志，下方可以查看配置，即阿里雲為了應用分配的規格參數。 注：阿里雲嘅函數計算係按量計費，詳見函数计算 3. 開通NAS文件系統此時應用已部署，但沒有存儲模型的硬盤，NAS文件系統就相當於存儲模型的硬盤。 在應用頁面點擊“初始化模型管理” 掛載硬盤NAS，若是新用戶可以領取免費試用。 點擊立即開通 成功後，訪問web UI域名。 4. 正式使用在該頁面，可正常使用stable diffusion t步驟（bou6 zaau6） 部署（bou6 cyu5） 函數計算（haam4 sou3 gai3 syun3） 立即開通（laap6 zik1 hoi1 tung1 ） 計費（gai3 fai3） 購買（gau3 maai）"},{"title":"【bash】使用du命令、find命令等清理电脑","date":"2024-03-11T05:18:18.000Z","url":"/2024/03/11/bash-du/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"du 命令du 命令（Disk Usage）是用于查看文件或目录磁盘使用情况的命令，它能够列出指定文件或目录的大小。 基本语法如下： 常用选项包括： -h, --human-readable：以易读的方式显示文件大小，以 KB、MB、GB 等单位。 -s, --summarize：仅显示总大小，不列出每个子目录的大小。 -c, --total：在所有显示行的末尾输出总和。 -k：以 KB 为单位显示文件大小。 -m：以 MB 为单位显示文件大小。 -g：以 GB 为单位显示文件大小。 一些常用的用法示例： 查看当前目录大小： 这将显示当前目录及其所有子目录的大小，并以易读的方式显示。 查看指定文件或目录大小： 这将显示指定文件或目录的大小。 查看指定目录大小并列出每个子目录的大小： 这将列出指定目录下每个子目录的大小，以及总体的大小。 查看当前目录下最大的文件或目录： 这将列出当前目录下最大的 10 个文件或目录，并按照大小降序排列。 查看当前目录下总大小： 这将显示当前目录的总大小，而不列出每个子目录的大小。 查看当前目录及其所有子目录的总大小： 这将显示当前目录及其所有子目录的总大小，但不列出每个子目录的大小。 du -a 和 du -d不能並存。因為du -d只能級聯查找文件夾，而du -a可以查找文件卻無法指定深度。 sort命令sort 命令是用于对文本文件内容进行排序的命令。它可以按照字母顺序、数字大小等方式对文本进行排序，并且支持多种选项以满足不同的需求。 當你對文件內容使用 sort 命令時，sort 會逐行讀取文件的內容，然後將這些行按照你指定的方式進行排序。 基本语法如下： 常用选项包括： -r, --reverse：逆序排序，即降序排序。 -n, --numeric-sort：按照数值大小排序。 -f, --ignore-case：忽略大小写。 -u, --unique：去重，去除重复的行。 -k, --key=POS1[,POS2]：指定以哪个字段进行排序，默认情况下是以整行作为一个字段。 -t, --field-separator=SEP：指定字段分隔符，默认是空格。 -h, --human-numeric-sort：以易读的方式对数字进行排序，例如将 “2K” 排在 “10M” 之前。 一些常用的用法示例： 按照字母顺序排序： 这将按照字母顺序对 file.txt 中的内容进行排序。 例如，考慮以下數字列表： 如果按照字母順序排序，它們將按照字符串的第一個字符來排序，即按照1、2、5、1。這將導致以下順序： 但如果按照數值大小排序，則會按照數字的大小來排序。這將導致以下順序： 在 sort 命令中，使用 -n 選項可以實現按照數值大小排序。 按照数字大小排序： 这将按照数字大小对 file.txt 中的内容进行排序。 逆序排序： 这将按照字母顺序对 file.txt 中的内容进行逆序排序。 忽略大小写排序： 这将按照字母顺序对 file.txt 中的内容进行排序，忽略大小写。 去重： 这将对 file.txt 中的内容进行排序，并且去除重复的行。 按照第二列数字大小排序： 这将按照第二列数字大小对 file.txt 中的内容进行排序。 使用逗号作为字段分隔符： 这将使用逗号作为字段分隔符，并且按照第二列的内容进行排序。 find命令搜索文件大小基本的 find 命令语法是： 其中： &lt;path&gt;：指定要搜索的路径。 &lt;options&gt;：用于控制搜索行为的选项。 &lt;actions&gt;：用于指定搜索结果的操作，比如 -exec。 下面是一些常用的 find 命令选项和用法： 搜索文件名： 这会在当前目录及其子目录中搜索文件名为 “filename” 的文件。 按类型搜索： 搜索文件： 搜索目录： 按大小搜索： 搜索大于指定大小的文件： 搜索小于指定大小的文件： 按权限搜索： 这会搜索所有权限设置为 644 的文件。 执行操作： 使用 -exec 执行命令： 这会找到所有 .txt 文件并执行 cat 命令来查看文件内容。 执行其他操作，比如删除文件： 这会删除所有以 .tmp 结尾的文件。 使用 du 命令以及sort命令整理與查找 mac 系統文件 查找一級目錄大小，按大小排序： 如果你想要按大小降序排序显示一级目录的文件大小，你可以将 du 命令与 sort 命令结合使用。 du -h -d 1：显示当前目录下每个一级文件和目录的總大小。 -h：以易读的方式显示文件大小，不加-h會將以原始字節的方式顯示文件大小。 -d 1：指定深度为 1，表示只显指定目录的一级子目录或文件的大小。 sort -rh：对 du 命令排序，-r 表示逆序（降序），-h 表示按照易读的数字格式进行比较。 使用find 查找當前目錄下的一級文件夾及文件 find . -maxdepth 1: 這個部分告訴 find 命令在當前目錄 (.) 下搜索，但僅搜索一級目錄，不搜索子目錄。 -maxdepth 1 限制搜索深度為一級目錄。 使用 find -exec 結合 du 命令查找當前目錄下的所有一級文件夾及文件 -exec 選項表示要執行一個額外命令，du -sh 則是計算目錄大小的命令，而 &#123;&#125; 代表找到的每個一級目錄的占位符，+ 則告訴 find 命令將所有找到的目錄一次性傳遞給 du 命令，而不是對每個目錄單獨執行 du 命令。 du -sh 會顯示當前目錄的總大小，而不包括子文件夾的大小。 -s 選項表示總和， -h 選項表示以易讀的方式（如 KB、MB、GB）顯示大小。 這個命令的意思是，先通過find查找了當前一級目錄下的所有文件及文件夾，在通過du命令查找這些文件及文件夾的大小。由於find查找出的一級目錄此時會被du命令二次查找，即查找出二級目錄，所以需要用du -sh來搜索當前目錄即可，而不需要再次深度查找。 使用sort 排序 其中，常用的選項包括： -r：表示反向排序，即降序排列。 -h：表示按照易讀的大小進行，例如 KB、MB、GB。 刪除文件 使用 rm 命令： 使用 rm 命令刪除文件。rm 是 “remove” 的縮寫。 例如，刪除名為 example.txt 的文件： 使用 rm 命令刪除多個文件： 你可以使用 rm 命令來一次刪除多個文件。 例如： 使用通配符刪除文件： 你可以使用通配符來刪除符合特定模式的文件。 這將刪除當前目錄中所有擴展名為 .txt 的文件。 刪除目錄及其內容： 如果你刪除目錄及內容，你可以使用 -r 或 -R 選項來遞歸刪除。 例如，刪除名為 folder 的目錄及內容： -rf 和 -r 的區別 -r 選項（或 --recursive）單獨使用時，表示遞歸刪除，它會刪除指定目錄下的所有文件及子目錄，包括子目錄中的文件和子子目錄中的內容。但是，如果遇到無法刪除的文件或目錄，會提示用戶確認。 -f 選項（或 --force）單獨使用時，表示強制刪除，它會忽略不存在的文件和不可寫的文件的權限，不會提示用戶進行二次確認的步驟。即使文件或目錄不存在，也不會顯示任何錯誤信息。 當你組合使用 -r 和 -f 時，即 -rf，表示強制遞歸刪除。這意味著無論文件是否存在、是否只讀，以及是否包含子目錄，都將被刪除，而且不會提示用戶確認。"},{"title":"【2023-08-08】拿水彩画了个锤子","date":"2023-08-07T16:03:33.000Z","url":"/2023/08/08/diary-0808/","categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"],["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"本来是录了绘画过程的，结果画完发现，没点开录制键。真~画了个锤子，醉了。 "},{"title":"【PCCS】 色调图（翻译）","date":"2023-08-07T09:44:18.000Z","url":"/2023/08/07/PCCS/","categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"写在开头日语原文来自：日本色研事業株式会社 HomePage 万一真的有人看这篇文章，奉劝看的懂日语的还是读日语，我对自己的翻译水平没什么自信。 什么是PCCSPCCS（Nippon Shikiken实用色彩坐标系统）是由日本色彩研究所开发的，主要目的是系统地解决色彩和谐问题，于1964年公布的系统。 虽然 PCCS 基于颜色的三个属性，但它的独特之处在于它可以用作色调和色相的二维系统。 * PCCS是Nippon Shikiken拥有版权的色彩系统。 PCCS的色相PCCS 色轮是 24 种最高饱和度颜色的排列，在感知上以相等的距离排列。 24 种色相定义如下。 被认为是红、黄、绿、蓝中心的色相，被称为心理四原色，显示在色轮上（红-2：R，黄-8：Y，绿-12：G ，蓝-18 ：B 先前确定的四种基本色相的心理互补色相显示在色轮上的相对位置（蓝绿-14：BG，蓝紫-20：V，红紫-24：RP，黄橙色-6：yO）。 将4种色相添加到上述8种色相中，使得每种色相之间的间隔在感知上以恒定速率变化，确定12种色相，并且对中间色相进行插值，形成24种色相。 ○：心理四基色（红、黄、绿、蓝）▲：颜料三基色（C、M、Y）△：色光三基色（R、G、B） 对于规划配色方案的色轮，通常采用以2、3、4为约数的12或24等分色轮，以便于选择2、3、4配色方案。PCCS 也采用了 24 色轮。 在色轮中，三种颜色16：gB、24：RP和8：Y对应于颜料（染料和印刷油墨）青色、品红色和黄色（减色原色）的三原色。另外，虽然无法表示色光的三原色（加法混和的三原色）红、绿、蓝，但在色卡中，与色光的三基色混合后变成青色、品红色和黄色的物理补色。如果要选择该色轮的三原色的色调去近似表示红绿蓝，则色轮中 3：yR、12：G、19：pB 3 种颜色可以表示与他们接近的色调。[1] *有关准确的颜色，请参阅“PCCS 谐波色卡 201-L” 。 PCCS的明度和饱和度明度白色和黑色之间的界限在感知上是均匀的。亮度符号与孟塞尔系统的亮度相匹配，白色为9.5，黑色为1.5，它们之间有17个等级，每级0.5。 饱和度在PCCS中，将各色相的代表色（鲜艳的色相）全部设定为相同的饱和度（9s），并分割从那里到非彩色的变化，以便可以以相等的间隔感知到它。为了与其他系统区别，PCCS饱和度用1s、2s至9s表示，饱和度首字母“s”。 三个属性的显示使用颜色的三个属性来表达颜色时，采用比例值和符号按照色相、明度、饱和度的顺序来表达，如“2：R-4.5-9s”。在无彩色的情况下，在无彩色“n”上加上表示亮度的数值，例如“n-5.5”。 PCCS的色调色调是明度和饱和度的综合概念。即使是相同色相的系列，也会有明暗、强弱、浓淡和深浅等调子的差异。这种颜色调子的差异被称为色调。设定了这种色调空间，是PCCS最大的特点之一。 每种色相分为12种色调，并将每种色相中相同色调的颜色汇集在一起。虽然明度有所不同，但会形成共同的明亮感觉群组。 在用色相和色调表示颜色时，例如色相编号12（绿色），在浅色调的情况下，会用缩写符号表示为“lt12”。在无饱和色的情况下，白色表示为“W”，黑色表示为“Bk”，其他颜色用表示亮度的数字加上“Gy”来表示，如“Gy-6.5”。 使用 PCCS 做色彩调和 根据CCS的色相和色调，可以将协调配色的形式分类如下： 同系的协调（共同要素的原则） 基于相同色相（相同、相邻）的协调 基于相同色调的协调 相似的协调（相似性的原则） 基于相似色相的协调 基于相似色调的协调 对比的协调（明确性的原则） 基于对比色相的协调 基于对比色调的协调 其他注[1]：此处我并不是完全根据原文进行的翻译，而是为了方便自己记忆理解，翻译的意思相近但说法略有偏差，原文如下： 色相環の中で、16:gB、24:RP、8:Yの3色は、色料(染料や印刷インキ)の三原色であるシアン、マゼンタ、イエローの色相にあたります(減法混色の三原色)。また、色光の三原色(加法混色の三原色)の赤、緑、青を色票で示すことは無理ではありますが、減法混色の三原色と混色すると無彩色になるような物理補色に相当する色相を色光の三原色の色相として選べば、色相環の中では、3:yR、12:G、19:pBの3色がそれらに近い色相として上げられます。 "},{"title":"【2023-07-30】试试用最便宜的材料来体验画水彩","date":"2023-07-30T10:03:33.000Z","url":"/2023/07/30/diary-0730/","categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"],["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"想试试看水粉能不能替代水彩于是。。。买了15块的管状青竹水粉，店铺送了一包素描纸，在闲鱼买了一只杂牌水彩笔，总价格不超过30块的东西。 性价比还行，就是送的纸很薄，很容易起毛，画一笔就开始炸毛，多画两笔基本上就纸也破了，边缘炸毛的不行了，比较烦。 颜料的话画完会发灰一丢丢，便宜水粉是这样的也没办法。 但覆盖力很强，水粉其实就是不透明水彩。在亚马逊上搜nicker不透明水彩或者荷尔拜因，出来的就是nicker水粉荷尔拜因水粉，非大陆的地区也是叫不透明水彩做水粉，大陆艺考为了便宜，所以材料用的低廉罢了。（还有店铺为了好卖材料，故意将不透明水彩和水粉的概念拉开）以至于大陆这边好多人都以为这俩不是一个东西。 （更有那些别有用心的，不知道是故意的，还是自己都没搞清楚，就在那里伪科普。） 所以感觉，纸质最重要，其次是颜料，其次是笔，总的来说性价比还是超高的~"},{"title":"【乱七八糟】五子棋ai的博弈树","date":"2023-07-15T06:02:07.000Z","url":"/2023/07/15/wzq/","categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":"简介博弈树是人工智能领域中用于描述博弈游戏的一种数据结构。在五子棋游戏中，博弈树可以被用来搜索最佳的下棋策略。 基本原理博弈树是一种树状结构，其中每个节点表示游戏的一个状态，每个边表示一步棋的走法。在五子棋游戏中，树的根节点表示当前棋盘的状态，每个子节点表示在当前状态下的下一步棋的可能走法。 博弈树的构建可以使用递归或迭代的方式进行。递归构建博弈树时，从当前状态开始，逐步生成所有可能的下一步状态，并将它们作为子节点添加到当前节点。这个过程会一直进行到达到终止条件，例如达到游戏结束状态或达到搜索的最大深度。 搜索方法博弈树的搜索是通过对树进行遍历来找到最佳的下棋策略。常用的搜索方法包括深度优先搜索（DFS）、广度优先搜索（BFS）、α-β剪枝等。 深度优先搜索：从根节点开始，沿着一个分支一直向下搜索，直到达到终止条件。如果搜索到达叶子节点或达到最大深度，就返回评估函数给出的当前状态的分数。如果当前节点有多个子节点，继续对每个子节点进行深度优先搜索。 广度优先搜索：从根节点开始，依次搜索当前节点的每个子节点，然后再搜索子节点的子节点，直到达到终止条件。广度优先搜索适用于较小的搜索空间，但在五子棋这样的复杂游戏中，搜索空间过大，广度优先搜索不太实用。 α-β剪枝：α-β剪枝是一种优化技术，用于减少博弈树搜索的分支数量。它利用极大极小算法的原理，在搜索过程中根据当前已知的最佳下棋策略来剪去无需再搜索的分支。通过设定上下界（α和β），在搜索过程中可以逐步收缩搜索空间，从而提高搜索效率。 优化技巧在五子棋博弈树算法中，由于搜索空间庞大，需要采用一些优化技巧来提高搜索效率。 剪枝策略：除了α-β剪枝之外，还可以使用其他剪枝策略来减少搜索空间。例如，可以通过启发式方法，在搜索过程中提前放弃不太可能是最佳走法的分支。 搜索深度控制：由于搜索深度直接影响算法的时间复杂度，可以通过设置合理的搜索深度来权衡搜索效率和结果的质量。 引入评估函数：为了减少搜索的复杂性，可以引入一个评估函数来对当前棋盘状态进行评估。评估函数可以根据一些启发式的规则来判断当前状态的好坏程度，从而避免搜索所有可能的走法。 剪枝策略剪枝策略是通过减少搜索空间来提高博弈树算法的效率。除了常见的α-β剪枝外，还有其他一些剪枝策略可以应用于五子棋博弈树算法。 启发式剪枝：在搜索过程中，可以根据一些启发式的规则提前放弃不太可能是最佳走法的分支。例如，当某个分支的棋局评估值远低于其他分支时，可以选择剪枝，不再继续搜索该分支。 禁手检测剪枝：五子棋中存在一些禁手规则，例如长连禁手、双活三禁手等。在搜索过程中，可以引入禁手检测剪枝，避免生成违反禁手规则的走法。 杀棋剪枝：在搜索过程中，可以通过检测某个节点是否形成必胜或必败的棋局，从而进行杀棋剪枝。如果某个节点的下一步棋可以直接获胜或导致对手必败，就可以选择剪枝，不再继续搜索该节点的子节点。 搜索深度控制搜索深度控制是通过设置合理的搜索深度来权衡搜索效率和结果质量。搜索深度越深，算法可以找到更长远的最佳下棋策略，但搜索时间也会随之增加。 固定深度搜索：最简单的搜索深度控制方法是固定一个搜索深度，不再继续向下搜索。这种方法适用于对搜索时间有严格要求的场景，但可能会影响算法的准确性。 迭代加深搜索：迭代加深搜索是一种渐进增加搜索深度的方法。开始时，使用较小的搜索深度进行搜索，然后逐步增加深度，直到达到预定的时间或深度限制。这种方法可以在较短时间内得到一个相对较好的结果，并且可以逐步改进结果。 时序搜索：时序搜索是一种根据时间限制来控制搜索深度的方法。通过设置一个固定的时间限制，算法在规定时间内尽可能搜索更深的层次，从而在有限时间内得到一个较好的结果。 引入评估函数评估函数是一种用于评估当前棋盘状态的启发式函数。引入评估函数可以在搜索过程中对当前状态进行评估，从而减少搜索的复杂性。 启发式评估函数：启发式评估函数基于一些启发式规则来判断当前状态的好坏程度。这些规则可以包括考虑棋子的形成连珠的潜力、考虑棋局的开放度、考虑棋子的价值等因素。通过评估当前状态的分数，可以在搜索过程中选择最有利的走法。 模式匹配评估函数：模式匹配评估函数是一种基于已知的棋局模式进行评估的方法。通过事先学习和存储一些常见的棋局模式，可以根据当前状态的模式匹配程度给出评估分数。这种方法可以较快地对当前状态进行评估，从而加速搜索过程。 神经网络评估函数：神经网络评估函数是利用神经网络模型来评估当前状态的方法。通过训练一个神经网络模型，将当前状态作为输入，输出一个评估分数。神经网络可以学习复杂的状态特征和权重，从而提供更准确的评估结果。 简单代码不包含具体实现，只是写一个大概的思路。 总结五子棋游戏的博弈树算法是一种用于搜索最佳下棋策略的方法。通过构建博弈树，并使用适当的搜索方法和优化技巧，可以在搜索空间庞大的情况下找到较优的下棋策略。然而，由于五子棋的复杂性，完全搜索所有可能的走法是不现实的，因此需要结合启发式方法和评估函数来提高搜索效率。 ,A handsome and cool blond boy with exquisite facial features and blue eyes, holding his chin with one hand, the sun hits his face from behind.In the church many pigeons flew over,masterpiece, best quality, very detailed, extremely detailed beautiful, super detailed, tousled hair, illustration, dynamic angles, fashion clothing, standing, mannequin, looking at viewer, beautiful detailed eyes, exquisitely beautiful face, floating, high saturation, beautiful and detailed light and shadow"},{"title":"【2023-07-14】诈骗手段真是层出不穷吖！","date":"2023-07-13T19:40:30.000Z","url":"/2023/07/14/diary-0714/","tags":[["防诈骗","/tags/%E9%98%B2%E8%AF%88%E9%AA%97/"]],"categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"刷了一段时间视频之后，觉得有些手段，就算是我遇到一样可能会上当呢。 想着自己不会上当的话，还是太naive了。 果然还是总结一下防止上当吧。。！！！！！ 诈骗的手段其实很多骗子也是被骗过去的，比如说提供高薪机会，被骗到国外，脱不了身。再加上骗了别人的钱，他也有分成。 冒充公职人员： 接触阶段：骗子通常通过电话、电子邮件、短信或社交媒体等方式联系，自称是公职人员，试图获得信任。。 虚假故事：骗子会编造一个故事，例如涉及了犯罪案件、有未支付的罚款、涉及税务问题等，以制造紧急情况并迫使你采取行动。要你现在去某某（异地）的公安局，当你本人表示不能现在过去，他就开始了他的骗局。什么网上法院、网上处理案件巴拉巴拉。 要求信息或资金：骗子会要求您提供个人信息，例如身份证号码、银行账户信息、密码等。他们还可能要求你转账款项或提供信用卡号码等财务信息。 如何防骗：自己去对应的公职部门问。不要相信电话那头的人提供的联系方式、对接方式。 网络做任务类：通过招聘信息，或给你打电话，问你有没有想要做某某兼职，发布网络兼职刷单，返佣金等等。。 一开始充小额返还正常，后来就开始额度越来越大，然后就开始骗人了。就我在网上刷了这么多诈骗视频总结的，就是一开始充200返你210。。小额都是正常的，到了500，基本就要开始正儿八经的行骗了。 如何防骗：警惕连单、提取失败。 连单：做了一些小任务后，告诉你连续做十个几十个任务，一次性提现，佣金会更高，实际上就提不出来了。 提取失败：一个群里，全都提取成功，就你一个人或者两个人失败。然后告诉你要再充值，然后给你解锁blabla。。然后你看群里其他人都发了提取成功的截图，你就充值了。后来你会发现，这个群里除了你全是托儿。就是为了骗你一个人的钱吖。 比如说你充了五千，遇到所谓的网络不好，提不出来了，告诉你再充一万可以解锁，然后你充了一万，又遇到所谓的超时，提不出来了，然后告诉你再充二万可以解锁。。。然后就一层滚一层。容易上当的就是沉没成本，还有一个就是愧疚感吖，比如全群说就因为你一个人，导致全群的人无法提取出来了。逼你不得不充值吖什么的，其实他们都是托吖！！！！！！！！！！！！！！！！ 骗子不一定是一个时间段内在骗你，他可能分好几天，分好几周，分好几个月，就只是为了让你放松警惕。然后再行骗。 冒充客服类：买了xx东西，说快递丢了或者别的理由，然后说退你钱，或者赔你几倍的钱，可以理赔。 又比如，你的电话号出了什么什么问题，然后说需要核实解锁。 但是需要你先垫手续费。还有比如说让你开启屏幕共享或者远程共享，那在手机里无论输入什么（密码？身份证？），对方都知道了屏。 最近特别流行的京东金融客服诈骗，电话过来连来电名都是京东客服。打电话过来说你绑定了什么什么京东金条，然后说你有借贷或者别的，需要关闭。 仔细想想这种要是打给我我都有受骗的可能，因为像我们不借贷的，根本不了解什么借贷平台的操作，还会以为真的是误操作需要解绑或者怎么样了。 如何防骗：反正这一类打着官网的旗号，就不要去理，直接去京东的app里问在线客服，或者自己打官方的客服电话问，不要用他给你的所谓官方的联系方式，不用他来转接。自己去和官方客服联系核实情况。 还有一点很重要的，京东的客服不会通过别的app和你联系的。不会通过xx会议软件去和你理赔 遇到的：今天遇到了，昨天在黑猫和315投诉了某购物平台，然后当天下午有自称黑猫的工作人员联系我，说要你下载某会议app，给你进行处理并赔偿blabla。我问你是搁哪儿诈骗呢？她尴尬了一下说不出话了。然后不挂电话，也不说话。后来我觉得无趣，就挂断了。然后当天下午真正的客服平台及反诈中心接连给我打了电话，提醒我那个号涉及诈骗blabla，但话说。。黑猫信息不是号称保密么？究竟是怎么弄到我电话的呢？ 投资股票期货：有一些假app，做的外观跟某些国外的app一样，然后后台其实都是假的，就跟我以前写活动抽奖转盘的代码一样。你以为你差一点点就抽到了大奖？其实我的代码里写着永远都不会让你抽到的，只是动画和交互看起来是你差一点点就能抽到而已。 这种app里的期货都是假的，后台想升就升，想降就降，就是为了让人充钱然后骗钱。 就算有一些做的比较真实的，真的从外网拿了数据的，后台一样可以锁定的，比如说只能让你充值，你一提现，就各种有问题吖什么的。 还有类似的，博彩类。比如让你下载赌博类的app吖什么的，然后一开始让你小赢，然后大输输输输输。。。。。。 如何防骗：因为像国内web3，虚拟货币这些，根本就没被允许阿。所以你如果没翻墙，就别想着阿自己在手机上在搞投资这些东西。肯定都是假的！！！！ 翻墙，不能像我一样就是为了学习么？？？国内的股票都没玩明白还想着在国内去玩国外的。 ———————————————— 题外话感觉有些人脑子真的是很龌龊。有次在一个blender的qq群里有人问骨骼绑定，就回他说discord有个大佬给我讲了这个骨骼绑定blabla。。然后有几个男生说“discord那种全是小电影儿的地方还有人讲这个?”给我鲸呆了。还有正常聊天有时候和男生聊到翻墙，居然有人疑惑“你一天翻墙都干什么”他觉得正经的女生都不翻墙，翻墙的都在干不正经的事情。关键是不止一个人这么疑惑阿。。绝了。 ————————————————— 资金盘这类骗局吸引人们投资一定金额，并承诺高额回报，但实际上是靠后来的参与者的投资来支付之前的参与者回报，而不是真正的盈利活动。这种骗局的基础是持续吸引新的投资者，直到无法支付回报或骗子消失，导致大多数人损失全部投资。 一开始宣传会告诉你，低风险，高回报。xx天一个周期，xx天/月给你百分之xx的回报。。。吸引你投钱。 不知道这个该不该说是诈骗。但肯定是为了骗你钱吖。 其实我觉得就相当于网络传销庞氏骗局。用新用户的钱，补老用户的坑。结局就是老用户空补不上，他们就跑路了。 现在的资金盘，为了让你看不出来，就改一些套套，比如说，数字藏品、元宇宙、数字货币。 如何防骗：还是那句，国内不支持这些。 而且缺乏监管，口子太大，你一个小屁民怎么玩得过别人吖。 普通人就像大时代里霍景良说的： 一個月都係賺個一萬幾千，死慳死抵玩股票，妄想一朝發達，佢哋根本就晤知道真正嘅大贏家係邊個。 应该没打错台词吧。粤拼不太好。 杀猪盘拒绝网恋，这类没太了解过。因为不会网恋。 别说网恋了，这辈子连找对象的欲望都没有。 各种交友app，除了以前在公司，公司是做这类交友app的互联网公司，被迫注册的员工账号，其他的听都没听说过。。。 因为在男女感情的需求方面实在淡薄，所以放个视频记一下，万一以后脑抽想谈恋爱呢。。。。 如何防骗：最好的做法，拒绝网恋。 （爱自己，对自己好不香么？？平时爱自己都一直觉得做的不够多不够好，所以没有什么精力去爱男人了） 实在不行，切记，感情中，不借钱，不投资。 见到秦始皇打钱的类似手段就别上当了。 传统电信手段银魂的拙者拙者诈骗，这种诈骗手段有点旧了。不过这种东西和时尚一样都是一个轮回吖。 具体就是假冒你的熟人，然后骗你的钱。 现在的变种就是比如说微信号qq号，各种资料搞得和你朋友一模一样然后骗你。再加上现在的ai比较方便。有了录音有了照片，就可以模拟你朋友的脸了。比如我之前研究过的D-ID就可以实现。 如何防骗：和熟人二次确认。提防ai冒充你的熟人。 视频聊天还有一类刷到的比较少，男的好像遇到的多吖。感觉本人这种社恐女生（or 拙者hhhh）且不喜欢视频聊天的不会上当。 具体就是有女的，说要和你果聊，然后让你下某某app，获取你的各种个人信息。然后趁机录下你的视频，然后要挟你给钱，不给的话就会曝光你，然后发给你的各种熟人吖同事吖朋友吖什么的。 不果聊也会有危险吖，因为现在ai很发达，首先用ai给你的脑壳换个果照很容易的。别说ai了，就算纯手工，我一样能把任何人的头ps换到范冰冰身上。 如何防骗：不要和陌生人说话，不要和陌生人视频，最好不要存电话号，背下来。 其他类型的诈骗 为你的支付宝转几千块钱，或者说话费充错了，充到了你的手机号。问你能不能把钱还给他，如果答应了，他会往你的手机号发来各种验证码，然后让你将验证码告诉给他。其实这些验证码都是网贷平台的，骗子其实有你的个人信息（个人信息泄露），然后会用你的个人信息在网贷平台借贷，获取验证码，然后只要你把验证码告诉了他，他就可以用你的名义在各大平台贷款了。 有一些网页游戏或者广告内的游戏，下载后，里面有弹出框或网页说需要实名认证（正规游戏要实名认证，但这些游戏实际上是骗人的），然后需要你输入身份证、手机号、验证码等等。实际上这些信息是用来贷款的。记住实名认证是接口对接的，如果有手机号了，就不需要你的身份证信息。如果没手机号才需要验证身份证。如果你是拿手机号注册的，只要手机号是正规途径办理的，就相当于已经实名认证过了，所以这种情况不会要你的身份证。而且你输入个假的身份证，假网页走到信贷那一步才知道。而真实名认证在你输入错误信息那一刻就会给你反馈结果了。还有一点需要注意的，他可以通过不同的地方来获取你的验证码和身份证信息。比如说，我先让你注册，注册过程中只需要你的手机号和验证码。然后你玩一会儿，或者注册好了准备玩了，他在告诉你需要实名认证，获取你的身份证信息。或者两步反过来，先让你实名认证，再告诉你手机号注册。（可能性更大，因为验证码有时间限制，不如先获取你的身份证信息。）这样一样有可能上当。终极防骗的手段切记：实名认证不需要任何形式的验证码。 警惕ai换脸，github上看到过项目，就是只要有一个人的声音片段，就可以根据这个人的声音片段生成想要说的话吖。包括比如说D-ID也有这个功能。ai换脸，还能生成视频。还能生成声音文字吖什么的。那就可以骗你身边的人了。 说扫码送什么东西，实际上有可能是借贷平台。不过最近更多的可能是个人养老金。反正不要在街边扫码什么的。 我本人遇到过的，就是走在路上遇到个大叔，说他丢了钱包，让你帮他买份饭，你去帮他买饭，地方有点偏，他把你给卖了。女生一定要小心。这种基本全属于人贩子。走两步就是警察局不去，拦一个陌生女生要你帮他买饭。还有比如说不记得自己住哪里了，提不动东西让你帮手，身体不好要你帮忙扶一把，要你带他回去。你就直接带去警察局吧，真的假的反正让警察来处理。收起你的好心。 包括晚上打车，有女生说她打好车了，要你和她一起，不能说这种绝对是人贩子，但有这种可能性。幸好，幸好我晕车吖！！！！ 前段时间那个谁谁的演唱会门票，咸鱼有好多假链接。就是你点进去，虽然长得一模一样，其实是假页面吖。然后你付了款，就被骗了钱吖。 街边有人拉你走，然后比如说有个假扮警察的，假扮好心人吖什么的，给你解围，你要警惕，他可能也是人贩子。 帮忙找宠物、谎称自己被跟踪、各种人贩子。 ‘p;.; huang谎称防疫人员隔离，让你去某地。这个现在应该不会了吖。 为什么诈骗的钱追不回来因为诈骗犯有各种各样的洗钱手段。 比如说虚拟货币，比如说虚构的房地产交易，比如说虚构的慈善机构这些。 还有就是把非法的资金和合法的业务进行混合这样就很难追踪。通过很多小公司商业交易。 还有就是像假的投资机会，然后这样就可以把非法的资金合法化。 比如说把非法的资金和合法的资金，用一些手段放在一个安全的账户里，那一个账户里有非法资金，还有合法资金的话，不可能说把这个账户给禁掉。 就比如说咸鱼代充话费，一般价格会比官网来的要便宜一些。比如你想充500，你给我400，我就给你充500了，其实他充话费的500块钱可能是不合法的途径得来的，但是他把这个500充到了移动联通电信blabla，那这个钱就进入一个安全的账户。损失一点点小钱把不合法的钱就洗干净了。类似的手段还有充水费充电充燃气费。 遇到诈骗时，随时引起注意的点 警察抓你之前是不会打电话来问你有没有时间立刻去异地的派出所的，直接就会上门了。 非腾讯的客服不会用腾讯的通讯工具来联系你，淘宝京东支付宝，人家都有自己的通讯工具。 诈骗犯骗人的时候一般会确认他周围有没有别的人，要求周围绝对安静，要求通讯工具静音，也就是不让人接到来自其他人（警察）的电话。 远离远离远离刷单兼职。刷单兼职群里无论谁发的转账信息截图，都是托。一个群里除了你一个正常人，其他全是拖。骗子可能利用你的沉没成本心里，骗子可能利用你的愧疚心理。 如果号称是什么官方的人，不要跟着他他的鼻子走，去自己联系官方的客服，而不是使用他们提供的渠道。（我一个做前端的有时候看他们的页面都觉得做的实在很像。更何况不是做这行的人） 如果真的被骗了，不要抱着侥幸心理，想着等等，万一不是被骗呢？立刻报警！！！！或许还能冻结账号被找回来钱吖。 诈骗的预防方法 保护好个人信息，包括声音，包括面容。 下载国家反诈中心 注意96110的来电，是反诈中心的电话 如果是00开头的电话，如果没有国外的亲戚，感觉一般都是诈骗电话。 怎么反诈 没必要不要下各种会议类软件，诈骗犯让下这种软件也不要下。不要开启远程操作。 不要加陌生好友。不要和陌生人视频聊天。 不要点陌生链接，不要点别人给你的陌生文件。 不要提供给任何人任何验证码，或者听信别人的话往邮箱发邮件（这种一般是冒充你的好友，让你帮忙解封微信或者别的）。再三确定是否为对应官方的机构。 蚂蚁保什么的理赔，别信。 我都不知道这篇日记会不会又导致我的域名被ban掉。"},{"title":"【日常】アルベス一万尺","date":"2023-07-10T20:31:23.000Z","url":"/2023/07/11/arubesu/","tags":[["日语学习","/tags/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"]],"categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"之前看蜡笔小新的时候，听风间唱的儿歌。觉得很有意思就查了日语原版的歌词。 ララララララララ ラララララララ ララララララララ ラララララ 就省略了，反正就是每段唱完然后rarara 歌词 アルプス一万尺 小槍の上で アルペン踊りを 踊りましょ 昨日見た夢 でっかいちいさい夢だよ のみがリュックしょって 富士登山 岩魚釣る子に 山路を聞けば 雲のかなたを 竿で指す お花畑で 昼寝をすれば 蝶々が飛んできて キスをする 雪渓光るよ 雷鳥いずこに エーデルヴァイス そこかしこ 一万尺に テントを張れば 星のランプに 手が届く キャンプサイトに カッコウ鳴いて 霧の中から 朝が来る 染めてやりたや あの娘の袖を お花畑の 花模様 蝶々でさえも 二匹でいるのに なぜに僕だけ 一人りぽち トントン拍子に 話が進み キスする時に 目が覚めた 山のこだまは 帰ってくるけど 僕のラブレター 返ってこない キャンプファイヤーで センチになって 可愛いあのこの 夢を見る お花畑で 昼寝をすれば 可愛いあのこの 夢を見る 夢で見るよじャ ほれよが浅い ほんとに好きなら 眠られぬ 雲より高い この頂で お山の大将 俺一人 チンネの頭に ザイルをかけて パイプ吹かせば 胸が湧く 剣のテラスに ハンマー振れば ハーケン歌うよ 青空に 山は荒れても 心の中は いつも天国 夢がある 槍や穂高は かくれて見えぬ 見えぬあたりが 槍穂高 命捧げて 恋するものに 何故に冷たい 岩の肌、 .ザイル担いで 穂高の山へ 明日は男の 度胸試し 穂高のルンゼに ザイルを捌いて ヨーデル唄えば 雲が湧く 西穂に登れば 奥穂が招く まねくその手が ジャンダルム 槍はムコ殿 穂高はヨメご 中でリンキの 焼が岳 槍と穂高を 番兵において お花畑で 花を摘む 槍と穂高を 番兵に立てて 鹿島めがけて キジを撃つ 槍の頭で 小キジを撃てば 高瀬と梓と 泣き別れ 名残つきない 大正池 またも見返す 穂高岳 まめで逢いましょ また来年も 山で桜の 咲く頃に アルプス一万尺の原曲は、アメリカの民謡「ヤンキードゥードゥル」という曲です。独立戦争の際の愛国歌として知られています。この曲に日本の歌詞をのせたのが「アルプス一万尺」です。 歌詞を作ったのは京都大学の山岳部の学生とされていますが、定かではありません。そしてアルプス一万尺の歌詞はなんと29番まであるのだそう！ そのなかには槍ヶ岳や西穂高岳など、日本アルプスの山の名前が登場します。この歌詞に出てくる「アルプス」は、中部地方にある3つの山脈「日本アルプス」をさしているのです。 翻译一下大概意思就是原曲是一首美国民谣，名为“Yankee Doodle”。被誉为独立战争时期的爱国歌曲。据说歌词可能是京都大学登山部的学生写的。而且歌词有29段那么多。出现了矢鹿岳、西穗高山等日本阿尔卑斯山的山名。歌词中的“阿尔卑斯”指的“日本阿尔卑斯山”。—————————————————————————————————————————— 拍手歌同时这也是一首拍手歌 youtube跟学拍手 恩，虽然只是学了一首儿歌，感觉我的蹩脚n3日语又进步了呢（什么错觉）以后万一我有小孩了，就跟她拍这个哈哈哈哈哈哈哈哈哈哈哈哈"},{"title":"【进程与线程】理解计算机中的任务管理","date":"2023-07-10T03:20:19.000Z","url":"/2023/07/10/jinch/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"简单回顾一下 进程和线程是任务管理的两个关键概念。它们帮助操作系统有效地执行多个任务，并确保计算机的高效运行。 进程：任务的执行实例想象一下，你的计算机就像一间工厂，每个任务都是一个工人。进程就是这些工人的执行实例。每个进程都是操作系统为执行任务创建的独立实体。 进程拥有自己的内存空间、文件描述符、打开的文件以及其他资源。它们相互独立，不会直接干扰其他进程的运行。 进程之间通常是相互隔离的，这有助于提高系统的稳定性和安全性。 举个例子，当你同时运行多个应用程序时，每个应用程序都在独立的进程中运行。这使得你可以同时使用多个应用程序而不会相互干扰。 线程：任务的执行单元线程是进程中的更小执行单位，它是任务的实际执行单元。每个进程可以包含多个线程，这些线程共享进程的资源。 不同于进程的独立性，线程是在同一进程内运行的，并共享同一内存空间。这意味着线程之间可以方便地进行通信和共享数据。 由于线程之间的切换开销较小，所以使用线程来执行并发任务能够提高计算机的效率。 举个例子，当你使用浏览器访问网页时，浏览器进程会创建多个线程来处理不同的任务，例如渲染页面、下载文件和处理用户输入等。这使得你可以同时进行多个操作，例如在网页上观看视频的同时进行其他浏览器操作。 进程与线程的关系进程和线程之间存在密切的关系。每个进程至少包含一个线程，这个线程被称为主线程。主线程负责进程的启动和执行，并可以创建额外的线程来处理其他任务。 进程和线程之间的关系可以用以下方式总结： 进程是任务的执行实例，线程是任务的执行单元。 进程是独立的实体，而线程是在同一进程内运行并共享资源。 进程之间相互独立，线程之间可以进行通信和数据共享。 进程切换开销较大，而线程切换开销较小。 在 macOS 和 Linux 上查看进程和线程现在让我们来看看如何在 macOS 和 Linux 上查看进程和线程的命令。 在 macOS 上，你可以使用以下命令来查看进程和线程： 查看所有进程：ps aux 查看特定进程的线程：ps -T -p &lt;进程ID&gt; 在 Linux 上，您可以使用以下命令来查看进程和线程： 查看所有进程：ps -eF 查看特定进程的线程：ps -T -p &lt;进程ID&gt; 通过这些命令，你可以获取进程和线程的相关信息，例如进程ID、线程ID、CPU 使用情况等等。"},{"title":"【zbrush】雕刻笔刷总结笔记","date":"2023-07-05T10:45:09.000Z","url":"/2023/07/05/zb1/","tags":[["建模","/tags/%E5%BB%BA%E6%A8%A1/"]],"categories":[["zbrush","/categories/zbrush/"]],"content":"把notability的笔记总结过来 需要提前掌握的内容有zbrush基础操作 笔刷快捷键设置：同时按下alt+command，单击需要自定义笔刷的图标。 一、常用笔刷Clay：黏土笔刷，最基础的雕刻笔刷。 Move：移动笔刷，做一些大形使用 magnify：膨胀笔刷，调小时可以画一些皮肤的青筋 Planar：平化 pinch: 挤捏 groom：毛发相关的笔刷 SnakeHook：蛇形沟，画头发是一绝的笔刷，有点像Move但比Move更加灵活。 比如说可以像这样先拉出头发的大形。 Stardard：标准雕刻，其实和Clay差不多，我一般使用clay DamStandard：可以用来做划痕。比如说一缕头发或者布料，可以先新建一个球然后用蛇形沟拉出形状。然后用damstandard 反向 or 正向雕出表面的划痕。 二、插入笔刷（imm）这类笔刷以 imm 开头 打开笔刷，按”i“可以搜索到 雕刻人像，常用的是 IMM BParts，点击选择之后，可以在上方选择要添加的五官 比如说，我要在球上加入耳朵，我可以这样 对了，我是开启了对称，居然会有人问我怎么开启对称。。按x阿。 四、修剪笔刷（trim）1. 四类笔刷的说明使用command + shift 可以选择四类笔刷： clip、select、slice、trim 2. trim笔刷的简单说明按command + shift 可以使用修剪，笔刷会包括trim相关，可以进行选择。 trim的效果，可以修剪表面 侧边修剪的效果 整体来看的话 五、分割笔刷（slice）按command + shift 可以使用分割，笔刷会包括slice相关，可以进行选择 1. slice笔刷基本使用。分割物体表面，是可以选择到背面的。 打开网格，选择slice笔刷，在表面进行选择，会看到表面被分割 且该分割可穿透，看背面吖 slice笔刷选择后，按 command + shift 分割，分割好之后，按ctrl shift点击区域，可以选择该区域。再次点击该区域可以反选，再次点击该区域取消选择。 2. 修改拓扑在修改拓扑中下面有删除隐藏，可以删除掉当前slice且看不到的结构，然后点击封闭孔洞可以封闭孔洞。z’v’d’d’f’f’f’f’f 3. 移动修剪区域ctrl shift 画出形状不松手按住空格可以移动修剪区域 六、蒙版和剪切1. 蒙版按command可以使用蒙版，笔刷会变成蒙版相关，可以进行蒙版。 选择：直接在需要选择的部分进行框选，未选择部分进行隐藏。 取消选择：在模型外按住 command 用鼠标框选一下任意空白处即可 反向选择：在模型外按住command 点击鼠标左键。 一般使用完蒙版后，可以使用提取进行抽壳。 使用方法子工具 - 提取 2. 选择按command + shift 可以使用选择，笔刷会包括select相关，可以进行选择 选择：在按住 command + shift 后，直接在需要选择的部分进行框选，未选择部分进行隐藏。 取消选择：在模型外按住command + shift 点击鼠标左键 反向选择：在模型外按住command + shift 用鼠标框选一下任意空白处即可。 七、 曲线笔刷（curve）1. 通用曲线笔刷clip、select、slice、trim及少部分其他笔刷是有curve类的，说一下通用的方法。 按住ctrl shift拉出直线，然后按住alt可以在想转角的地方转角。双击双击alt可以将转角转成直角。 2. curveLathe 车削笔刷 3. curveTube和curveMultiTubecurveTube只能画一条，画另一条时前一条会被删除。 curveMultiTube可以画多条。 八、 贴图参考1. 整体参考绘制 - 加载图像 2. 局部参考绘制 - 前后/上下/左右 在绘制中还有一个重要功能是前后上下左右，可以在网格中贴图，网格正面也能贴背面也能贴。贴图1就是正面，贴图2就是背面的 绘制 - 填充模式可以调整背景透明度的。 如上所述的。 2. 贴图纹理参考纹理 - 图像平面 - 加载图像 在下方可以调整发什么角度的参考视图个。 就。。"},{"title":"【梯子】如何自己搭建科学上网的环境","date":"2023-06-01T09:36:06.000Z","url":"/2023/06/01/djvxn/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"动不动ban我域名，看样子这篇文章在域名到期前别想放出来了 "},{"title":"【blender】geometry nodes","date":"2023-06-01T02:13:20.000Z","url":"/2023/06/01/blender-geometry-node/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":"把我在notability的笔记复制过来。是当时跟着Geometry Nodes - Blender 3.0 ( Introduction for Beginners )教程过的几何节点知识。 当时写的比较乱，还有语音笔记，改天得重新整理好。 "},{"title":"【其他】摄影及绘画有关的术语对照","date":"2023-05-16T10:36:45.000Z","url":"/2023/05/16/syyhh/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"是总结用来ai绘画的，不过我也确实不怎么懂构图 对构图唯一的了解就是学素描的时候老师说物体要稍稍偏右偏下blabla 拍摄角度（Shooting Angles）： High Angle Shot：高角度拍摄 Low Angle Shot：低角度拍摄 Eye-Level Shot：与眼平拍摄 Bird’s Eye View：俯瞰视角 Worm’s Eye View：仰视视角 Dutch Angle：倾斜角度拍摄 构图（Composition）： Rule of Thirds：三分法构图 Leading Lines：引导线构图 Symmetry：对称构图 Balance：平衡构图 Framing：框架构图 Diagonal Composition：对角线构图 透视（Perspective）： One-Point Perspective：单点透视 Two-Point Perspective：双点透视 Three-Point Perspective：三点透视 Wide-Angle Perspective：广角透视 Telephoto Perspective：长焦透视 光源、光的方向 Front Lighting：正面光照 Backlighting：逆光照明 Rim Lighting：边缘光照 Side Lighting：侧面光照 Top Lighting：顶部光照 Bottom Lighting：底部光照 Natural Light：自然光 Artificial Light：人工光 Diffused Light：漫射光 Hard Light：硬光 Soft Light：柔光 Directional Light：定向光 Key Light：主光源 Fill Light：补光源 Accent Light：点光源 Ambient Light：环境光 Cast Shadows：投影阴影 Highlight：高光 光的色彩 Color Temperature：色温 Cool White：冷白光 Warm White：暖白光 Daylight：白天光 Natural Light：自然光 Artificial Light：人工光 Incandescent Light：白炽灯光 Fluorescent Light：荧光灯光 LED Light：LED灯光 RGB Lighting：RGB彩色灯光 Ambient Light：环境光 Direct Light：直射光 Reflected Light：反射光 Diffused Light：漫射光 Flickering Light：闪烁光 Colored Light：彩色光 Saturated Light：饱和光 Tinted Light：染色光 Cool Colors：冷色调 Warm Colors：暖色调 配色相关 Color Scheme：配色方案 Primary Colors：主色 Secondary Colors：次要色 Tertiary Colors：中间色 Complementary Colors：互补色 Analogous Colors：类似色 Monochromatic Colors：单色调 Warm Colors：暖色调 Cool Colors：冷色调 Neutral Colors：中性色 Vibrant Colors：鲜明色彩 Pastel Colors：柔和色彩 Earthy Colors：大地色调 Gradient：渐变 Hue：色调 Saturation：饱和度 Value/Brightness：明度 Color Harmony：色彩和谐 Color Contrast：色彩对比 "},{"title":"【2023-05-12】blablablabla","date":"2023-05-12T03:28:18.000Z","url":"/2023/05/12/hh/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"画画也好久不画了自从有了midjourney，感觉我这种菜鸡水平一下子就被比下去了。 blender都有一段时间没打开了。 少女阿！你不爱画画了么！！！！！ 沉迷任天堂，翻出了我的新大三，打了两周的新马里奥兄弟2和马里奥3dland。 拿到了五星闪光存档，成功的让马里奥摘下了帽子。 然后又打古早七宝奇谋12，都是打了十几遍的游戏。 连switch都好久不打开了，我的岛给删了。我也不知道switch的云备份是需要原来的机子在吖！！！！ 把新大三的岛捡起来了，然后由于没有人，所以有一个需要旅行的建筑没解锁。 我的商业街已经开到了格蕾丝奢侈品店，那个gay里gay气的格蕾丝动不动就一脸傲娇不屑的说【对现在的你来说，xxx算是高岭之花了】 新大三的岛没有switch那么。。。那么能布置，就是啥都能摆在户外。 水果比switch种类多多多多多了，还有稀有的美味水果。 我哪知道稀有的美味水果是拿来种的吖！我直接就吞了，结果到现在也遇不到了。 switch的岛民搬走前一定会通知人，然后人同意了才会搬走。 新大三的岛民，运气好了你问他他会说在考虑搬走，然后你还能挽留一下。更多的时候可能吭都不吭一声，留封信就走了。。 然后你就只能偶尔在商店街看到他。 还有一个谣言就是三丽鸥系列只能在switch用，新大三不能用。。拜托三丽鸥系列本来就是在新大三那会儿发售的。 三丽鸥的家具可真好看吖！ 以前在南岛还是偶尔能遇到人的，现在在南岛坐一天也遇不到一个人。 航平航海的时候总是秀恩爱，在switch里没透漏过他那一大家子吧。 他的老豆在switch里我记得是在巴猎岛上运行李吧，在新大三南岛上搞了各种各样的小游戏，什么拼化石找艺术品找家具抓虫抓鱼抓海洋生物。。。 最变态的就是捉迷藏和那个连连看，真的有人类能轻松的过最高级的连连看么？？？？ 还有那个总被同伴扔下海的（？）海鸥，新大三里我好像记得叫醒他就能得到东西了。可是switch里就需要帮他找零件找手机壳。。或者叫通讯设备？反正我每次挖到都感觉像个手机壳。 switch的动森是布置元素多了，3ds的新叶是交互性更强，动物的性格和对话也比较丰富，节日和平时还会找你玩游戏什么的，switch这方面就单调些。 比如gay里gay气的格蕾丝，鹈鹕姐妹和邮递员不可不说的那些事儿，暴躁河童相亲相爱的一家人。。。 半夜被鹈鹕妹妹腹诽，催河童快点儿划船别唱歌了，他会抱怨我一直啪啪啪，啪啪啪的按，像个麻了爪的大龙虾。。 二楼的发型师，做的发型十有八九都好丑。 还有暴躁reset叔叔和racket叔叔（我不太明白为什么叫球拍叔叔，我日语没那么差吧能认错单词），有段时间我那个大喇叭没办法发出声音，就是一想说话就说【好像暂时无法使用】什么的，某天突然好了，我也不知道为啥。 查的时候看有人说是因为鼹鼠在喇叭里面堵着？？不太懂，反正我修了重置监控中心之后好像没多久就好了。算个谜团吧。 —————————————————————— 决定每周还是做一个blender模型、小场景什么的吧。 画画，每周画张画 准备面试，10月份回北京~ 我想看的书：平面构成、色彩构成"},{"title":"【2023-05-12】blablablabla","date":"2023-05-12T03:28:18.000Z","url":"/2023/05/12/hstory/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 故事标题：《**魔法启示录** —— 奇幻小镇的惊奇冒险》 在一个名叫艾尔维尔的奇幻小镇上，生活着一个名叫艾米莉亚的年轻女巫。 艾米莉亚是个充满好奇心的女孩，对奇幻世界中的各种魔法和神秘充满了憧憬。 有一天，艾米莉亚在森林里的一本古老魔法书中发现了一种特殊的咒语，据说能够召唤出一只拥有特殊能力的魔法兔子。 她兴奋地念出了咒语，但没想到却引来了一只又胖又懒的大灰兔，名字叫做波波。 波波声称自己是从一个名叫“梦幻岛”的奇幻世界而来的。 波波能够嗅出隐藏在世界各处的几件传说级魔法道具，就像一只能嗅出宝藏的猎犬一样。 但除此之外，波波什么都不记得。 艾米莉亚在书中看到过“梦幻岛”，是一个拥有传说中的魔法道具和无数财宝的地点。 但没有人知道“梦幻岛”是否真实存在。 为了变成一个更厉害。。。并且更有钱的魔法师，艾米莉亚决定带着波波旅行世界，去寻找关于“梦幻岛”的秘密。 首先，着手寻找这几件魔法道具，以及这只会说话的大灰兔——波波身上隐藏的秘密。 于是她们展开了一场惊险刺激的冒险之旅。 他们遇到了各种各样奇怪的生物和魔法怪物。 在旅途中，他们结识了一位叫做奥利弗的勇敢骑士，一个叫做莉莉的可爱精灵，以及一个名叫乔治的奇美拉巨人。 这个团队一路上经历了许多有趣的事件。 最终，在艾米莉亚和她的新朋友们的帮助下，他们终于找到了这几件传说中的魔法道具，原来这几件传说中的魔法道具，就是开启“梦幻岛”的钥匙。 他们来到了传说中的“梦幻岛”，见到了将波波变成了兔子的“神明”。一个变化万千的存在。 “终于，这一天到来了”，神明这样说道，“一切都如我所预料的一样。” “神明”的目的，究竟是什么？他究竟，是不是“神明”。。。？ 他们是否会解开这个世界的秘密，一切是否会如他们所愿……？ 世界背景：在一个名叫艾尔维尔（Elveril）的大陆上，存在着广袤的森林、浩瀚的山脉、神秘的河流和辽阔的草原。这个世界中，充满了各种神秘的生物和神灵，其中包括精灵、矮人、人类、兽人、巨人等等。他们在这片大陆上相互交织着，有时合作，有时对立。 世界观：艾尔维尔是由众多神灵创造而成的，其中最重要的是光明神阿拉迪尔（Aladil）和黑暗神阿尔贝罗斯（Albeross）。他们在宇宙的起源之初，一同创造了艾尔维尔，但由于意见分歧，导致两者分裂，形成了光明与黑暗的对立。 在这个世界中，存在着许多古老的传说和神秘的力量，比如传说中的“梦幻岛”，据说是位于大陆尽头的一个神秘之地，拥有无尽的宝藏和魔法力量。但这个岛只有在特定的时刻才会显现在现实世界中，而且只有拥有特定魔法道具的人才能找到它。 魔法系统：魔法是普遍存在的，但它并非轻易可得，只有经过长期的学习和修行才能掌握。魔法被分为不同的领域，包括元素魔法、神秘魔法、精灵魔法等等。每种魔法都有其自身的规则和限制，需要使用者付出一定的代价。 七大魔法神器道具的背景： 这些道具都是古老的传说之物，据说是由众多神灵和传奇英雄所创造或发现的。它们蕴含着神秘的力量，可以改变世界的命运。但这些道具散落在艾尔维尔各个角落，需要勇敢的冒险者去寻找和解开它们的秘密。 艾米莉亚和波波就是这样的冒险者，他们在艾尔维尔的大陆上展开了一场奇幻而充满挑战的冒险之旅，希望能够找到这些道具，解开“梦幻岛”的秘密，以及揭示世界背后的神秘力量。 ### 艾米莉亚人物小传： 艾米莉亚是一个居住在奇幻小镇艾尔维尔的年轻女巫，她对魔法和奇幻世界充满了无限的向往和好奇。 她是个有点贪心的女孩，总是对珍贵的魔法宝物和宝石情有独钟。 虽然她心存贪念，但她并不是个坏人，她只是有着自己的小毛病。 有一天，艾米莉亚在一本古老的魔法书中发现了一种特殊的咒语，据说可以召唤出一只拥有特殊能力的魔法兔子。 她对这个咒语充满了好奇，于是决定念出咒语，看看会发生什么事情。 当波波出现在她面前时，她吓了一跳。 这只大灰兔说自己叫波波，这只兔子不仅会说话，而且拥有一种与众不同的魔法感应力。 波波能够嗅出隐藏在世界各处的几件传说级魔法道具，就像一只能嗅出宝藏的猎犬一样。 艾米莉亚之所以想召唤这只兔子，是因为她希望能够借助波波的力量，找到更多的宝物和魔法知识，以满足她对财富和魔法的渴望。 她并没有什么高尚的理想，她只是想要成为一个更强大的女巫，探索世界的魔法，拥有更多的珍贵的魔法宝物和财宝。 艾米莉亚有些贪财，但她的心中更多的拥有一份对魔法的热爱和对世界的向往。 她希望未来可以通过借助波波的力量和自己的魔法，探索更多世界的秘密，成为一个更加强大。。和更加有钱的女巫。 ### 波塔米尔小传： 波塔米尔原本是一位来自遥远国度的魔法师，名叫波塔米尔，他来自一个叫做阿斯特瑞亚的国家。 在阿斯特瑞亚，波塔米尔是个颇受尊敬的人物，他拥有着高超的魔法技艺。 然而，他内心却隐藏着一个不为人知的秘密。 波塔米尔曾经历过一场毁灭性的战争，这场战争夺走了他所珍视的一切，包括他的家人和朋友。 这场战争令他对人性和世界产生了巨大的怀疑，他渴望着更大的力量和地位，以便能够在世界上获得自己的地位。 某次，他听闻了一个关于梦幻岛的传说，据说那里隐藏着无数宝藏和一件传说中的魔法珍宝。 波塔米尔渴望获取这些宝藏，不仅是为了获得更大的权力，更是为了消除战争。 他想要利用自己的力量和强力的统治，以及几件集齐后就足以毁灭世界的传说中的魔法道具，把世界所有的政治、军事力量都掌握在自己手中，以此来迫使各国停止战争。 他设想成立一个全球性的专制政权，通过镇压任何反对派和异议声音，来维持世界上的“和平”。 他会利用自己的魔法能力，胁迫、操纵甚至控制世界各国的领导人和政府，让他们服从他的意志。 他会利用魔法来创造一种强大的威慑力量，威胁那些不遵从他的国家，让他们知道不听从他的命令将会面临可怕的后果。 他为了这个目标，开始搜寻这几件传说中的魔法道具。 当波塔米尔踏上梦幻岛时，他被这片充满魔法力量的土地所迷惑，试图利用自己的魔法感应能力寻找宝藏，但却用尽方法也找不到。 失落和沮丧的波塔米尔感到无比愤怒，他开始在这里用充满破坏力的魔法，试图用暴力翻遍整个岛找出这些宝藏。 梦幻岛一直以来沉睡着一位古老的神明，他虽然沉睡，但力量强大到依旧保护着这片土地和传说中的某件魔法道具。 这位神明感应到了波塔米尔的暴力，或许是为了阻止他，将他变成了一只胖胖的大灰兔。 神明似乎抱有某种目的所以才留住了他的性命，并且期待未来某个拥有特殊力量的人，通过召唤的方式召唤走波塔米尔，这个人就是艾米莉亚。 关于他的名字，波波，是源自于他从前的魔法名字波塔米尔的缩写，也是他失去了魔法身份后保留下来的唯一记忆。 他只记得自己叫波波。 他能感应到某些东西，某些他之前在寻找的东西——就是传说中的魔法道具，他不记得具体是在寻找什么了，对于过去的一切忘得一干二净了。 不知道自己原本是人类，不知道如何恢复原型。 奥利弗小传（啰嗦版）：奥利弗来自诺维亚王国，一个以骑士精神和荣耀为中心的国家。 他的家族自古以来都是诺维亚王国的忠实骑士，代代相传，为国家效力。 在这个家族中长大，奥利弗接受了严格的武术和骑士道训练，被灌输着对国王和王国的忠诚和责任。 然而，尽管奥利弗在国家布置的各种任务中表现出色，但他内心却逐渐被矛盾和挣扎所困扰。他原本认为，为了保护多数人的利益，即使需要牺牲少数人的生命也是必要的。 因此，当国家下达的任务会要求伤害平民时，他都能够执行得很完美。 然而，一次意外的事件彻底改变了他的想法。 某次事件中，国王为了维护王室的尊严，下令屠杀某个边境小镇所有无辜的平民。 这件事开始让奥利弗感到迷茫。他渴望成为一名真正的勇士，而不仅仅是因为从小受到的骑士精神教育，就对所有王室和家族下达的一切不合理的命令言听计从。 他开始质疑家族和王室的绝对正确性，但又无法容忍自己对王室权威产生质疑，虽然内心开始产生迷茫，却逼迫自己依旧服从命令。 后来，奥利弗遇到了艾米莉亚和波波，他们最初是敌对的。 诺维亚王国拥有一件艾米莉亚和波波一直在寻找的七大传说级魔法道具之一。 国王不知道这件魔法道具在哪里，只有波波可以感应到。 因为国王想要这件道具，于是奥利弗被派遣去暗中观察艾米莉亚和波波，当艾米莉亚和波波找到道具时，夺取道具并杀掉他们。 然而，奥利弗发现了国王要这件道具是为了发动无谓的战争，无数平民会因此失去性命。他又一次开始迷茫面对家族的阻挠，不得不做出选择，他选择为了平民对抗王室。 这次决定是他开始寻找真正的勇气和自由的转折点。 后来艾米莉亚和波波成功找到并带走了这件魔法道具，奥利弗没有让国王的阴谋得逞，可他因为违背命令背叛王室，结果被家族驱逐。 接着，奥利弗选择和艾米莉亚和波波一起旅行，奥利弗加入的理由，一是因为他需要思考以往自己的价值观，寻找真正的自我，二是因为艾米莉亚和波波寻找七大传说中魔法道具这种事情，对世界可能造成威胁。 以他的观念无法坐视不理，所以他选择强硬的加入艾米莉亚和波波一行人，想观察他们是否具有潜在的危险性。 艾米莉亚和波波此时无法摆脱他，只能被动的接受他加入。 同时艾米莉亚和波波也想，由于这次寻找魔法道具的行动，波波被暴露给全世界知道自己是唯一可以感应到七大魔法神器的生物。 全世界的国家都在觊觎这些魔法神器。 因此在他们未来的旅途中，波波很可能会陷入危险。 而奥利弗身为世界大国之一的诺维亚王国的原高阶骑士，对诺维亚王国的内部事务应当有相当程度的了解。 艾米莉亚和波波希望通过奥利弗的视角，了解王室高层的动向，推测这些大国可能会采取的行动，思考今后潜在的危险，以及今后的冒险旅程及方向。 同时，奥利弗的骑士身份和战斗能力为主角团带来了重要的支援。他在战斗中表现出色，能够为团队提供强大的保护和战斗力。 这使得主角团对他的加入更加欢迎。 然而，随着时间的推移，奥利弗在主角团中的地位逐渐发生变化。 他的真诚和勇气开始感染其他成员，大家逐渐建立了深厚的信任和友谊。 在一次冒险中，奥利弗为了拯救伙伴们不惜牺牲自己，展现了无私的勇气和牺牲精神。这个事件成为了契机，让主角团彻底接受了奥利弗，将他视为平等的伙伴。 奥利弗的加入不仅为主角团带来了情报和战斗力，更重要的是，他成为了团队的核心成员之一，与他们共同面对挑战，共同追求梦想。 这种相互依赖和信任的关系，使得他们的冒险之旅更加完整和充实。 奥利弗小传：奥利弗来自诺维亚王国，一个以骑士精神和荣耀为中心的国家。他的家族自古以来都是诺维亚王国的忠实骑士，代代相传，为国家效力。在这个家族中长大，奥利弗接受了严格的武术和骑士道训练，对国王和王国的忠诚和责任被灌输得很深。 然而，尽管奥利弗在国家布置的各种任务中表现出色，但他内心逐渐被矛盾和挣扎所困扰。他原本认为，为了保护多数人的利益，即使需要牺牲少数人的生命也是必要的。然而，一次意外的事件彻底改变了他的想法。 米兰多尔（Milandor）事件中，国王为了维护王室的尊严，下令屠杀某个边境小镇所有无辜的平民，让奥利弗开始质疑王室的决策。他开始迷茫，渴望成为一名真正的勇士，而不仅仅是因为从小受到的骑士精神教育，对所有王室和家族下达的不合理命令言听计从。 几年后，奥利弗遇到了来这里的艾米莉亚和波波，他们最初是敌对的。诺维亚王国拥有一件艾米莉亚和波波一直在寻找的七大传说级魔法道具之一。国王不知道这件魔法道具在哪里，只有波波可以感应到。于是，奥利弗被派遣去暗中观察艾米莉亚和波波，并在艾米莉亚和波波找到道具时，夺取道具并杀掉他们。 然而，奥利弗发现了国王要这件道具是为了发动无谓的战争，无数平民会因此失去性命。他因此选择背叛王室，为了平民对抗王室。这次决定是他开始寻找真正的勇气和自由的转折点。 后来艾米莉亚和波波成功找到并带走了这件魔法道具，奥利弗因违背命令而被家族驱逐。 接着，奥利弗选择和艾米莉亚和波波一起旅行。他加入的理由一是因为他需要思考以往的价值观，寻找真正的自我，二是因为艾米莉亚和波波寻找七大传说中魔法道具的行动，可能对世界造成威胁，他无法坐视不理。艾米莉亚和波波此时无法摆脱他，只能被动接受他的加入。 同时，艾米莉亚和波波也希望通过奥利弗的视角，了解王室高层的动向，推测这些大国可能会采取的行动，思考今后的潜在危险以及冒险旅程的方向。 奥利弗的骑士身份和战斗能力为主角团带来了重要的支援。他在战斗中表现出色，为团队提供强大的保护和战斗力。这使得主角团对他的加入更加欢迎。 随着时间的推移，奥利弗在主角团中的地位逐渐发生变化。他的真诚和勇气开始感染其他成员，大家建立了深厚的信任和友谊。在一次冒险中，奥利弗为了拯救伙伴们不惜牺牲自己，展现了无私的勇气和牺牲精神。这个事件成为了契机，让主角团彻底接受了奥利弗，将他视为平等的伙伴。 奥利弗的加入不仅为主角团带来了情报和战斗力，更重要的是，他成为了团队的核心成员之一，与他们共同面对挑战，共同追求梦想。这种相互依赖和信任的关系，使得他们的冒险之旅更加完整和充实。 关于米兰多尔（Milandor）事件米兰多尔（Milandor）位于国王统治区边缘，是一个多民族聚居地，有着来自不同国家的居民。镇长的明智领导使得这里成为了大陆上和平共处的典范，尽管居民来自不同的文化和背景，他们和睦相处，共同维护着这片地区的和平。 这个小镇地理位置非常重要，连接着国王统治区和周边国家的主要通道。掌握了这个小镇就意味着掌握了边境的控制权，能够有效地监视边境的动向并防范外部威胁。 二王子渴望扩大自己的势力范围，并希望能够掌握这个关键地带的控制权。他想利用这个小镇作为自己的基地，以便将来在政治和军事上有更多的影响力。 因此，他向米兰多尔的镇长施加压力，要求提供大量的食物和贵重资源给他私人，以支持他的野心。 镇长拒绝了他的要求，认为这是对小镇居民的不公平剥削，并且违背了国王对各地领地的规定。 为了实现他的目标，二王子决定利用一切手段对付小镇，他编造谎言指控小镇外来居民对本国人不友好，策划袭击并杀害了几名本国人。他企图通过这种手段为自己的无理要求找借口，并将镇长定为叛国罪犯，以此来达到掌握边境地带控制权的目的。 镇长平时对居民十分友好周到，因此当镇长被冤枉抓走后，他们集合了一些青壮年在首都发动了抗议游行，希望国王能够了解他们的处境。 镇压的场面被首都的平民看到了，质疑二王子是否真的诬陷了米兰多尔的居民们。 事情传到了国王耳朵里，国王知道了二王子的野心，然而不愿意承认二王子的错误。 他认为镇民的游行是对王国尊严的威胁，为了维护王室的尊严，他下令逮捕并处死所有参与者，并派人去屠杀小镇的所有外来人。 他认为，包庇二王子是为了维护国家的尊严，不让王室的丑闻外扬。 奥利弗和他的队伍被派遣前往这个小镇，执行国王的命令。奥利弗领着他的队伍，对所有居民进行了围剿。 然而，在屠杀过程中，奥利弗发觉这些人并不像所谓的“暴徒”，他意识到了事情的真相并不是国王所描述的那样，这里根本没有暴徒。他们只是用游行表示二王子诬陷他们的不满，却反过来被国王诬陷他们叛国。 他一开始以为国王是被人蒙蔽，于是暂时停止屠杀，选择告诉国王他的疑虑，当他报告完后，发现国王对这一切并不疑惑，才得知国王一开始就清楚这些平民是被冤枉的，甚至就是国王本人下达诬陷的指令。 国王依旧强制要求奥利弗执行屠杀命令，奥利弗的从小受到的骑士精神教育不允许他违背命令，虽然不想服从，但命令在前，只好继续屠杀。许多本国人不幸被卷入了事件，他们在试图逃生的过程中成了牺牲品。妇女和儿童在混乱都不能幸免，无辜的平民被误伤被杀害。 这血腥的一幕让奥利弗心如刀割，他意识到国王的命令并非总是符合正义，他开始质疑自己的行为。这场血腥事件让他开始思考自己对国家和王室的忠诚，以及他在这个世界中的位置和责任。 关于米兰多尔（Milandor）事件（精简版）米兰多尔是一个和平共处的多民族聚居地，居民来自不同国家，却和睦相处，这得益于镇长的明智领导。 这个小镇地理位置非常重要，连接了国王统治区和周边国家的主要通道，拥有了这个小镇，就掌握了边境的控制权。 二王子希望扩大自己的势力范围，以米兰多尔作为基地。他向镇长施加压力，要求提供大量食物和贵重资源。镇长拒绝了他的要求，认为这是不公平的剥削。 二王子决定利用一切手段对付小镇，他编造了关于外来居民的谎言，企图将镇长定为叛国罪犯，以此达到掌控边境的目的。 当镇长被冤枉抓走后，居民发起了抗议，但被国王下令镇压，导致了无辜居民的死亡。 奥利弗和他的队伍被派去执行国王的命令，他们对居民进行了围剿。但奥利弗发现事实并非国王所说，居民只是表达不满，却被国王诬陷为叛国。 奥利弗质疑了国王的命令，但最终被迫继续屠杀。这一幕让他开始反思自己对国家和王室的忠诚，以及自己在这个世界中的责任。 世界背景和世界观：在阿尔达尼亚大陆上，存在着一个神秘而辽阔的奇幻世界，这片大陆上拥有七大洲，分布着各种各样的地域和生物。这个世界被一片茂密的森林所覆盖，其中隐藏着无数的奇迹和危险。 诺玛尼亚洲：这是一个古老而神秘的洲，位于大陆的西北部。这里有着广袤的荒原和雄伟的山脉，是兽人和巨人族的栖息地。 埃尔芬达洲：位于大陆的东南部，这片洲是精灵和妖精的领地。这里有着迷人的森林和湖泊，以及精灵族的古老城堡和神秘之地。 多米尼亚洲：这是一个拥有丰富魔法资源的洲，位于大陆的中部。这里有着茂密的森林和广阔的草原，是人类和矮人族的主要聚集地。 卡尔蒙德洲：这片洲位于大陆的西南部，是龙族的领地。这里有着火山和峡谷，以及龙族的古老神庙和宝藏。 希望之地洲：位于大陆的东北部，这片洲是一个神秘而充满活力的地方。这里有着繁华的城市和蓬勃发展的文化，是各种种族和文化的交汇地。 暗影岛洲：这个洲位于大陆的西部，被一片永恒的暗影所笼罩。这里是黑暗生物和不死族的栖息地，充满了恐惧和死亡的气息。 神秘之地洲：这片洲位于大陆的南部，被一片神秘的云雾所覆盖。这里是各种传说生物和神秘遗迹的所在地，隐藏着无数的宝藏和秘密。 在这片神秘的大陆上，散落着七件传说中的魔法道具，它们分布在各种遗迹和危险之中，代表着不同种族和文化的智慧与力量。 艾米莉亚和她的伙伴们将穿越整个阿尔达尼亚大陆，前往这些地区寻找这些传说级魔法道具，面对各种挑战和危险，揭开这些道具背后的神秘秘密。 在阿尔达尼亚大陆上，人类是最为广泛分布和生活的种族之一，他们在各个洲都有着自己的聚居地和王国。以下是一些主要的人类王国： 诺维亚王国：位于诺玛尼亚洲西北部的诺维亚王国是人类的重要王国之一，以其勇敢的骑士和强大的军队而闻名。这个王国的首都是圣光城，是一座充满了骑士精神和传统文化的城市。 埃尔辛帝国：位于多米尼亚洲的东部，埃尔辛帝国是一个庞大而强大的人类帝国，以其强大的魔法力量和先进的科技而著称。这个帝国的首都是玛格达城，是一个繁华而充满生机的城市。 卡拉米尔王国：位于埃尔芬达洲的东北部，卡拉米尔王国是一个以冒险者和商人为主的王国，以其丰富的贸易和冒险精神而闻名。这个王国的首都是港湾城，是一个国际性的贸易中心。 阿斯加德王国：位于多米尼亚洲的西南部，阿斯加德王国是一个以战士和探险家为主的王国，以其勇敢和荣耀而闻名。这个王国的首都是勇士之城，是一个充满英雄传说和历史遗迹的城市。 莱文多王国：位于希望之地洲的中部，莱文多王国是一个以自然和艺术为主的王国，以其美丽的自然风景和独特的文化而闻名。这个王国的首都是艺术之都，是一个充满艺术气息和文化活动的城市。 巴拉多王国：位于希望之地洲的北部，巴拉多王国是一个以智慧和学问为主的王国，以其丰富的知识和学术传统而闻名。这个王国的首都是学者之城，是一个充满学问和智慧的城市。 阿兰西亚王国：位于神秘之地洲的东部，阿兰西亚王国是一个以神秘和神秘主义为主的王国，以其神秘的遗迹和仪式而闻名。这个王国的首都是神秘之城，是一个充满神秘气息和宗教仪式的城市。 塔尔米斯共和国：位于埃尔芬达洲的中南部，塔尔米斯共和国是一个以商业和文化为主的共和国，以其繁荣的港口和多元化的文化而闻名。这个共和国由一系列自由城邦组成，首都是自由港，是一个自由和开放的城市。 布兰德尔联邦：位于多米尼亚洲的北部，布兰德尔联邦是一个以农业和手工业为主的联邦国家，以其丰富的农产品和工艺品而闻名。这个联邦的首都是绿谷城，是一个绿树成荫的城市。 艾斯蒂亚王国：位于诺玛尼亚洲的南部，艾斯蒂亚王国是一个以骑士精神和宗教信仰为主的王国，以其圣洁的神殿和英勇的骑士而闻名。这个王国的首都是圣光城，是一个充满敬畏和神圣气息的城市。 伊斯坦王国：位于埃尔芬达洲的东部，伊斯坦王国是一个以贸易和海洋为主的王国，以其繁华的海港和多元化的文化而闻名。这个王国的首都是海港城，是一个国际性的贸易中心。 卡斯蒂亚帝国：位于神秘之地洲的中部，卡斯蒂亚帝国是一个以神秘主义和战争为主的帝国，以其强大的魔法力量和精锐的军队而闻名。这个帝国的首都是帝国城，是一个充满权力和神秘的城市。 洛克达尼亚王国：位于希望之地洲的西部，洛克达尼亚王国是一个以勇气和冒险为主的王国，以其英雄传说和壮丽风景而闻名。这个王国的首都是勇士之城，是一个充满历史和传奇的城市。 德拉科尼亚公国：位于多米尼亚洲的西部，德拉科尼亚公国是一个以魔法和龙族为主的公国，以其强大的魔法和神秘的龙族而闻名。这个公国的首都是龙之城，是一个充满魔法和神秘的城市。 主角团是来自不同国家和地区的冒险者，他们的目标是寻找传说中的七件魔法道具，并解开这些道具背后的神秘。他们之间的关系建立在对冒险和探索的共同兴趣上，每个人都有着自己的动机和目标，但都被各自的渴望驱使着前进。 艾米莉亚：作为故事的主角之一，艾米莉亚是一个年轻的女巫，对魔法和奇幻世界充满好奇和向往。她希望通过寻找魔法道具来提升自己的魔法能力，成为一个更加强大的女巫，并满足自己对财富和奇迹的渴望。 波波：这只大灰兔是艾米莉亚召唤出来的魔法伙伴，拥有着独特的魔法感应力。他加入了艾米莉亚的冒险队伍，帮助她找到隐藏在世界各处的魔法道具，但他自己也有着一些神秘的过去和目标。 奥利弗：作为一名勇敢的骑士，奥利弗加入了艾米莉亚的冒险队伍，他希望通过这次冒险来证明自己的勇气和价值，同时也寻找属于他自己的荣耀和奖赏。 莉莉：作为一名可爱的精灵，莉莉加入了艾米莉亚的冒险队伍，她希望通过这次冒险来探索世界，了解更多关于人类和其他种族的文化和生活。 乔治：作为一名滑稽的巨人，乔治加入了艾米莉亚的冒险队伍，他希望通过这次冒险来寻找属于他自己的地位和尊严，同时也寻找与其他种族和平共处的可能性。 这些角色之间的关系错综复杂，每个人都有着自己的动机和目标，但他们共同面对的挑战和冒险将使他们彼此之间建立起深厚的友谊和信任。在这个充满魔法和奇迹的世界中，主角团将共同经历许多惊险刺激的冒险，解开世界的秘密，最终实现各自的愿望和目标。"},{"title":"【webpack】自动化修改已经打包好的代码","date":"2023-05-09T08:42:28.000Z","url":"/2023/05/09/webpackdbh/","tags":[["node","/tags/node/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"今天有一个项目，对接时看 readme 里写 打包出来的 vendor 有存在 cookie，目前还没有查清楚引用的哪个包导致的。只能打包完成后手工删除一下 Cookie 相关的信息。 每次都需要修改已经打包好的代码，感觉很麻烦，就写了个小脚本replace.js 使用 Node.js 中的 fs 模块和正则表达式实现文件内容的替换 打包后，使用node replace.js测试成功。 不嫌麻烦的话打包完后手动node replace.js就行了。 嫌麻烦的话。。。 于是下一步加入到 webpack 构建中，每次打包后自动执行脚本： 加入到自动构建步骤 在 webpack 配置文件中引入 Node.js 的 child_process 模块： plugins 中加入 简单解释：我定义了一个名为 ReplacePlugin 的 webpack 插件。插件是一个类，它包含一个名为 apply 的方法。这个方法接受一个 compiler 对象作为参数，用于访问 webpack 编译器的 API。 在 apply 方法中，我使用 compiler.hooks.done.tap 方法注册了一个回调函数。这个回调函数会在 webpack 编译完成后执行。 回调函数中使用了 execSync 函数来执行 node replace.js 命令。也就是说在 webpack 编译完成后，会运行名为 replace.js 的 Node.js 脚本。 关于child_process模块child_process 是 Node.js 的一个内置模块，它提供了一组用于创建和管理子进程的 API。子进程是由另一个进程（在这种情况下是 Node.js 进程）创建的进程。 execSync 函数是从 child_process 模块中导入的。因此这个函数可以用来同步地执行一个 shell 命令，并返回命令的输出。 注：它会阻塞 Node.js 事件循环，直到子进程退出。 关于applyapply 是一个方法，它是 webpack 插件的一个重要组成部分。当你在 webpack 配置中注册一个插件时，webpack 会自动调用插件的 apply 方法。 apply 方法接受一个 compiler 对象作为参数。compiler 对象代表了 webpack 编译器，它提供了一组 API，允许插件在编译过程中的不同阶段执行自定义操作。 我这里的 apply 方法使用了 compiler.hooks.done.tap 方法来注册一个回调函数。这个回调函数会在 webpack 编译完成后执行。也就是说，插件通过 apply 方法向 webpack 编译器注册了一个钩子函数，用于在编译完成后执行自定义操作。 完成以上配置后，每次打包就会自动完成。 vue3 以上版本：本来其实是想在vue.config.js 中添加一个 configureWebpack 钩子，在其中使用 webpack-plugin-replace 插件进行替换。比这种写脚本方法简单多了。 不过这个方法仅适用于 vue3 以上版本，而上面的方法适用于任何版本。 首先，需要在项目中安装 webpack-plugin-replace： 然后，在 vue.config.js 中加入以下代码： 其中，include 配置了需要进行替换的文件夹路径，values 则配置了需要替换的字符串和对应的替换值。在执行 yarn run build 后，这些字符串将会被替换掉。 需要注意的是，vue.config.js 中的配置是在构建时读取的，因此如果想要修改这些配置，需要重新运行 yarn run build 才能生效。 完成。"},{"title":"【反向代理】webpack-dev-server反向代理的原理及简介","date":"2023-05-08T06:21:19.000Z","url":"/2023/05/08/fxdl/","tags":[["webpack","/tags/webpack/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"在 Web 开发中，由于浏览器的安全机制限制，同源策略（Same-Origin Policy）会阻止来自不同源（协议、域名、端口）的 Web 应用程序之间的访问。这意味着如果你的 Web 应用程序试图从一个不同的域名请求数据，将会收到一个跨域请求错误。 在本地开发时，由于 api 从测试环境提供，而本地的域名为 localhost，会导致跨域。此时可以使用 webpack-dev-server 的反向代理功能去设置。 1. 什么是 webpack-dev-serverwebpack-dev-server是一个开发环境下的服务器，它能够为我们提供一个本地的开发环境，实时重新加载页面，并且能够支持各种类型的静态资源。它内置了 webpack 编译器，可以自动编译项目代码并在浏览器中实时展示。 2. 什么是反向代理在开发环境中，我们可能需要从本地访问远程的服务器接口，但是由于跨域的限制，我们无法直接访问远程服务器。这时候就需要借助反向代理服务器来实现。反向代理服务器可以在本地开启一个代理服务，将本地请求转发到远程服务器，从而解决跨域问题。 3. webpack-dev-server 实现反向代理的原理webpack-dev-server 内置了 express 服务器，并且支持配置代理服务器。通过配置代理服务器，我们可以将本地的请求转发到远程服务器。具体的实现原理如下： 在webpack.config.js中配置代理服务器相关的选项，比如proxy、before、after等。 在启动 webpack-dev-server 时，会自动启动一个 express 服务器，并监听开发服务器的端口。 当我们在浏览器中发起请求时，express 服务器会拦截请求，并判断该请求是否满足代理规则。 如果请求满足代理规则，express 服务器会将该请求转发到代理服务器。 代理服务器会将请求发送到远程服务器，并将响应返回给 express 服务器。 express 服务器收到远程服务器的响应后，将响应返回给浏览器。 4. 如何配置 webpack-dev-server 反向代理在webpack.config.js文件中，我们可以通过devServer.proxy选项来配置反向代理服务器，其常见配置如下： 上述配置的含义是：将以/api开头的请求转发到服务器上，并且去掉/api前缀。 其中，target选项表示需要转发的远程服务器地址，pathRewrite选项用于重写请求路径。 5. 使用案例假设我们有一个 Vue.js 项目，需要通过反向代理来访问后端 API。后端 API 的地址为 。 首先，我们需要安装 webpack-dev-server 和 http-proxy-middleware： 接下来，在 vue.config.js 中添加以下配置： 这个配置的意思是：所有以 /api 开头的请求都会被代理到 ，并且会在请求头中加上 Origin: ，以模拟跨域请求。changeOrigin 选项表示是否改变请求头中的 Origin 字段，设为 true 可以解决一些跨域问题。pathRewrite 选项表示将请求路径中的 /api 替换为空，以便后端接收请求时不会包含 /api。 然后在前端代码中，我们可以这样来访问 API： 这样，axios 库会将请求发送到 ，webpack-dev-server 会将这个请求转发到 ，最终将后端 API 的响应返回给前端。 需要注意的是，由于是通过代理服务器来访问后端 API，所以我们无法直接在浏览器中访问 ，必须通过代理服务器来访问。在开发环境下，我们可以使用 webpack-dev-server 提供的 /webpack-dev-server/ 页面来访问代理服务器的相关信息。"},{"title":"【构成】色彩构成（未完）","date":"2023-05-06T02:40:09.000Z","url":"/2023/05/06/scgc/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"跟着书过，不知道看多久 一、色彩构成的情感表达第一节：色彩的总结1. 红色：热情、爱、力量、勇气、危险、愤怒、血液、情欲、诱惑、紧张等情感。 2. 黄色：明朗、喜悦、阳光、警告 3. 橙色：活力、温暖、食欲 4. 绿色：生命、希望、健康 5. 蓝色：清爽、理性、智慧、镇定 6. 紫色：浪漫、神秘、幻想、富有 7. 粉红色：温柔、甜蜜、浪漫、女性化、童话、浪漫、无邪 8. 白色：纯洁、无辜、宁静、明亮、简约、无私 9. 黑色：神秘、力量、庄严、悲伤、死亡、恶意、保守、冷酷 10. 灰色：高雅、含蓄、内敛、中性 11. 金银色：奢华、富丽 第二节：色彩的通感1. 色彩的软硬感色彩的软硬感是色彩与视觉共同形成的软硬感觉作用于人的心理结果。明度是影响色彩软硬感的关键因素。 明度高，色彩感觉偏软。明度低吖色彩感觉偏硬。 色彩的软硬度还与纯度有关。 高纯度的色彩有坚硬的感觉，低纯度的色彩有柔软感。 2. 色彩的轻重感色彩的轻重感与明度纯度和透明度有关系。 明度与纯度： 明度纯度都高的颜色，给人以轻柔感。 明度纯度都低的颜色，给人以重量感。 色相： 暖色给人以轻的感觉，冷色给人以重的感觉。 色彩的位置接近作品上方时，可以强调轻盈感，处于下方则可以强调厚重的感觉。 （当色彩的位置接近作品的上方时，可以营造出轻盈、明亮的感觉，这是因为人们习惯将天空与轻盈、明亮的氛围联系在一起。反之，当色彩的位置接近作品的下方时，会强调厚重、稳重的感觉，因为人们将大地与厚重、稳定的感觉联系在一起。） 透明度： 透明度高给人以轻盈的印象。 透明度低给人以沉重的印象。 3. 色彩的绚丽感和质朴感使用色相丰富的高纯度、高明度的色彩，就会给人绚丽的感觉。 使用色相单一的低纯度、低明度的色彩，就会给人质朴的感觉。 4. 色彩的兴奋感与沉静感色彩的兴奋感与沉静感与色相的联系紧密。 红、橙、黄给人以兴奋感。 蓝、蓝绿、蓝紫则给人以沉静感。 一般来说，暖色比冷色更容易引起人的兴奋感。 有一些规律，我总是记记不住就忘了，写在这里 光色混合有色光照在物体上，会发生光色混合。若光的饱和度更高，则最终色相向光色方向偏移。若物体的饱和度更高，则最终色相向物体的固有色方向偏移。白色光照在物体上，色相会发生偏移。物体固有色靠近青品黄哪个颜色近，亮部就向像青品黄哪个颜色偏移。暗部则像红绿蓝偏移。物体的饱和度越高，越不容易受到光的影响，物体饱和度足够高的话，光很难影响物体。 光和物体固有色的关系60内饱和度明显提升，亮度和光有关，提升有弱有强（比如同饱和度蓝光的亮度比青光暗）60-90度饱和度提升，但提升缓慢。90-120度开始渐渐灰一点，超过120之后，越接近180，光肉眼可见的越弱，饱和度越低。光的强度分为本身的强度和饱和度的强度。明度高的物体，容易受光色的影响 光和暗部的关系 暗部一般不受主光圆的影响，但受环境光（比如反光，比如天光）的影响。然后可以根据环境光，结合上述所说的第二点去分析暗部，环境光一般不会有主光源那么强。 光的强度分为本身的强度（明度）和饱和度的强度。明度高的物体，容易受光色的影响。 物体受到光照，但被光照影响的最弱的地方饱和度最高 接近明暗交界线的地方会感觉饱和度突然提高。 反射光因为弱，所以照在物体身上，可以很好的体现物体本身的固有色。 物体固有色与周围环境色为同色系时，光色混合，饱和度适当增加弱固有色与环境色为对比色时，饱和度降低。 分析图片的步骤：先分析直射光，再分析天光（环境光），再分析反射光 冷色降低饱和度，颜色变暖，暖色降低饱和度，颜色变冷 颜色的冷暖在彩色系中：把橙色称为暖级，把蓝色称为冷极。在无彩色系中：把白色称为冷极，把黑色称为暖极。暖色加白变冷；冷色加白变暖。另一方面，纯度越高，冷暖感 颜色对画面的影响环境色 &gt; 光源色 &gt; 固有色 空间关系可以使用冷暖来表示，也可以使用饱和度来表示在空间关系中，向后的物体饱和度会下降。 明度对比、饱和度对比、冷暖对比、透视变化，用这些去塑造空间的关系。饱和度：一般的塑造中，近处颜色偏暖、纯度高；对比强的色彩感觉距离近；偏冷含灰、对比弱的色彩感觉距离远。但不是绝对的，可以根据自己塑造的物体去调整饱和度。 反光的光色由反射面的固有色决定。反光的色光色相与物体固有色色环角度大于120，则反光部分变灰，稍微变亮，饱和度降低，因为反射色光被物体表面大量吸收反光的色光色相与物体固有色色环角度大于60小于120，则反光部分变亮变灰，饱和度降低，因为反射色光被物体表面混合后反射反光的色光色相与物体固有色色环角度小于60，则反光部分变亮，饱和度提高。 色相明度提高，他们的素描灰度值会变得难以区分，所以不容易画错 冷暖交替：冷光下，亮部冷，暗部暖，反光冷，投影暖 色彩和素描一样要记住转折面，只要有转折颜色就有变化。转折越强烈明暗变化越强烈，亮 - 青品黄 暗 - 红绿蓝变化 颜色会互相影响，背景会影响物体，物体也会影响物体 亮部很亮，曝光过度，重点就在暗部。亮部曝光合适，重点在亮部，暗部要简略的刻画 一开始绘画要找色彩与色彩之间的联系，不要去纠结形 在做色彩练习的时候，可以试试：色相偏移：整体色相偏移、局部色相偏移（只偏移亮部或只偏移暗部）色相抖动：整体色相抖动、局部色相偏移（只偏移亮部或只偏移暗部） ———————————————————————————————— 红色里面想混一些绿色，我可以在原先色相的基础上，像绿色的方向偏移，然后降低颜色饱和度，降低明度（or升高一点点，看混合的颜色是什么样的，比如说如果是柠檬黄，那肯定是亮一点，如果是比红要暗的黄，那肯定是暗一点。就和纸上调色一个道理）最主要是降低饱和度，色相偏移，就可以混色。 但我想不通的是，因为电脑调色是rgb吖，光与光混合怎么会变暗呢？？颜料与颜料混合是可能变暗的，光与光按理说一定会亮吖。 亮部 — 光色、固有色混合（光越强，固有色越不明显）;灰部 — 固有色 ;暗部 — 环境色、反光色混合固有色。 次表面散射：在半透光的物体上体现的很明显。比如说人体皮肤。越接近明暗交界线，饱和度越高，直到完全坠入暗部。 光色衰减：光的距离越远，光越暗。比例呈抛物线变化，而不是正比。当然，光色也会这么变化，所以在色板上也是这么变化。 光色衰减2：光的距离变远时，色相会偏移。距离青品黄谁更近，就往谁偏移。比如红色，离黄近的红就往黄偏移，离品红近的红就往红偏移。 光色衰减3：曝光超严重的时候，最亮的是白色 光色衰减4：从光近到光远的变化是这样的：饱和度低 — 饱和度高；明度高 — 明度低；色相向红绿蓝变化 一般来说，由于空气透视的原因，近处物体的饱和度高，远处饱和度低，在同一个物体上也可以如此表示。 亮 – 暗 色相会偏移。在有结构的转折上，色相也会偏移。 暗部反光的颜色，受固有色、环境光及天光影响。但不是说整个部位都是受同等影响，比如说，根据位置不同，会受不同程度的环境光及天光影响。有些地方受天光影响大，有些地方受环境光影响大，中间部位会受天光及环境光的混合光色影响。由于反光一般是很弱的，所以影响也不是很大。 "},{"title":"【网页】六位颜色和八位颜色的区别","date":"2023-04-23T03:34:11.000Z","url":"/2023/04/23/lwys/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["undefined",""]],"content":"在定义颜色的时候，#ffffff 和 #ffffffff 都是十六进制的表示方式，表示的是 RGB 或 RGBA 颜色模式下的颜色值。 #ffffff 表示的是 RGB 颜色模式下的白色，其中每两个相同的字符表示一个颜色通道的数值，即 #RRGGBB，其中 RR 表示红色通道的数值，GG 表示绿色通道的数值，BB 表示蓝色通道的数值。每个通道的数值都是一个 0-255 之间的十进制数。 #ffffffff 则表示的是 RGBA 颜色模式下的白色，其中除了 RGB 部分的颜色通道数值以外，还有一个表示透明度的通道数值，即 #RRGGBBAA，其中 AA 表示透明度的数值，数值范围也是 0-255 的十进制数。 八位的颜色表示方式则是指用一个 32 位的无符号整数来表示颜色，其中最高的 8 位表示透明度通道的数值，接下来每 8 位表示一个颜色通道的数值，即 AA RR GG BB，每个通道的数值也是一个 0-255 之间的十进制数。 因此，六位和八位颜色表示方式的区别在于八位方式多了一个表示透明度的通道，而且将四个颜色通道和透明度通道的数值压缩到一个 32 位的整数中，可以更加节省存储空间。 六位颜色和八位颜色的区别当我们在网页设计和开发中定义颜色时，一般使用十六进制表示法。这种表示法使用一个带有 # 符号的字符串，后面跟着六个或八个十六进制数字，来表示颜色。 六位颜色表示法使用 # 符号后面跟着六个十六进制数字，用来表示红、绿、蓝（RGB）三个颜色通道的值。每个颜色通道的值都是介于 00 到 FF 之间的十六进制数字，其中 00 表示最小值，FF 表示最大值。例如，#FF0000 表示红色，#00FF00 表示绿色，#0000FF 表示蓝色。 而八位颜色表示法则将 RGB 值和一个透明度通道值（Alpha）结合起来，使用一个带有 # 符号的字符串后面跟着八个十六进制数字，用来表示红、绿、蓝（RGB）三个颜色通道以及透明度通道的值。每个颜色通道的值仍然是介于 00 到 FF 之间的十六进制数字，而透明度通道的值则表示颜色的不透明度，也是介于 00 到 FF 之间的十六进制数字。例如，#FF0000FF 表示红色，透明度为不透明（即不透明度为 FF）。 六位颜色表示法适用于大多数情况，比如定义文本颜色、背景颜色等。而八位颜色表示法则更适用于需要定义半透明颜色的情况，比如定义阴影颜色、边框颜色等。在实际开发中，使用六位和八位颜色表示法时需要根据具体的需求来选择，遵循“合适即好”的原则。 总之，六位和八位颜色表示法是网页设计和开发中常用的颜色表示方式，通过了解这两种表示法的区别和应用场景，我们可以更好地运用它们来实现我们的网页设计需求。"},{"title":"【ai绘画】Midjourney 之 Commands（实用命令）","date":"2023-04-19T06:16:35.000Z","url":"/2023/04/19/midjourney3-1/","tags":[["Midjourney","/tags/Midjourney/"],["ai繪畫","/tags/ai%E7%B9%AA%E7%95%AB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"太常用的就不列举了，比如 /imagine 感觉比较常用的实用的如下：/info/blend/describe/remix/show/settings"},{"title":"【2023-04-17】bing该说你靠谱还是该说你离谱","date":"2023-04-17T07:13:19.000Z","url":"/2023/04/17/bing/","tags":[["bing","/tags/bing/"]],"categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 不过就离谱这点我觉得chatgpt倒也不输给它。 —————————— 0808 哇。。居然有人不信，把这篇文章状态reset一下"},{"title":"【ai绘画】midjourney试水合集","date":"2023-04-10T11:12:51.000Z","url":"/2023/04/10/midjourney5/","tags":[["Midjourney","/tags/Midjourney/"],["ai繪畫","/tags/ai%E7%B9%AA%E7%95%AB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"准备之后用关键词和命令还有参数一一试水都丢在这里。 觉得midjourney很适合生成连续的故事什么的 关键词A handsome and strong soldier wearing green military uniform, with half of his face visible, in a Japanese anime style. The illustration is semi-thickly painted with bright and colorful tones, resulting in an attractive and glossy finish. adg The scene is set during daytime, under the shining sun. A sweet-looking Japanese-style girl is depicted from the waist up, sporting double buns with her hair mostly blue but also featuring some colorful strands. Her blue eyes are accentuated by a semi-thick paint style and the lighting is coming from the side, highlighting her slightly tilted head and resulting in an attractive glossy finish. 3d风格3d art c4d ultra detoiled "},{"title":"【ai绘画】Midjourney 之 Commands（命令概述）","date":"2023-04-10T11:06:10.000Z","url":"/2023/04/10/midjourney3/","tags":[["Midjourney","/tags/Midjourney/"],["ai繪畫","/tags/ai%E7%B9%AA%E7%95%AB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、命令简介 /ask：提问并获得答案。 /blend：轻松混合两个图像。 /daily_theme：切换是否接收 #daily-theme 频道更新的通知提醒。 /docs：在官方 Midjourney Discord 服务器中使用，快速生成本用户指南中涉及的主题链接！ /faq：在官方 Midjourney Discord 服务器中使用，快速生成常见提示工艺频道的常见问题解答链接。 /fast：切换到快速生成模式。无需排队，需要订阅Standard Plan或Pro Plan（可以使用快速生成模式的时间不同）。 /help：显示有关 Midjourney Bot 的有用基本信息和提示。 /imagine：使用提示生成图像。 /info：查看有关您的帐户以及任何排队或运行的作业的信息。 /stealth：对于 Pro 计划订阅者：切换到隐形模式。 /public：对于 Pro 计划订阅者：切换到公共模式m。 /subscribe：生成用户帐户页面的个人链接。 /settings：查看并调整 Midjourney Bot 的设置。 /prefer option：创建或管理自定义选项。 /prefer option list：查看您当前的自定义选项。 /prefer suffix：指定要添加到每个提示结尾的后缀。 /show：使用图像作业 ID 在 Discord 中重新生成作业。 /relax：切换到放松模式，对应/fast快速生成模式。 /remix：切换混合模式。使用方法：/prefer remix /settings：设置midjourny默认工作方式。比如版本、快速模式、质量等 二、常用命令的详解以上命令部分需要在官方 Midjourney Discord 服务器中使用，所以如果没有用，首先看看自己在不在midjourney的官方服务器。 /blend 作用：融合2-5个图像的风格，生成新的图像。 详见Midjourney 之 Prompts 使用/blend命令混合图像 /docs：查看文档 Settings and Presets（设置与预设） 1️⃣ MJ Version 1 2️⃣ MJ Version 2 3️⃣ MJ Version 3 4️⃣ MJ Version 4 5️⃣ MJ Version 5 模型版本 5仅适用于订阅了 Midjourney 的用户。 🔥 Half Quality 🔥 Base Quality 🔥 High Quality (2x cost) 设置用于作业的质量参数。 半质量 = --q .5，基本质量 = --q 1，高质量 = --q 2。 🖌️ Style Low 🖌️ Style Med 🖌️ Style High 🖌️ Style Very High mk 设置用于作业的风格化参数。 风格低 = --s 50，风格中 = --s 100，风格高 = --s 250，风格非常高 = --s 750， 🧍&zwj;♂️Public 🕵️ Stealth 在公共模式和隐身模式之间切换。对应于/public和/stealth命令。 🎛️ Remix 切换到混音模式 🐇 Fast 🐢 Relax 在Fast 和 Relaxed 模式之间切换。对应于/fast和/relax命令。 设置说明 添加到提示末尾的参数将覆盖使用 所做的选择/settings。 自定义首选项 使用 prefer 命令创建自定义选项，以自动将常用参数添加到提示末尾。 /prefer auto_dm完成的工作会自动发送到直接消息 /prefer option创建或管理自定义选项。 /prefer option list查看您当前的自定义选项。 /prefer suffix指定要添加到每个提示末尾的后缀。 偏好选项 /prefer option set &lt;name&gt; &lt;value&gt;创建可用于将多个参数快速添加到提示末尾的自定义参数。 /prefer option set mine --hd --ar 7:4创建一个名为“我的”的选项，转换为--hd --ar 7:4. 使用/imagine prompt vibrant California poppies --mine, 被解释为/imagine prompt vibrant California poppies --hd --ar 7:4。 将“值”字段留空以删除选项。 /prefer option list列出使用创建的所有选项prefer option set. 用户最多可以有 20 个自定义选项。 要删除自定义选项，请使用/prefer option set &lt;name to delete&gt;值字段并将其留空。 首选后缀 /prefer suffix在所有提示后自动附加指定的后缀。使用不带值的命令进行复位。 命令示例：/prefer suffix --uplight --video Only Parameters可以与 一起使用/prefer suffix， prefer suffix --no orangeis accepted prefer suffix orange::-1不接受 订阅者可以在 Discord 的直接消息中与 Midjourney Bot 进行一对一的工作，而不是通过公共频道。在您的直接消息中制作的图像仍受内容和审核规则的约束，并且将在您的 Midjourney 网站画廊中可见。 设置用于作业的质量参数。 半质量 = --q .5，基本质量 = --q 1，高质量 = --q 2。 🖌️ Style Low 🖌️ Style Med 🖌️ Style High 🖌️ Style Very High 设置用于作业的风格化参数。 风格低 = --s 50，风格中 = --s 100，风格高 = --s 250，风格非常高 = --s 750， 🧍&zwj;♂️Public 🕵️ Stealth 在公共模式和隐身模式之间切换。对应于/public和/stealth命令。 🎛️ Remix 切换到混音模式 🐇 Fast 🐢 Relax 在Fast 和 Relaxed 模式之间切换。对应于/fast和/relax命令。 设置说明 添加到提示末尾的参数将覆盖使用 所做的选择/settings。 自定义首选项 使用 prefer 命令创建自定义选项，以自动将常用参数添加到提示末尾。 /prefer auto_dm完成的工作会自动发送到option set &lt;name&gt; &lt;value&gt;创建可用于将多个参数快速添加到提示末尾的自定义参数。 /prefer option set mine --hd --ar 7:4创建一个名为“我的”的选项，转换为--hd --ar 7:4. 使用/imagine prompt vibrant California poppies --mine, 被解释为/imagine prompt vibrant California poppies --hd --ar 7:4。 将“值”字段留空以删除选项。 /prefer option list列出使用创建的所有选项prefer option set. 用户最多可以有 20 个自定义选项。 要删除自定义选项，请使用/prefer option set &lt;name to delete&gt;值字段并将其留空。 首选后缀 /prefer suffix在所有提示后自动附加指定的后缀。使用不带值的命令进行复位。 命令示例：/prefer suffix --uplight --video Only Parameters可以与 一起使用/prefer suffix， prefer suffix --no orangeis accepted prefer suffix orange::-1不接受 订阅者可以在 Discord 的直接消息中与 Midjourney Bot 进行一对一的工作，而不是通过公共频道。在您的直接消息中制作的图像仍受内容和审核规则的约束，并且将在您的 Midjourney 网站画廊中可见。"},{"title":"【ai绘画】Midjourney 之 Param（参数）","date":"2023-04-10T11:06:10.000Z","url":"/2023/04/10/midjourney4/","tags":[["Midjourney","/tags/Midjourney/"],["ai繪畫","/tags/ai%E7%B9%AA%E7%95%AB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、命令列表1. --aspect或 --ar纵横比。如--ar 16:9就是纵横比16:9 2. --chaos &lt;number 0–100&gt;--chaos &lt;number 0–100&gt; 改变结果的多样性。较高的值会产生更多不寻常的结果。 --chaos接受值 0–100。默认--chaos值为 0。 3. --no--no plants 会尝试从图像中移除植物。 4. --quality &lt;.25&gt;或 --q &lt;.25&gt;--quality &lt;.25, .5, 1, or 2&gt;, 或 --q &lt;.25, .5, 1, or 2&gt; 您要花费多少时间进行渲染。默认值为 1。值越高渲染结果越质量越高，值越低渲染结果越质量越低。 5. --repeat或--r--repeat &lt;1–40&gt;, or --r &lt;1–40&gt; 从单个提示创建多个作业。--repeat对于多次快速重新运行作业很有用。 --repeat适用于 Standard 和 Pro订阅者，--repeat Standard 订阅者接受 2–10 的值。--repeatPro 订阅者接受值 2–40。该参数只能在Fast GPU 模式--repeat下使用。 使用作业结果上的重做（重新滚动）🔄 按钮只会重新运行提示一次。 6. --seed或--sameseedMidjourney 机器人使用种子编号创建视觉噪声场，如电视静态，作为生成初始图像网格的起点。种子编号是为每个图像随机生成的，但可以使用 –seed 或 –sameseed 参数指定。使用相同的种子编号和提示将产生相似的结束图像。 7. --stop使用--stop参数在流程中途完成作业。以较早的百分比停止作业会产生更模糊、更不详细的结果。 8. --style--style &lt;4a, 4b, or 4c&gt;在 Midjourney模型版本4的版本之间--style &lt;expressive, or cute&gt;切换 在 Niji模型版本5的版本之间切换 9. --stylize &lt;number&gt;或--s &lt;number&gt;--stylize &lt;number&gt;，或--s &lt;number&gt; 参数会影响 Midjourney 的默认美学风格应用于 Jobs 的强度。 10. --tile用来生成可用作重复拼贴的图像，比如织物、壁纸、纹理等。 11. --video使用该--video参数创建正在生成的初始图像网格的短片。使用信封 ☉️ 表情符号对完成的工作做出反应，让 Midjourney Bot 将视频链接发送到您的直接消息。 --video仅适用于图像网格，不适用于高档。--video适用于模型版本 1、2、3、test和testp。 效果： 12. --uplight --uplight选择 U 按钮时使用替代的“轻型”升频器。结果更接近原始网格图像。放大后的图像细节更少，更平滑。 13. --upbeta --upbeta选择 U 按钮时使用替代的 beta 升频器。结果更接近原始网格图像。放大后的图像添加的细节明显更少。 14. 默认参数(Model Version 4) –ar –c –q –seed –stop –style –stylize 默认值 1:1 0 1 随机 100 4c 100 范围 1:2–2:1 0–100 .25 .5 or 1 0–4294967295 10–100 4a, 4b, or 4c 0–1000 15. 默认参数 (Model Version 5) –ar –c –q –c –stop –stylize 默认值 1:1 0 1 随机 100 100 范围 any 0–100 .25 .5, or 1 0–4294967295 10–100 0–1000 大于 2:1 的宽高比是实验性的，可能会产生不可预测的结果。（实测有时会有黑边。） 二、--seed详细说明1. --seed说明用过 Midjourney 的小伙伴会发现在发送提示词后，MJ 最开始的图像里会有一个非常模糊的噪点团 ，然后逐渐变得具体清晰，而这个噪点团的起点就是“Seed”。MJ 依靠它来创建一个视觉噪音场，作为生成初始图像的起点。每个图像的种子值是为随机生成的，但可以用 –seed 参数指定。在 v4 模型中使用相同的种子值和提示词将产生相同的图像结果，利用这点我们可以生成连贯一致的人物形象或者场景。 Seed是Midjourney图像生成的初始点，每个图像的种子值是随机生成的，但可以用Seed参数保持统一。使用相同的种子值和提示词将产生完全相同的图像结果，利用这但可以生成连贯的人物形象或场景。 a rabbit –seed 4100004954，只要seed值一致，那么无论生成几次，只要关键词相同结果都是相同的。 2. 获取 --seed使用时要确保服务器开启了隐私设置。 如果是自己创建的服务器，那么需要在个人服务器上右键 - 隐私设置 也可以全局设置，Discord - Preferences - 隐私与安全 - 允许服务器成员直接向您发起私聊。 但要注意，这个设置不适用于已经加入的服务器。 3. 使用示例首先输入描述，然后为描述指定seed，seed可以随机填，比如我这里写12345，那么生成的四宫格整张图的seed值就是12345 比如我选择了图2作为接下来要持续生成的图，点击U2 然后获取seed值 图像上右键 - 选择envelope 如果没有，点击添加反应 - 显示更多 - 搜索envelope并添加 然后点击私信 - midjourney Bot，就可以查看了。 拿到seed值后，根据上面的关键词，尽量不要变动，然后进一步描述场景、细节等 就会发现生成的图片是基于上面的图片去变动的（虽然有时候变动的也挺一言难尽）。 seed值相同，描述值相同，生成的结果也相同。 三、--chaos（--c）详细说明--chaos参数影响初始图像网格变化程度。高--chaos值将产生更多不寻常和意想不到的结果和组合。较低的--chaos值具有更可靠、可重复的结果。 --chaos接受值 0–100。默认--chaos值为 0。 低chaos可以使结果图像差别低， 高chaos可以使结果图像差别高。 四、 --remix详细说明使用remix模式更改提示、参数、模型版本或变体之间的纵横比。Remix 将采用您的起始图像的一般构图，并将其用作新工作的一部分。重新混合可以帮助改变图像的设置或照明、发展主题或实现棘手的构图。Remix是一项实验性功能，可能会随时更改或删除。 使用/prefer remix命令开启或关闭 然后在生成图像后，点击Make Variations，会弹出Remix框。（若remix开启成功，按钮将变成绿色） 我将 chinese girl 描述词变为了 cat，点击提交 新生成的图片就会以原图为基础，女人变成了喵头。（看起来确实一言难尽吖。。。！！） 五、upscaler详细说明1. 简略说明Midjourney 首先为每个作业生成一个低分辨率图像选项网格。您可以在任何网格图像上使用 Midjourney upscaler 来增加尺寸并添加更多细节。有多种可用于放大图像的放大模型。每个图像网格下方的按钮用于放大所选图像。U1 U2 U3 U4 点击了某个图像放大器之后，会有一排按钮 这就是升频器。 2. 对应尺寸和大小所有尺寸均适用于 1:1 宽高比的正方形。 模型版本 起始网格大小 V4 default Upscaler Detail Upscale Light Upscale Beta Upscale Anime Upscale Max Upscale** 默认模型 v4 512 x 512 1024 x 1024 * 1024 x 1024 1 024 × 1024 2048 x 2048 1024 x 1024 - v5 1024 x 1024 - - - - - - v1–v3 256×256 - 1024 x 1024* 1024 x 1024 1024 x 1024 1024 x 1024 1664 x 1664 niji 512 x 512 1024 x 1024 1024 x 1024 1024 x 1024 2048 x 2048 1024 x 1024 - niji 5 1024 x 1024 - - - - - - test/testp 512 x 512 - - - 2048 x 2048 1024 x 1024* - hd 512 x 512 - 1536 x 1536* 1536 x 1536 2048 x 2048 - 1024 x 1024 *= 每个 Midjourney 版本模型的默认升频器。**Max Upscale 是一种较旧的资源密集型升频器，仅在用户处于快速模式时可用。 升频器分为Regular (Default) Upscaler、Light Upscaler、Detailed Upscaler、Beta Upscaler、Anime Upscaler、Remaster。切换方式就在每个图片生成后，下方的一排按钮 官方文档对每种升频器的介绍非常详细，这里就不多说了。 Midjourney Model 5 The newest Midjourney Model Version 5 (and Niji 5) produces high-resolution 1024 x1024 px image grids without needing an additional step to upscale each mage. When using Midjourney Model Version 5, the U1 U2 U3 U4 buttons under each image grid will separate the selected image from the initial image grid. 人话：v5模型和niji模型的默认升频器包含了放大图像的作用，因为初始生成的图像就已经是1024*1024了，所以点击u1、u2、u3、u4就是将每个图片单独提取出来而已。而其他版本的模型点击u1、u2、u3、u4是有放大并添加细节的作用的。 六、--tile详细说明用来生成可用作重复拼贴的图像，比如织物、壁纸、纹理等。 --tile适用于模型 版本1、2、3和5。且仅仅生成一个瓦片。 若想根据该瓦片生成完整壁纸/图案/纹理的话，可以使用像这种无缝模式检查器这样的模式制作工具来查看拼贴重复。 使用方法示例： 它生成的结果是一块一块的，单独一块被称为瓦片。瓦片重复需要自己去拼接。 七、--stylizeMidjourney Bot 经过训练可以生成有利于艺术色彩、构图和形式的图像。或参数影响该训练应用--stylize的--s强度。低--stylize生成的图像与提示非常匹配，但艺术性较差。高--stylize创建的图像非常具有艺术性，但与提示的联系较少。--stylize的默认值为 100，并且在使用默认 [V4 模型] 时接受 0-1000 的整数值。 不同的Midjourney 版本模型具有不同的风格化范围。 v5 v4 v3 test/testp Niji 程式化默认 100 100 2500 2500 other 程式化范围 0–1000 0–1000 625–60000 1250–5000 other 八、复合提示比如hot dog（热狗）这种词，如果想分开表示hot 和 dog （一只很热的狗），那就需要复合提示。 复合提示使用::表示 比如： 再比如： 纸杯蛋糕插图 被认为是一起制作纸杯蛋糕的插图图像。 杯子 与 蛋糕插图 分开考虑，制作杯子中的蛋糕图像。 杯子 、 蛋糕 和 插图 被分开考虑，制作一个杯子里的蛋糕，带有花朵和蝴蝶等常见的插图元素。 权重复合提示可以赋予权重如hot::2 dog，意思是hot的重要性比dog大两倍，又可以写成hot::2 dog::1 v4可以接受小数做权重，v1-3只能接受整数，默认为1。 可以接受负数权重，但所有权重的总和必须为正数。 负数权重可以用来去掉某些元素九、排列提升 可以同时处理多个作业，这个我暂时用不到，所以略过了。 简单的用法就是用大括号&#123;&#125;分割选项列表，然后快速创建多个作业，最多可以同时创建40个。 比如：/imagine prompt a &#123;red, green, yellow&#125; bird 创建并处理三个作业。 相当于： 那这样子就方便去创建一些只有部分元素不同，而整体装饰或构图相同的作业。 可以固定部分描述不变，参数也不变，部分描述变体。 或者固定部分参数不变，描述不变，尺寸变化等等。 支持多层嵌套 在我看来，有些像remix，但remix会在原图基础上调整。而这个是直接生成新的。 转义大括号内用逗号做分割，但如果描述包含逗号，可以使用转义字符 相当于 "},{"title":"【ai绘画】Midjourney 之 Prompts","date":"2023-04-09T03:55:04.000Z","url":"/2023/04/09/midjourney2/","tags":[["Midjourney","/tags/Midjourney/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、Promptsprompts（提示）是 Midjourney Bot 解释以生成图像的短文本短语。Midjourney Bot 将提示中的单词和短语分解为更小的部分，称为标记，可以将其与其训练数据进行比较，然后用于生成图像。精心制作的提示可以帮助制作独特而令人兴奋的图像。 1. 结构提示可以像一个单词、短语、emoji一样简单，也可以使用更高级的提示。 更高级的提示可以包括一个或多个图像 URL、多个文本短语以及一个或多个参数 image Prompts 可以将图像 URL 添加到提示中以影响最终结果的样式和内容。 图片 URL 始终位于提示的前面。 Text Prompt 要生成的图像的文本描述。 Parameters Parameters位于提示的末尾，它可以改变图像的生成方式。 用–表示。 可以更改宽高比、模型、放大器等等。 2. 需要注意的提示点长度非常短的提示将在很大程度上依赖于 Midjourney 的默认样式。 更具描述性的提示更适合独特的外观。 语法不是越长越好，要提取重点词，专注于要创建的主要概念。因为midjourney不是像人类那样理解语法。 要用更精准的词汇，比如：大，是怎么样的大？ big, try gigantic, enormous, immense 去掉不需要的内容--no参数加上的东西可以告诉midjourney，你不想在图像上出现什么 比如不想要蛋糕，可以加上--no cake （唔、挺惊悚的。。生日没有蛋糕的怒气值叠满了！） 考虑哪些细节很重要尽量把很重要的任何背景或细节搞清楚： 主题：人、动物、人物、地点、物体等。 媒介：照片、绘画、插图、雕塑、涂鸦、挂毯等。 环境：室内、室外、月球上、纳尼亚、水下、翡翠城等。 照明：柔和、环境、阴天、霓虹灯、工作室灯等 颜色：充满活力、柔和、明亮、单色、彩色、黑白、柔和等。 情绪：稳重、平静、喧闹、精力充沛等。 构图：肖像、头像、特写、鸟瞰图等。 把官网的英文摘下来作参考： Subject: person, animal, character, location, object, etc. Medium: photo, painting, illustration, sculpture, doodle, tapestry, etc. Environment: indoors, outdoors, on the moon, in Narnia, underwater, the Emerald City, etc. Lighting: soft, ambient, overcast, neon, studio lights, etc Color: vibrant, muted, bright, monochromatic, colorful, black and white, pastel, etc. Mood: Sedate, calm, raucous, energetic, etc. Composition: Portrait, headshot, closeup, birds-eye view, etc. 使用具体数字比如”three birds”就比”birds”更加精确 3. Exprore Prompting（探索提示）选择媒介提示示例：/imagine prompt &lt;any art style&gt; style cat 常用的媒介类型： Block Print版画 Folk Art民间艺术 Cyanotype蓝版 Graffiti涂鸦 Paint-by-Numbers数字绘画 Risograph数字印刷 Ukiyo-e浮世绘 Pencil Sketch铅笔素描 Watercolor水彩 Pixel Art像素画 Blacklight Painting紫外线画 Cross Stitch十字绣 细化更精确的单词和短语将有助于创建具有完全正确外观和感觉的图像。 提示示例：/imagine prompt &lt;style&gt; sketch of a cat Life Drawing写生 Continuous Line连续线 Loose Gestural随性手势画 Blind Contour草图速写 Value Study明暗对比研究 Charcoal Sketch炭笔素描 时间旅行不同的时代有不同的视觉风格。 提示示例：/imagine prompt &lt;decade&gt; cat illustration 1700s 1800s 1900s 1910s 1920s 1930s 1940s 1950s 1960s 1970s 1980s 1990s 表情提示示例：/imagine prompt &lt;emotion&gt; cat Determined坚定 Happy快乐 Sleepy困 Angry生气 Shy害羞 Embarassed尴尬 使颜色更加丰富提示示例：/imagine prompt &lt;color word&gt; colored cat Millennial Pink千禧粉 Acid Green酸性绿 Desaturated无饱和度 Canary Yellow金丝雀黄 Peach桃色 Two Toned双色调 Pastel粉彩 Mauve淡紫色 Ebony乌木色 Neutral中性色 Day Glo荧光色 Green Tinted绿色调 环境提示示例：/imagine prompt &lt;location&gt; cat Tundra苔原 Salt Flat盐滩 Jungle密林 Desert沙漠 Mountain山脉 Cloud Forest云雾森林 使用/blend命令混合图像该/blend命令允许您快速上传 2-5 张图像，然后读取每张图像的风格和元素，并将它们合并成一个新颖的新图像。 /blend与使用多个图像提示相同/imagine，但界面经过优化以方便在移动设备上使用。 /blend最多可处理 5 张图像。要在提示中使用 5 个以上的图像，请使用/imagine prompts /blend，不适用于文本提示。要同时使用文本和图像提示，请使用/imagine prompts /blend选项输入/blend命令后，系统会提示您上传两张照片。 要添加更多图像，可点击 增加4 并选择image3、image4或image5。 该/blend命令可能需要比其他命令更长的时间才能启动，因为您的图像必须在 Midjourney Bot 可以处理您的请求之前上传。 dimensions：可设置生成图片比例。混合图像的默认纵横比为 1:1，但您可以使用可选dimensions字段在方形纵横比square (1:1)、纵向纵横比portrait (2:3) 或横向纵横比landscape (3:2) 之间进行选择。 自定义后缀被添加到提示的末尾/blend，就像任何其他/imagine提示一样。作为/blend命令的一部分指定的宽高比会覆盖自定义后缀中的宽高比。 混合技巧为获得最佳效果，请上传与您想要的结果具有相同宽高比的图像。"},{"title":"uni-app基础(总结中)","date":"2023-04-06T08:09:55.000Z","url":"/2023/04/06/uni-app/","tags":[["uni-app","/tags/uni-app/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、uni-app重点总结1. uniapp 规范 页面遵循vue语法，模板块、脚本块和样式块。 页面遵循vue单文件组件规范（SFC） 页面标签遵循小程序语法规范 接口接近小程序规范 数据绑定及事件处理遵循vue规范 为兼容多端运行，遵循flex布局。 2. uniapp 特色 条件编译 App端的Nvue开发 Nvue是native-vue的简写。是在uniapp中以.nvue结尾的文件，它为app提供了原生的渲染能力。 Nvue内置了weex的渲染引擎，所以在.nvue文件中，既可以使用weex内置的方法，也可以使用uni-app的内置方法。 只能在NATIVE端使用。 HTML5+ HTML5+引擎为应用提供了原生的安卓端和ios端的方法。有一些复杂功能在html5无法做到时，可以使用html5+引擎。 只能在NATIVE端使用 二、创建uniapp项目1. 通过hbuilder创建安装好hbuilder后， 运行： 2. 通过vue命令行创建环境安装全局安装vue-cli 创建uni-app使用正式版（对应HBuilderX最新正式版） 使用alpha版（对应HBuilderX最新alpha版） 三、语法1. 模板语法和vue一样 2. 数据绑定在小程序中使用 在uni-app中 其实就和vue是一样的。 3. 条件判断 注：v-show在uni-app非h5页面中会有坑。尽量不要把v-show放在组件上，在组件外层套一层view。 4. 列表渲染 5. 内置组件view相当于div text相当于span scroll-view swiper和swiper-item match-media movable-area和movable-view：即手指/鼠标按住movable-view拖动或双指缩放，但拖不出movable-area规定的范围。 movable-view必须在movable-area组件中，并且必须是直接子节点，否则不能移动。 cover-view和 cover-image : cover-view相当于 position: fixed; 但在其中可以写自己的布局。 cover-image和cover-view用法相同，区别在于cover-image只可以放图片，它可以嵌套在cover-view中 button input 6. 自定义组件的使用7. 基础 api 用法8. 条件编译9. 页面布局"},{"title":"【ai绘画】Midjourney 之 入门","date":"2023-04-03T03:37:57.000Z","url":"/2023/04/03/midjourney1/","tags":[["Midjourney","/tags/Midjourney/"],["ai繪畫","/tags/ai%E7%B9%AA%E7%95%AB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"想了想还是整理一下文档吧。ai出来一个我就搁colab部署一个，midjourney掏点儿小钱就能省去我部署的步骤真是太好了。而且也不像stable diffusion那样需要自己搜集训练模型我体验过的ai绘画中算是效果最好，上手难度最低的一个。 一、安装及入门1. 注册discord midjourney的使用是通过discord访问，所以需要注册discord。 点击进入：discord官网 科学上网简单介绍discordDiscord是一款免费的语音、视频和文字聊天应用程序，它允许用户在私人或公共服务器上创建和加入聊天室或频道。Discord的功能包括语音和视频通话、实时文本聊天、文件共享、屏幕共享、在线状态、自定义表情符号和徽章、服务器和频道管理工具等。它还提供了丰富的API，允许开发者创建自定义的机器人和集成其他服务。通过Discord，用户可以方便地与其他人交流和合作，无论是在游戏、工作还是社交方面。它已经成为了一个非常流行的工具，有着庞大的用户群体和活跃的社区。 2. 访问midjourney.com访问Midjourney.com，点击join the Beta，或直接前往Midjourney Discord。 3. 寻找newbies频道在discord左侧，有房间可选 随便选择一个进入即可。 4、 使用 /imagine 命令 从斜杠命令弹出窗口中键入/imagine prompt:或选择命令。/imagine 该/imagine命令从简短的文本描述（称为Prompt）生成一个独特的图像。 初次使用时，Midjourney Bot 将生成一个弹出窗口，要求您接受服务条款。在生成任何图像之前，您必须同意服务条款。 5、处理图像Midjourney Bot 需要大约一分钟的时间来生成四个选项。生成图像会激活免费的 Midjourney 试用版。试用用户有部分的免费时间，在需要订阅付费之前可以完成大约 25 个工作。 使用/info命令检查你的快速剩余时间查看您的剩余试用时间。 6、图像生成的基础上，进一步的变化初始图像网格生成完成后，会出现两行按钮： U 按钮放大图像，生成所选图像的更大版本并添加更多细节。 V 按钮创建所选网格图像的细微变化。创建变体会生成与所选图像的整体风格和构图相似的新图像网格。 🔄（重新滚动）重新运行作业。在这种情况下，它将重新运行原始提示，生成新的图像网格。 7. 评价图像使用放大图像后，将出现一组新选项： Make Variations：创建放大图像的变体并生成包含四个选项的新网格。 Beta/Light Upscale Redo：使用不同的升级器模型重做升级。 ↗️Web：在Midjourney.com 上打开图库中的图像 8. 保存图像单击图像以全尺寸打开它，然后右键单击并选择Save image。 在手机上，长按图片，然后点击右上角的下载图标。 所有图片均可立即在midjourney.com/appSign In with Discord上查看。 9. 订阅服务试用用户有试用时长，若不生成图片不会消耗，但也不会更新。要制作更多图像，请使用/subscribe在任何newbies频道中的命令生成指向中途帐户页面的个人链接。 不要与他人分享此个人链接。 请访问订阅服务，获取有关价格和更多信息。 二、创建自己的个人服务器在公共频道很多人都在生成图片，要翻找自己生成的图片很麻烦。 可以在discord创建自己的服务器并部署midjourney机器人，在自己的频道下使用midjourney。 注：虽然在自己的个人服务器可以只展示自己的图片，但实际上生成的图片还是在midjourney公共区可以访问到。 只有付费计划pro plan可以避免这点。 1. 创建服务器点击+号 —&gt; 亲自创建 —&gt; 仅供我和我的朋友使用 —&gt; 创建 2. 进入频道，输入命令即可使用 入门部分就到这里，之后我会用新文章整理关键字及命令部分。"},{"title":"【BFC】BFC","date":"2023-04-03T03:12:24.000Z","url":"/2023/04/03/BFC/","tags":[["css","/tags/css/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"BFC概念BFC是“块级格式化上下文”的缩写，用于控制文档中块级元素的布局和定位。在一个BFC中，元素按照一定的规则进行排列，不会影响到BFC外部的元素。BFC的常见特征包括： 内部的盒子会在垂直方向上一个接一个地放置，因此不会重叠。 在BFC中，每个盒子的左边和右边外边距（margin）不会和其他元素的外边距折叠（collapse）。 BFC可以包含浮动元素，因此可以避免浮动元素对其他元素的影响。 BFC的高度可以自适应其内部元素的高度，不会塌陷（collapse）。 通过理解和应用BFC，可以更好地掌控页面的布局和样式，解决一些常见的排版问题，比如清除浮动、避免外边距折叠等。 BFC的实际运用场景清除浮动：当一个父元素包含了一个浮动元素时，父元素可能会因为子元素浮动而导致高度塌陷。这时可以在父元素上创建一个新的BFC来解决这个问题，例如： 避免外边距折叠当两个相邻的元素的外边距发生重叠时，可以在其中一个元素上创建一个新的BFC来避免这个问题，例如： 自适应布局在一个父元素中，如果有一些子元素的高度不固定，可以在父元素上创建一个新的BFC，从而实现自适应布局，例如： 解决文本环绕问题当需要在一个元素周围放置文本时，可以在该元素上创建一个新的BFC，从而实现文本环绕的效果，例如： 其他可以创建bfc的例子上面列举的多数还是使用overflow: hidden时，这种BFC的创建方式是很常用来解决布局问题的。实际上还有很多别的方法会创建BFC。 + 使用float属性创建新的BFC： + 使用position属性创建新的BFC： 使用display创建BFC使用一些display属性值也可以创建新的BFC，例如display: table-celldisplay: table-caption等。"},{"title":"【性能优化】Webpack-Bundle-Analyzer","date":"2023-04-03T02:46:52.000Z","url":"/2023/04/03/Webpack-Bundle-Analyzer/","tags":[["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"简单写一下，就是在开发时使用了它做性能分析，还是挺好用的。 官网 简介 Webpack Bundle Analyzer是一个Webpack插件，用于分析和可视化Webpack打包后的bundle文件。它可以帮助开发者找出打包文件中的性能瓶颈和优化机会，从而提高应用程序的性能和用户体验。 Webpack Bundle Analyzer可以生成一个可交互的可视化图表，展示打包后的bundle文件中各个模块的大小、依赖关系、文件类型等信息，还可以通过颜色区分出不同的模块类型，如应用代码、第三方库、webpack运行时等。开发者可以通过这个图表找出文件中占用空间最大的模块和文件，进一步分析和优化代码和依赖关系，减少文件大小和提高打包速度。 除了可视化图表外，Webpack Bundle Analyzer还可以生成详细的报告文件，包含了模块和文件的详细信息，开发者可以根据报告文件找出打包文件中的性能问题和优化机会。 在前端开发中，Webpack Bundle Analyzer可以帮助开发者分析和优化Webpack打包文件，从而提高应用程序的性能和用户体验。 在umi+react中的使用umi是一个基于webpack和babel的可扩展企业级前端应用框架，可以帮助开发者快速构建React单页面应用或多页面应用。umi集成了Webpack，所以我们可以直接在umi项目中使用Webpack Bundle Analyzer插件来分析和优化打包文件。 首先，在项目中安装Webpack Bundle Analyzer插件： 然后，在.umirc.js文件中配置Webpack Bundle Analyzer插件： 配置完成后，运行umi dev命令，Webpack Bundle Analyzer插件将自动启动并在浏览器中显示打包文件的分析报告。 通过Webpack Bundle Analyzer插件，开发者可以快速找出应用程序中占用空间最大的模块和文件，进一步分析和优化代码和依赖关系，提高应用程序的性能和用户体验。"},{"title":"组件库相关","date":"2023-03-30T11:01:18.000Z","url":"/2023/03/30/zjk/","tags":[["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、思维整理移动端的前端组件库可以包括许多组件，这里列出一些常见的组件：按钮组件：用于触发操作或提交表单。图标组件：用于显示图标。输入框组件：包括文本输入框、数字输入框等。列表组件：用于展示列表信息。滚动组件：用于滚动显示大量内容。轮播组件：用于轮播广告或图片。弹窗组件：用于弹出提示或确认框。标签组件：用于分类或标记信息。搜索组件：用于搜索信息。日期时间组件：用于选择日期时间。下拉选择组件：用于选择下拉菜单中的选项。滑块组件：用于选择范围或值。表单组件：包括表单验证、提交等。树形组件：用于显示层级结构。下拉刷新：下拉时可以重新加载数据。上拉加载更多：当data很多时分页适用。头像+头像框组件：有些活动中会有不规则头像框，或者vip的特效等。搜索文本框：带搜索按钮的文本款组件等。再比如性能优化方面，防抖、节流等 jsbridge相关：调用相机、调用相册、分享等 组件库搭建：展示方面：用react/vue + bootstrap4 做框架，codesandbox做代码演示，还有复制链接及效果，类似antd组件的网站。然后使用npm包安装，引入使用。 比如说，我现在想搭一个npm包，里面包括按钮组件、搜索框组件等。这里我就只写两个按钮组件、搜索框组件 二、npm包的开发示例1. 安装依赖 2. 在项目根目录下创建一个 webpack.config.js 文件，配置如下：在项目根目录下创建一个 webpack.config.js 文件，配置如下： 其中，entry 字段指定了入口文件，output 字段指定了输出配置，这里生成了一个名为 my-button.js 的文件，library 指定了模块名称，libraryTarget 指定了模块的导出方式。 3. 在 src 目录下创建 index.js 文件和 Button.vue 文件，分别编写代码如下： Button.vue： 4. 在命令行中运行以下命令打包： 5. 引用将打包后的文件（即 my-button.js）上传到 npm 上，然后在需要使用该组件库的项目中，通过以下命令安装该组件库： 在项目中使用该组件库，可以像下面这样引入： 之后就可以在Vue 组件中使用 MyButton 组件了，像这样： 三、在原有组件基础上加入新的搜索文本框组件思路：先将新的搜索文本框组件写好并打包成一个单独的模块。然后，可以在 my-button 组件中引入新的搜索文本框组件并进行相应的配置和使用。最后，将 my-button 和搜索文本框组件打包成一个组件库并发布到 npm 上。 具体的步骤如下： 1. 编写搜索文本框组件具体的编写就不说了，假设已经编辑好，命名为 my-input。创建一个webpack.config.js文件，配置打包规则： 这里使用了 vue-loader 处理 .vue 单文件组件，使用 css-loader、vue-style-loader 和 style-loader 处理样式文件，使用 file-loader 处理静态资源文件。设置了输出目录路径、输出文件名称、打包生成的库的名称、打包生成的库的目标环境等。 2. 在 src 目录下创建一个 index.js 入口文件，用于导出组件： 3. 引入 在项目中引用组件库中的组件，首先需要在代码中引入组件，比如： 然后在代码中直接使用引入的组件即可： 三、搭建boostrap+vue的网页端待补充"},{"title":"【npm】npm发布步骤","date":"2023-03-28T03:36:08.000Z","url":"/2023/03/28/npmfb/","tags":[["npm","/tags/npm/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"npm包发布发布一个npm包通常需要以下步骤： 确保你已经安装了Node.js和npm，以及在npm上注册了一个账户。如果没有，请先在上注册一个账户。 在终端中创建一个新的项目文件夹，并进入该文件夹。执行以下命令来初始化npm包： 在你的项目文件夹中编写代码，并确保在package.json文件中指定了正确的入口文件路径和依赖项。 编写README文件和许可证文件，并确保它们在项目文件夹中。 在终端中运行以下命令来登录npm账户: 输入你的用户名、密码和电子邮件地址。如果一切顺利，你将登录成功（若无法登录，请看看“可能遇到的问题”部分）。 在终端中运行以下命令，将包发布到npm上: 这将把你的npm包上传到npm仓库。你的包将被分配一个唯一的版本号，并且其他人可以通过npm来安装你的包。如果你需要更新你的包，只需更新代码，修改版本号并再次运行npm publish命令即可。 请注意，当你发布npm包时，你的代码将被公开发布到npm上。因此，你应该小心保护敏感信息，并确保遵循最佳实践，以确保代码的安全性和稳定性。 npm包删除如果你想删除自己发布的npm包，可以在终端中使用以下命令： 请注意，删除一个包是不可逆转的，因此请确保你真正需要删除它，以避免造成不必要的损失。 其他注意事项： 删除已发布的npm包会破坏其他人对你的代码的依赖，因此在删除之前，请确保没有人正在使用你的代码，或者提供足够的警告时间，以便其他人可以切换到其他代码。 如果你已经发布了多个版本的npm包，则只能删除最新的版本，不能删除旧版本。 删除npm包需要管理员权限，因此你需要确保你的账户拥有管理员权限，才能删除你发布的包。 可能遇到的问题如果你执行 npm login 命令时出现错误，可能是以下几种情况之一： 检查你的npm账户是否已注册。如果你还没有npm账户，你需要先在npm的官方网站上注册一个账户。 检查你的网络连接是否正常。如果你的网络连接不稳定或者有问题，可能导致登录失败。 检查你的npm注册表是否正确。如果你要登录的是npm的私有注册表，确保你已经订阅了npm付费计划，以便可以创建一个私有注册表，并通过该私有注册表来发布私有包。 检查你的npm配置是否正确。你可以在命令行中运行以下命令，查看npm的配置信息： 确保你的 registry 配置是正确的。如果你要登录的是npm的私有注册表，确保你的 registry 配置是指向该私有注册表的。 如果你已经确认了以上的问题，并且你的 npm login 命令仍然失败，你可以尝试以下几种方法： 清除npm的缓存。你可以使用以下命令来清除npm的缓存： 清除缓存后，尝试再次登录。 检查npm的版本。确保你正在使用的是最新版本的npm。 如果你使用的是代理服务器，你可以尝试在命令行中设置代理服务器。例如： 将 yourproxy 替换为你的代理服务器地址，将 yourport 替换为你的代理服务器端口号。 如果你仍然无法成功登录，你可以查看npm的官方文档或者向npm的技术支持团队寻求帮助。 关于第四点，确认是否使用私有注册表的补充因为很多人使用的是国内淘宝镜像以至于npm login不成功，此时只需要改为官方镜像即可。 具体方法如下：要确认是否使用私有注册表，你可以检查你的npm配置文件。默认情况下，npm会将你的包发布到npm官方的公共注册表，而不是私有注册表。如果你要使用私有注册表，你需要订阅npm的付费计划，并创建一个私有注册表。在登录时，你需要使用该私有注册表的URL。 要检查你的npm配置是否指向私有注册表，可以运行以下命令： 如果输出的结果是私有注册表的URL，那么你正在使用私有注册表。如果输出的结果是默认的公共注册表URL（），那么你不是在使用私有注册表。 如果你确定你要使用私有注册表，但无法成功登录，那么可能是因为你的npm配置不正确。确保你已经在npm上订阅了付费计划，并创建了一个私有注册表。在登录时，你需要使用该私有注册表的URL，并提供正确的访问凭据。如果你仍然无法成功登录，你可以联系npm的技术支持团队，寻求帮助。 如何更改？你可以通过 npm config set 命令来更改npm的配置。例如，要将npm配置的注册表更改为私有注册表的URL，可以使用以下命令： 其中 &lt;your-private-registry-url&gt; 是你的私有注册表的URL。你需要将其替换为你的实际URL。 如果你想将npm配置恢复为默认设置，可以使用以下命令： 这将删除当前配置的 registry 选项，使npm使用默认的公共注册表。 发布一个私有的npm包 使用npm收费工具 如果你希望仅向付费用户提供访问权限，你可以使用npm的付费工具。你可以在npm网站上注册一个付费账户，创建一个收费组织，然后将你的包添加到该组织中。然后，你可以设置访问权限，仅允许那些已经付费的用户使用你的包。 使用npm访问令牌 另一种方法是使用npm访问令牌。你可以创建一个令牌，并将其授予仅限于你允许的用户。然后，你可以将该令牌用于安装你的包。只有持有该令牌的用户才能使用你的包。你可以在npm网站上创建一个访问令牌，并将其添加到你的项目中的.npmrc文件中。请确保令牌不被泄露，以避免未经授权的用户使用你的代码。 使用私有npm仓库（类似淘宝镜像源的服务器，但其实淘宝镜像源是公开的） 最后，你可以使用私有npm仓库。你可以在你自己的服务器上搭建一个npm仓库，并将你的包上传到该仓库中。然后，你可以设置访问权限，只有你允许的用户才能访问该仓库并安装你的包。你可以使用像Sinopia、Verdaccio等这样的开源工具来搭建私有npm仓库。 1、3都属于人民币玩家的方式，这俩方式就不说了 使用npm访问令牌第二种方法是使用npm访问令牌。你可以创建一个令牌，授予仅限于你允许的用户，并将该令牌用于安装你的npm包。以下是实现此目的的详细步骤： 首先，你需要在npm上注册一个账户。如果你还没有注册，请在上注册一个账户。 接下来，你需要创建一个npm访问令牌。你可以使用以下命令在终端中创建一个访问令牌： &lt;registry-url&gt;是指你要发布npm包的npm仓库的地址。例如，如果你要发布到npm官方仓库，那么这个值应该是。如果你要发布到私有仓库，那么这个值应该是你的私有仓库地址。 执行以上命令后，npm将提示你输入你的npm账户的用户名和密码。输入正确的用户名和密码后，npm将生成一个新的访问令牌，并将其输出到终端中。 将新生成的访问令牌添加到你的.npmrc文件中。.npmrc文件通常位于你的用户目录下。在.npmrc文件中添加以下内容： &lt;registry-url&gt;是你要发布npm包的npm仓库地址，&lt;access-token&gt;是你新生成的访问令牌。 将你的npm包发布到npm仓库。你可以使用以下命令将你的包发布到npm仓库中： &lt;registry-url&gt;是你要发布的npm仓库地址，可以是npm官方仓库或者私有仓库。 现在，只有持有你的访问令牌的用户才能访问和安装你的npm包。你可以将访问令牌授予你允许的用户，或者在需要时撤销该令牌的访问权限。 请注意，访问令牌是一个非常重要的凭证，因此你需要妥善保管它，不要将它泄露给未经授权的用户。如果你怀疑你的令牌已经被泄露，那么你应该立即撤销该令牌，并生成一个新的访问令牌。"},{"title":"【实用工具】Mitmproxy 抓包","date":"2023-03-24T03:49:42.000Z","url":"/2023/03/24/mitmproxy/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"什么是MitmproxyMitmproxy是一款基于Python开发的抓包工具，可以用于拦截、修改和重放HTTP和HTTPS流量。以下是使用Mitmproxy进行抓包的简单步骤： 安装和启动安装和启动Mitmproxy：你可以从Mitmproxy的官方网站（）上下载安装程序，并根据操作系统的不同进行安装。安装完成后，你可以通过在终端窗口输入“mitmproxy”命令来启动Mitmproxy。 配置设备代理配置设备代理：将设备的代理设置为Mitmproxy的IP地址和端口号（默认端口号为8080）。具体方法取决于你使用的设备和操作系统。例如，在iOS设备上，你可以通过“设置”&gt;“Wi-Fi”&gt;“当前连接的Wi-Fi网络”&gt;“代理”&gt;“手动”来进行配置。 开始抓包开始抓包：一旦你的设备代理已经配置好，Mitmproxy就会自动开始捕获HTTP和HTTPS流量。你可以在Mitmproxy的控制台中查看所有的请求和响应。你还可以使用一些Mitmproxy提供的快捷键，如使用“tab”键切换到请求/响应窗格，使用“e”键编辑请求，使用“w”键保存请求和响应等等。 导出数据导出数据：在完成抓包后，你可以将数据导出为不同的格式，例如HAR文件、PCAP文件或CSV文件，以便在其他工具中进行分析。 需要注意的是，抓包可能会涉及到隐私问题，请确保在合适的环境下使用该工具，并尊重他人的隐私。"},{"title":"【css】重排与重绘","date":"2023-03-22T03:21:30.000Z","url":"/2023/03/22/cphch/","tags":[["css","/tags/css/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、从输入url到渲染出页面的整个过程 dns解析： 域名—&gt;IP 浏览器根据IP地址向服务器发起http请求 服务器处理http请求，并返回给浏览器 根据HTML生成Domtree，根据Css生成cssom，再整合dom树和cssom整合的rendertree 根据render tree渲染页面 遇到script标签则暂停渲染，优先加载并执行js代码，完成再继续，直至渲染完成。 渲染：在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。 重排会导致重绘 重绘：某些元素的外观被改变，例如：元素的填充颜色 重排：重新生成布局，重新排列元素。 改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。 所以： 重绘不一定导致重排，但重排一定会导致重绘。 重排(reflow)：概念：当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 重排也叫回流，简单的说就是重新生成布局，重新排列元素。 下面情况会发生重排： 页面初始渲染，这是开销最大的一次重排 添加/删除可见的DOM元素 改变元素位置 改变元素尺寸，比如边距、填充、边框、宽度和高度等 改变元素内容，比如文字数量，图片大小等 改变元素字体大小 改变浏览器窗口尺寸，比如resize事件发生时 激活CSS伪类（例如：:hover） 设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。 常见引起重排属性和方法 – – – width height margin padding display border-width border position overflow font-size vertical-align min-height clientWidth clientHeight clientTop clientLeft offsetWidth offsetHeight offsetTop offsetLeft scrollWidth scrollHeight scrollTop scrollLeft scrollIntoView() scrollTo() getComputedStyle() getBoundingClientRect() scrollIntoViewIfNeeded() 重排影响的范围：由于浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种： 全局范围：从根节点html开始对整个渲染树进行重新布局。 局部范围：对渲染树的某部分或某一个渲染对象进行重新布局 全局范围重排： 当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。 局部范围重排： 用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。 重绘(Repaints):概念：当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 常见的引起重绘的属性： 属性： – – – color border-style visibility background text-decoration background-image background-position background-repeat outline-color outline outline-style border-radius outline-width box-shadow background-size 重排优化建议：重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。 减少重排范围我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。 尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。 减少重排次数1.样式集中改变不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 cssText 变量中编辑。虽然现在大部分现代浏览器都会有 Flush 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。 2.分离读写操作DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。 原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制： 当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。 3.将 DOM 离线“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做： 使用 display:none 一旦我们给元素设置 display:none 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 display属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，visibility : hidden 的元素只对重绘有影响，不影响重排。 通过 documentFragment 创建一个 dom 碎片,在它上面批量操作 dom，操作完成之后，再添加到文档中，这样只会触发一次重排。 复制节点，在副本上工作，然后替换它！ 4.使用 absolute 或 fixed 脱离文档流使用绝对定位会使的该元素单独成为渲染树中 body 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。 5.优化动画 可以把动画效果应用到 position属性为 absolute 或 fixed 的元素上，这样对其他元素影响较小。 动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多 启用GPU加速 GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。 GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。 在浏览器中查看页面渲染时间1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。如下图 蓝色: 网络通信和HTML解析 黄色: JavaScript执行 紫色: 样式计算和布局，即重排 绿色: 重绘 哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。 2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。如下图： 3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。 4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。"},{"title":"【杂七杂八】mac连接远程服务器","date":"2023-03-21T03:15:20.000Z","url":"/2023/03/21/ljyc/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"方法一：用终端登录终端输入命令： ssh -p 端口号 服务器用户名@ip 如：ssh -p 22 &#x72;&#x6f;&#x6f;&#116;&#x40;&#x31;&#x31;&#53;&#46;&#49;&#x30;&#56;&#x2e;&#x31;&#49;&#x35;&#46;&#49; 回车，初次登录时输入yes确认是否连接 回车，输入密码 回车，登陆成功 方法二：用shell连接在终端中选择如下： 点击加号，添加自己的服务器ip，然后输入用户名，点击连接 输入密码就连接上了。 方法三：其他可视化工具如FileZilla等，输入主机IP、用户名、密码、端口号、点击连接。很快就连接上了。不具体说了。"},{"title":"docker的使用和简介","date":"2023-03-21T02:56:21.000Z","url":"/2023/03/21/dockersy/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"docker简介1：docker定义docker是一个用来装应用的容器，就像杯子可以装水，笔筒可以装笔，书包可以放书一样。你可以把“Hello World！”放到docker中，也可以把网站放到docker中，你可以把任何你想到的程序放到docker中。 2. docker目的docker的主要目标是”Build,Ship and Run any App,Angwhere”,构建，运输，处处运行构建：制作docker镜像，打包容器的所有系统目录文件运输：下载docker镜像运行：基于docker镜像提供的rootfs，启动容器总结：只要能运行docker容器，那么docker镜像中已经安装好的软件也可以运行，所以说docker是一种件的打包技术。 最重要的优点在与docke环境的高度一致性。 Docker与虚拟机的区别：容器时在linux上本机运行，并与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，非常轻量虚拟机运行的是一个完整的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。 3. docker的架构docker三个基本概念： 镜像（Image）：Build – 构建镜像 – [镜像 类比 集装箱]Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：Run – 运行镜像（运行的镜像就是一个容器）- [容器 就是 运行程序的地方]镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：Ship – 运输镜像（从仓库和我们的主机上运输）- [仓库 类比 超级码头]仓库可看着一个代码控制中心，用来保存镜像。 4. docker的运行流程 （1）docker pull:首先客户端client向Docker daemon发送命令docker pull，告诉Docker daemon要拉取哪个镜像，Docker daemon会先在本机检查这个镜像是否存在，如果存在并且版本一致，它不会做任何操作；如果不存在，它会到Docker的镜像仓库中寻找，如果找到了，就会把仓库中的镜像拉取到本地。 （2）docker run:客户端将docker run命令发送到Docker deamon中，Docker deamon会先检查这个镜像是否在本地已经存在，如果不存在，它会到仓库中寻找，把镜像下载到本地，下载之后它会通过一定的方式把镜像运行起来，变成docker容器 二、docker的安装采用yum安装方式，但由自己选择安装版本，需要自己安装docker-ce仓库。 1. 检查系统的内核版本，内核需大于3.10即可uname -r 2. 安装yum仓库管理工具yum-utilsyum -y install yum-utils 3. 安装docker-ce仓库1： 国内docker-ce仓库： 2：国外可直接用官方的docker-ce仓库： 安装后，在/etc/yum.repos.d/可以看到有了docker-ce.repo 文件，docker-ce仓库完成。 4. 查看docker版本并安装可直接安装，也可选择版本安装， 直接yum -y install docker-ce 安装，官方软件源默认启用了最新的软件。 查看版本，选择自己的想要版本安装。查看版本： 安装自己的版本号：docker-ce-[VERSION]，如上图中的docker-ce-3:20.10.7-3.el8安装如下： 安装完成，docker version可查看版本 三. docker的常用命令启动docker： 进入容器 docker run: 创建并启动一个新的容器。 例如： docker run nginx 将在一个新的容器中运行Nginx。 docker start: 启动已经存在的容器，让其重新运行。 docker stop: 停止正在运行的容器。 例如： docker stop container_name 将停止名为“container_name”的容器。 docker rm: 删除一个或多个容器。 例如： docker rm container_name 将删除名为“container_name”的容器。 docker images: 列出本地的Docker镜像。 例如： docker images 将列出本地存储的所有Docker镜像。 docker rmi: 删除本地的Docker镜像。 例如： docker rmi image_name 将删除名为“image_name”的本地Docker镜像。 docker pull: 下载一个Docker镜像，不包含容器。 例如： docker pull nginx 将下载最新版本的Nginx镜像。关于docker pull的更详尽的解释，请看下方其它补充 docker push: 将一个Docker镜像上传到Docker Hub。 例如： docker push username/image_name 将上传名为“image_name”的本地Docker镜像到Docker Hub上的用户名为“username”的仓库中。 docker inspect: 查看Docker容器的详细信息。 例如： docker inspect container_name 将显示名为“container_name”的容器的详细信息。 docker exec: 在正在运行的容器中执行命令。 例如： docker exec -it container_name bash 将在名为“container_name”的容器中打开一个Bash shell。 docker ps: 列出所有正在运行的容器。 例如： docker ps 将列出所有正在运行的容器的详细信息。docker ps -a列出所有正在运行的没在运行的容器。 docker search xxx: 选择安装的镜像，如docker search jenkins,会列出所有的jenkins镜像，然后使用docker pull [name] 安装。 删除镜像后还能在容器中安装镜像，具体的命令就跟容器命令一样，比如说我拉了docker run jenkins，它的容器是linux（这个自动生成的），然后rmi了镜像之后，可以使用shell命令在其中重新安装，就像在linux电脑里一样的。比如想安装apache的话，命令： 删除容器就要重新pull了。 其他补充：1. docker run的细节在一些情况下，Docker会自动完成拉取镜像、创建容器和启动容器的过程，具体取决于您使用的命令和Docker的配置。例如，如果您使用的是 docker run 命令，则Docker将自动完成以下操作： 如果本地不存在指定的镜像，则从默认的镜像仓库（例如Docker Hub）拉取该镜像。 使用指定的镜像创建一个新的容器，并启动该容器。 但是，如果您使用的是 docker create 和 docker start 命令，则需要手动完成这些步骤。 在任何情况下，Docker都会自动完成一些基本的设置和配置，例如创建容器网络、分配IP地址和端口等。但是，一些高级设置和配置可能需要手动完成，例如挂载主机文件、配置容器卷等。 因此，对于每个具体的使用场景，您需要仔细检查Docker命令和配置，并根据需要手动完成必要的步骤。 2. docker run和docker start当容器不存在时，docker run会拉取一个镜像（img）并创建一个容器（container）并运行，也就是说，docker run可以隐式包含docker pull 如果容器已经存在，docker run 和 docker start 也会有不同的作用。docker start 会启动一个已经停止的容器，它的运行时状态与停止之前一样，包括任何已经添加到容器中的文件或数据。docker run 则会创建一个新的容器，并在其中运行指定的命令或应用程序。如果使用的是同一个容器名称，docker run 将会重新创建一个新的容器，而不是启动原来的容器。因此，如果你想启动一个已经存在的容器，应该使用 docker start。如果你想要创建一个新的容器并运行一个新的命令，应该使用 docker run。 3. docker pull 的详尽解释在Docker中，一般的使用流程是先拉取镜像，然后使用镜像创建容器并启动。就是先pull再run。但实际上如果使用的是公共的 Docker Hub 镜像，dockder pull就不是必须的。但是在一些情况下，需要在本地预先拉取镜像，例如： 你需要从一个私有的 Docker Registry 拉取镜像，而该 Registry 可能需要身份验证或者在防火墙之后； 你需要将拉取的镜像进行修改或者自定义操作，然后再创建容器，而不是从 Docker Hub 直接拉取。 因此，在这些情况下，我们需要使用 docker pull 命令来拉取镜像到本地，然后再使用 docker run 命令来创建容器。 4. 如何使用 docker 拉取并运行私人镜像首先，你需要确保你能够访问这个私人镜像。如果这个私人镜像是托管在 Docker Hub 上的，则需要相应的权限。如果是自己搭建的私有镜像库，则需要配置相应的访问权限。 接下来，你可以在命令行中使用以下命令来拉取这个私人镜像： 其中 &lt;私人镜像地址&gt; 是私人镜像的地址，&lt;私人镜像名称&gt; 是私人镜像的名称，&lt;标签&gt; 是镜像的标签。 例如，如果你要拉取一个私人镜像地址为 myregistry.com，镜像名称为 abc，标签为 latest 的镜像，可以使用以下命令： "},{"title":"【移动端】自适应方案","date":"2023-03-20T09:53:43.000Z","url":"/2023/03/20/ydd/","tags":[["css","/tags/css/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"基本概念：设备独立像素（DIP）：逻辑像素，同樣嘅屏幕大小DIP都喺一樣嘅。物理像素（pt）：分辨率，屏幕一行同埋一列分别有幾多像素点leigaa。**设备像素比DPR(Device Pixel Ratio)**：DPR = 物理像素 / 设备独立像素，它通常与视网膜屏(Retina 屏)有关。 适配方案1. px + 自适应缩放（viewport）适用于设计给的设计稿只需要在各种屏幕等比缩放的情况。设置meta viewport的width为设计稿给出的width，使设计稿在不同屏幕上只需要自适应缩放。 如上，就是设计给的设计稿为750px，CSS单位使用px即可。 这个方法写法简便，设计稿是多少就写多少，开发速度很快。可能会有部分特别特别低版本的手机不兼容。这个方法有一个很大的缺点，就是缩放全局等比缩放，有些不想缩放的（比如部分1px边框、文字等）也会因为它的影响而等比缩放。 2. rem适配方案其实属于viewport的过渡方案，所以其实它和第一种viewport方案是一致的。只不过是早年对viewport的兼容性不好，所以早年是使用rem+js去实现自适应缩放。rem：‘The font size of the root element’，就是以根元素 的字体大小为基本单位，是一种相对单位。rem 适配的原理就是以 html 的 font-size 大小为基本单位来布局。em：另一种相对单位，它相对于该元素的本身的 font-size 值来计算。em是可以嵌套计算的，所以容易导致一些奇怪的问题。 假设屏幕750px，设置根元素为100px，即1rem=100px。那么24px的字体，就是0.24rem。在不同屏幕上的缩放就是实际屏幕大小/750px = 实际根元素字体大小/100px所以实际根元素字体大小 = 实际屏幕大小*100px/750px设置根元素100px是为了好计算，直接除以一百就算出来了。设置个奇奇怪怪的值当然也可以按这个比例算。就是可以但没必要~ 这个方法的兼容性很好，在遇到不想缩放的元素时，也可以用px进行设置。就是需要同时用js进行各个屏幕适配，比较麻烦。 3. vw、vh适配vh、vw方案：将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。vw(Viewport’s width)：1vw等于视觉视口的1%vh(Viewport’s height) :1vh 为视觉视口高度的1%vmin : vw 和 vh 中的较小值vmax : 选取 vw 和 vh 中的较大值 如果设计稿是750px宽度。如果视觉视口为750px，那么1vw = 1% = 7.5px，这时UI给定一个元素的宽为75px（设备独立像素），我们只需要将它设置为 75px / 750px = 10% = 10vw。就是酱紫拉~它和屏幕大小没啥关系的。就是百分比 4. 自动计算的插件实际开发过程当中，计算每一个dom元素的vw或者rem是很麻烦的，所以可以使用postcss-px-to-viewport去自动转换。 配置参数默认参数: unitToConvert (String) 需要转换的单位，默认为”px”viewportWidth (Number) 设计稿的视口宽度unitPrecision (Number) 单位转换后保留的精度propList (Array) 能转化为vw的属性列表viewportUnit (String) 希望使用的视口单位fontViewportUnit (String) 字体使用的视口单位selectorBlackList (Array) 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。minPixelValue (Number) 设置最小的转换数值，如果为1的话，只有大于1的值会被转换mediaQuery (Boolean) 媒体查询里的单位是否需要转换单位replace (Boolean) 是否直接更换属性值，而不添加备用属性exclude (Array or Regexp) 忽略某些文件夹下的文件或特定文件，例如 ‘node_modules’ 下的文件landscape (Boolean) 是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape)landscapeUnit (String) 横屏时使用的单位landscapeWidth (Number) 横屏时使用的视口宽度 当然，less、sass也有对此自定义解决的方案，可以自行查看文档。 5. Viewport 方案（推荐） 由于 viewport 单位得到众多浏览器的兼容，lib-flexible 这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用 viewport 来替代此方案。 vw 适配方案的流程： meta 标签设置 viewport 宽度为屏幕宽度； 开发环境配置 postcss-px-to-viewport 或者类似插件； 根据设计稿写样式，元素宽高直接取设计稿宽高即可，单位为 px，插件会将其转换为 vw； 段落文本也按照设计稿写，单位为px，不需要转换为 vw；6. media媒体查询有时候用户需要的更大的屏幕上更多的内容，而不是更大的字，所以在pc、平板一侧主要用到的兼容方式是media媒体查询。 使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。 你也可以针对不同的媒体使用不同样式文件 : 因为这里主要讨论的是移动端，所以media媒体查询的用法不详述了。"},{"title":"【grid】简单总结","date":"2023-03-15T10:04:24.000Z","url":"/2023/03/15/cxy/css/grid/","tags":[["css","/tags/css/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、易记点整理父： 子： 属性关键字： auto-fill 和 auto-fit 的区别auto-fill和auto-fit都是CSS的repeat()函数的扩展值，用于自动填充和调整网格项目的数量。 auto-fill会自动填充网格容器，尽可能多地填充项目，而不考虑项目的大小。它会在一个网格轨道上放置尽可能多的项目，然后通过增加网格行或列来添加更多项目。这意味着它会在网格轨道上尽可能多地放置项目，直到没有更多项目可以放置为止。因此，它可以在轨道中留下一些空间，因为不会强制填充整个轨道。 例如，如果我们有一个网格容器和一个项目，这个项目的大小是200像素，我们使用auto-fill并设置每个轨道的大小为250像素，那么这个项目将占用整个轨道，因为它可以在轨道上放置一个完整的项目。 auto-fit会调整网格项目，以使网格填满容器，而不考虑项目的数量。它会在网格轨道上放置尽可能多的项目，但如果剩下的空间不能容纳一个完整的项目，它将缩小项目的大小，以使它们适合空间。这意味着它会填充整个轨道，因此不会在轨道中留下空间。 例如，如果我们有一个网格容器和一个项目，这个项目的大小是200像素，我们使用auto-fit并设置每个轨道的大小为250像素，那么这个项目将被缩小，以适合轨道，并留下50像素的空间。 因此，auto-fill和auto-fit的区别在于它们处理空间的方式不同。auto-fill会填充整个轨道，但是可能留下一些空间，而auto-fit则会完全填充整个轨道，但可能会缩小项目的大小来适合空间。 二、 grid布局(1) 基本使用 上面代码意思是三行三列的布局，行宽100px，高100px，也可以使用百分比 也可以这么简写： repeat() 函数有两个参数，第一个是重复的次数，第二个是具体数值 三、容器属性：(2) auto-fill有时候，单元格大小固定，而容器大小不一定，可以用auto-fill指定一行/列尽可能放入更多的元素 (3) frgrid布局为了方便表示比例，引入fr，如果一个设置1fr，一个设置2fr，那后者就是前者的两倍 上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。 (4) autoauto参数表示由浏览器自动决定宽高 (5) 行和列的线可以自己命名，用[名字] 网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 (6) 设置行与行、列与列的间距grid-row-gap 与 grid-column-gap，行与列的间距。grid-gap: grid-row-gap 与 grid-column-gap的简写，两个值。格式：grid-gap: 行 列根据最新标准，grid-row-gap、grid-column-gap的新写法是去掉grid-前缀。 (7) grid-template-areas可以给各个网格取名，如果不需要利用该网格，则用.代替 可以给各个网格取名，如果不需要利用该网格，则用.代替 (8) grid-auto-flow子元素按照顺序自动放置在网格内，默认先行后列，设为列的话 (9) justify-items align-items值为start center end strech(拉伸占满整个容器，如果有设置width或height则对应拉伸失效) (10) justify-content align-content设置整个内容区域在容器里面的水平位置(左中右) 四、容器内部的元素属性(1) grid-column-start grid-column-end grid-row-start grid-row-end设置某个子元素在第几个网格线内 子元素在横向第二根网格线，竖向倒数第一根网格线内。 (2) grid-area，设置某元素在某个单元格中 (3) justify-self align-self place-self和父元素的justify-items align-items 一致。只不过一个设置在父元素上，作用于所有子元素。一个是设置在子元素上，只对单个子元素有效。 place-self用来同时设置justify-self align-self，简写justify-self align-self"},{"title":"【flex】简单总结","date":"2023-03-15T10:02:02.000Z","url":"/2023/03/15/cxy/css/flex/","tags":[["css","/tags/css/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、容器属性1. justify-contentflex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 2. align-itemsflex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3. flex-flowflex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 4. flex-wrap 换行nowrap（默认）：不换行。wrap：换行，第一行在上方。wrap-reverse：换行，第一行在下方。 5. align-content多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 6. flex-directionrow（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 二、子元素属性1. order 排列顺序数字 2. flex-grow 剩余空间的项目放大比例flex-grow: 0 表示项目剩余空间不分配。 flex-grow: 1: 表示项目剩余空间按比例分配至自适应父元素宽度。 数字越大拉伸越严重 2. flex-shrink 剩余空间的项目缩小比例子元素未超出空间，设置无效。 当子元素总宽度超出了容器时，收缩比例。 flex-shrink: 0 表示项目即使超出也不压缩。 flex-shrink: 1: 表示项目按比例压缩至自适应父元素宽度。 数字越大压缩越严重 3. flex-basis 分配剩余空间前，该子元素的占据尺寸。优先级高于flex-grow和flex-shrink 若flex-basis: 0，则该元素按自身内容自适应，无视被设置的width。 可以为具体数值，比如flex-basis: 150px 4. flex2/3/4的简写 设置flex：1（相当于flex: 1 0 0或flex-grow: 1），可以让项目自适应到父元素的宽度。 设置flex: 0，可以让子元素无视被设置的宽度，自适应到内部元素的宽度。 5. align-self子元素的默认对齐方式 三、其他假设有这样的div结构： 默认情况下，子元素的宽度由他们的内容决定，即使在设置了父元素的总宽度的情况下，也只是根据内容自适应。 默认情况下，若子元素总宽度超出父元素，则自适应收缩到父元素宽度。 若有单独的子元素有设置宽度，则按比例收缩 若子元素宽度未超出父元素，则flex-shrink失效。 设置flex: 0，可以让子元素无视被设置的宽度width，自适应到内部元素的宽度。（相当于flex-basis: 0） flex-basis的优先级大于width flex-shrink: 0，表示无视容器宽度，被设置的子元素永不收缩，即使超出父容器。 flex-basic、flex-grow和flex-shrink的优先级： 要注意一点，flex-basis是最先被设置的属性，但这并不代表生效的优先级最高，flex-basis优先级必定大于flex-grow和width，但和flex-shrink比起来，优先级不一定是最高的。所以说并不是flex-basic设置后，flex-shrink就无效了。 项目首先会按照flex-basis的值进行设置，优先级高于flex-grow与width 如果剩余空间不足以容纳所有项目的 flex-basis 尺寸之和，并且某些项目的 flex-shrink 值大于 1，那么这些项目会按照其 flex-shrink 值收缩，以适应剩余空间。 如果剩余空间仍然不足，那么项目的 flex-basis 属性值将影响哪些项目更容易受到收缩。具体来说，flex-basis 的值较大的项目更不容易受到收缩，因为它们需要更多的剩余空间才能保持其初始尺寸。 若flex-basis: 0，则该元素按自身内容自适应，无视被设置的width。（相当于flex: 0） "},{"title":"react-hooks","date":"2023-03-14T09:11:14.000Z","url":"/2023/03/14/cxy/cxydeziwoxiuyang2/framework/react/react-hooks/","categories":[["undefined",""]],"content":"一、基本介绍react是基于数据是不可变的（每次setState都会返回一个新数据），这也是为什么需要setState()来更新数据而不能使用像vue的this.state = newState的形式更新数据的原因，其实你用this.state=newState确实可以改数据，但是react不知道数据变了。 二、useMemo、useCallback的执行时机对比useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。 三、useEffect 和 useMemo 区别useEffect是在DOM改变之后触发，useMemo在DOM渲染之前就触发useMemo是在DOM更新前触发的，就像官方所说的，类比生命周期就是[shouldComponentUpdate]useEffect可以帮助我们在DOM更新完成后执行某些副作用操作，如数据获取，设置订阅以及手动更改 React 组件中的 DOM 等不要在这个useMemo函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo在useMemo中使用setState你会发现会产生死循环，并且会有警告，因为useMemo是在渲染中进行的，你在其中操作DOM后，又会导致触发memo 三、useMemo可以把它理解成vue里面的computed，是一种数据的缓存，而这个缓存依赖后面的第二个参数数组。 如果页面上展示的数据是通过某些state计算得来的一个数据，那么你每次这个组件里面无关的state变化引起的重新渲染，都会导致这个数据重新计算。 这时候就需要用useMemo(()=&gt;&#123;&#125;, [])去包裹你的计算的方法体，这样那些无关的state改变引起的渲染不会重新计算这个方法体，而是返回之前计算的结果，达到一种缓存的效果。 四、useCallbackuseCallback跟useMemo比较类似，但它返回的是缓存的函数。 使用场景：有一个父组件，其中包含子组件，子组件接收一个函数作为props；通常而言，如果父组件更新了，子组件也会执行更新；但是大多数场景下，更新是没有必要的，我们可以借助useCallback来返回函数，然后把这个函数作为props传递给子组件；由于useCallback返回的函数实例在第二个参数，也就是依赖项未发生变化时不会被重新创建，因此，每次父组件的更新不会导致子组件内部的函数实例发生变化。这样，子组件就能避免不必要的更新。 useCallback一般要配合React.memo来使用：react的Hooks组件对props的浅比较是在memo里面比较的（类组件是在shouldComponentUpdate里面），如果没有memo，那么你使用useCallback就没啥意义，反而浪费性能（因为useCallback来包裹函数也是需要开销的）。因为子组件还是会重新渲染。 React.memo与useMemo的区别和联系在React的组件中，如果子组件没有被React.memo包裹，或者没有使用useMemo来处理props传递参数，那么当父组件的任何值更新时，整个组件都将会进行重新渲染，包括父组件下面的所有子组件。多数情况下对于子组件来说没有必要。毕竟不是父组件的每一次更新都需要修改子组件的值，而频繁的更新却会导致不需要更新的子组件被迫更新，造成资源的浪费。针对上述问题，React提供了React.memo和useMemo。 React.memo：React.memo()本质是一个高阶组件（HOC），高阶组件和高阶函数类似，高阶函数是接收一个函数，然后经过一些判断和处理后再返回这个函数。对应到高阶组件，就是接收一个组件，然后经过一些判断和处理后再返回这个组件。再回归到React.memo(), 这个高阶组件接收一个组件A作为参数并返回一个组件B，如果组件B的props没有改变，则组件B会阻止组件A重新渲染。A和B本质上是同一个组件，但A是否进行重新渲染，需要由Props是否发生改变来决定。 useMemo：React提供的一个hook函数，他不是高阶组件。使用useMemo定义的变量，只会在useMemo的第二个依赖参数发生修改时才会发生修改。使用useMemo时，应保证第一个参数函数里所使用的变量都出现在第二个依赖参数数组中，这样可以避免一些额外的错误。 "},{"title":"typescript总结笔记（7）配置文件、命令行、双斜线指令","date":"2023-03-11T11:44:13.000Z","url":"/2023/03/11/typescript7/","tags":[["typescript","/tags/typescript/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、配置文件 tsconfig.json哎呀，懒得写了，反正常用配置就那几个 &quot;compilerOptions&quot;：这是最重要的部分，用于配置 TypeScript 编译器的选项。以下是一些常见的选项： &quot;target&quot;：指定目标 ECMAScript 版本。常见的选项包括 &quot;ES5&quot;、&quot;ES6&quot;、&quot;ESNext&quot; 等。 &quot;module&quot;：指定模块系统，常见的选项包括 &quot;CommonJS&quot;、&quot;ES6&quot;、&quot;UMD&quot;、&quot;AMD&quot; 等。 &quot;outDir&quot;：指定编译输出目录。 &quot;strict&quot;：启用严格模式，包括严格的类型检查和空检查。 &quot;esModuleInterop&quot;：启用 ES 模块的互操作性。 &quot;jsx&quot;：指定 JSX 支持，常见选项包括 &quot;react&quot; 和 &quot;preserve&quot;。 &quot;include&quot; 和 &quot;exclude&quot;：这两个选项用于指定哪些文件应该包含在编译中，以及哪些文件应该排除在外。它们可以使用通配符模式来匹配文件。 &quot;files&quot;：如果不使用 &quot;include&quot; 和 &quot;exclude&quot;，可以使用 &quot;files&quot; 选项明确列出要编译的文件。 &quot;extends&quot;：可以继承其他 tsconfig.json 文件的设置，以便在多个项目中共享通用配置。 &quot;includeDeclarations&quot;：如果需要生成 .d.ts 声明文件，可以启用此选项。 &quot;types&quot; 和 &quot;typeRoots&quot;：用于管理类型声明文件的依赖和搜索路径。 &quot;baseUrl&quot; 和 &quot;paths&quot;：用于配置模块解析路径别名，便于导入模块。 &quot;rootDir&quot; 和 &quot;composite&quot;：用于配置项目的根目录和启用项目引用。 二、命令行其实常用命令一样就那几个 编译 TypeScript 文件： 这将编译指定的 TypeScript 文件（file.ts）并生成对应的 JavaScript 文件。 编译整个项目： 如果你在项目的根目录中有一个 tsconfig.json 配置文件，运行 tsc 命令将会编译整个 TypeScript 项目，根据配置文件中的设置进行编译。 使用不同的配置文件编译项目： 这将使用指定的自定义配置文件（customconfig.json）来编译 TypeScript 项目。 监视模式： 使用 -w 选项启动 TypeScript 编译器的监视模式，它会自动监视文件的更改并在保存时重新编译。 生成声明文件（.d.ts）： 使用 --declaration 选项生成 TypeScript 声明文件（.d.ts），这对于发布 TypeScript 库非常有用。 生成 Source Maps： 使用 --sourceMap 选项生成 JavaScript 的 Source Map 文件，以便在调试时将编译后的 JavaScript 映射回 TypeScript。 指定输出目录： 使用 --outDir 选项指定编译输出文件的目录。 删除编译结果： 使用 --clean 选项删除先前的编译结果。 三、双斜线指令以下是一些常见的双斜线指令示例： // @ts-ignore： 这个指令告诉 TypeScript 编译器忽略下一行代码的类型检查错误。 // @ts-check： 这个指令告诉 TypeScript 编译器检查下一行代码的类型，并在存在错误时报告错误。 // @ts-nocheck： 这个指令告诉 TypeScript 编译器在接下来的代码中禁用类型检查，直到遇到下一个指令（如@ts-check）。 // @ts-expect-error 和 // @ts-expect-error 1234： 这个指令告诉 TypeScript 编译器期望在接下来的代码中报告错误。你可以提供一个错误代码（如 1234）来指定期望的错误。 JSDoc TypeScript 直接处理 JS 文件时，如果无法推断出类型，会使用 JS 脚本里面的 JSDoc 注释。 我没用过，先不写了。用到了看官网吧。 "},{"title":"typescript总结笔记（8）常见面试题","date":"2023-03-11T11:44:13.000Z","url":"/2023/03/11/typescript8/","tags":[["typescript","/tags/typescript/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"前端八股文"},{"title":"typescript总结笔记（6）声明文件与声明语句","date":"2023-03-10T14:21:13.000Z","url":"/2023/03/10/typescript6/","tags":[["typescript","/tags/typescript/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、声明文件与声明语句1. 声明语句 declare declare 关键字用来告诉编译器，某个类型是存在的，可以在当前文件中使用。 declare 只通知编译器某个类型是存在的，不用给出具体实现。 declare 只能用来描述已经存在的变量和数据结构，不能用来声明新的变量和数据结构。 所有 declare 语句都不会出现在编译后的文件里面。 场景declare 关键字可以给出外部变量的类型描述，主要场景为下面两个： 用于声明第三方库或模块的类型：比如说引入第三方npm包时，若他们没有提供.d.ts文件。以jQuery为例，typescript将不知道如何处理jQuery对象，这时可以声明 现在，当你在项目中使用 jQuery 时，TypeScript 将知道它的类型信息，以便进行类型检查。 与非 TypeScript 代码集成：有些js库不包含ts代码，也没有声明文件（*.d.ts），需要自己书写声明文件（*.d.ts），此时在声明文件中声明全局变量，让typescript知道这些变量的类型。 可使用declare声明的类型 声明外部变量 declare var 和 declare let 使用方法： **声明function **declare function 声明class declare class 声明模块和命名空间 declare namespace 和 declare module **声明js原生属性和方法 ** declare global 为 JavaScript 引擎的原生对象添加属性和方法，可以使用declare global &#123;&#125;语法。 使用： 当然，必须要在tsconfig中的include或files中进行引入。 声明文件比较多时，可以使用三斜线指令（下面会说）···/// ··· 声明enmu declare enmu 2. 声明文件 .d.ts2.1 概念一般来说，声明语句会被放到一个单独的文件（*.d.ts）中，这就是声明文件。 2.2 第三方声明文件第三方库一般提供了声明文件，如jQuery。安装第三方声明文件的方法是： 如jQuery的声明文件 一般来说typescript可以自动识别@types/ 的声明文件并加载，但如果官方未提供声明文件，但社区有提供，此时想更改编译选项，可以在tscofig中配置： 补充一点ts查找声明文件的顺序： 首先会查找 typeRoots 中指定的目录，以查找自定义的声明文件。 然后，会查找 types 中指定的声明文件，这通常是用于引入官方声明文件或项目内部的自定义声明文件。 最后，会继续查找 node_modules/@types 目录下的官方声明文件。 2.3 项目自动生成声明文件tsconfig中，配置&quot;declaration&quot;: true ，编译 时会 自动生成 。 或命令行 2.4 内置声明文件在安装typescript的文件夹内（一般是项目的node_modules/typescript中），会有lib文件夹，提供了一些常见的声明文件。 可以在tsconfig中启用 2.5 自己书写声明文件如果既没有官方声明文件，也没有第三方社区声明文件，那只好自己写了。 declare在上面👆🏻"},{"title":"typescript总结笔记（3）装饰器","date":"2023-03-09T13:42:13.000Z","url":"/2023/03/09/typescript3/","tags":[["typescript","/tags/typescript/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、装饰器介绍装饰器是一种特殊的语法，它允许你在不修改原始代码的情况下，向类、方法、属性或参数添加额外的功能或元数据。 装饰器通常以 @ 符号开头，是一个方法。然后应用于目标（类、方法、属性或参数）。 装饰器方法的参数 在类装饰器中： target：表示被装饰的类本身，通常是类的构造函数。你可以在类装饰器内部访问和操作整个类的构造函数和原型。 在方法装饰器中： target：表示被装饰方法所属的类的原型对象。你可以在方法装饰器内部访问和操作类的原型以及方法名。 methodName：表示被装饰的方法的名称。 descriptor：表示被装饰方法的属性描述符，包括方法的配置。 在属性装饰器中： target：表示被装饰属性所属的类的原型对象。你可以在属性装饰器内部访问和操作类的原型以及属性名。 propertyName：表示被装饰的属性的名称。 descriptor：表示被装饰属性的属性描述符，包括属性的配置。 在参数装饰其中： target：表示被装饰参数所属的类的原型对象。你可以在参数装饰器内部访问和操作类的原型以及参数所属的方法名。 methodName：表示包含参数的方法的名称。 类装饰器 方法装饰器这里是一个日志记录方法装饰器的示例，作用为在方法调用前后记录日志。 属性装饰器这里是一个属性验证属性装饰器的示例，验证属性的值是否为数字。 参数装饰器这里是一个参数日志参数装饰器的例子，用来记录方法参数的值。 ，"},{"title":"typescript总结笔记（4）类型工具、类型映射、类型运算符","date":"2023-03-09T13:42:13.000Z","url":"/2023/03/09/typescript4/","tags":[["typescript","/tags/typescript/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、类型工具TypeScript 提供了一些内置的类型工具，用来方便地处理各种类型，以及生成新的类型。 Exclude&lt;T, U&gt; 从 T 中排除出可分配给 U的元素。 Omit&lt;T, K&gt; 的作用是忽略T中的某些属性。 Merge&lt;O1, O2&gt; 是将两个对象的属性合并。 Compute&lt;A &amp; B&gt; 是将交叉类型合并 Intersection&lt;T, U&gt;的作用是取T的属性,此属性同样也存在与U。 Overwrite&lt;T, U&gt; 是用U的属性覆盖T的相同属性。 Pick&lt;Type, Keys&gt;Pick&lt;Type, Keys&gt;返回一个新的对象类型，第一个参数Type是一个对象类型，第二个参数Keys是Type里面被选定的键名。 上面示例中，Pick&lt;Type, Keys&gt;会从对象类型A里面挑出指定的键名，组成一个新的对象类型。 指定的键名Keys必须是对象键名Type里面已经存在的键名，否则会报错。 上面示例中，对象类型A不存在键名z，所以报错了。 Pick&lt;Type, Keys&gt;的实现如下。 Omit&lt;Type, Keys&gt;Omit&lt;Type, Keys&gt;用来从对象类型Type中，删除指定的属性Keys，组成一个新的对象类型返回。 上面示例中，Omit&lt;Type, Keys&gt;从对象类型A里面删除指定属性，返回剩下的属性。 指定删除的键名Keys可以是对象类型Type中不存在的属性，但必须兼容string|number|symbol。 上面示例中，对象类型A中不存在属性z，所以就原样返回了。 Omit&lt;Type, Keys&gt;的实现如下。 Exclude&lt;UnionType, ExcludedMembers&gt;Exclude&lt;UnionType, ExcludedMembers&gt;用来从联合类型UnionType里面，删除某些类型ExcludedMembers，组成一个新的类型返回。 Exclude&lt;UnionType, ExcludedMembers&gt;的实现如下。 上面代码中，等号右边的部分，表示先判断T是否兼容U，如果是的就返回never类型，否则返回当前类型T。由于never类型是任何其他类型的子类型，它跟其他类型组成联合类型时，可以直接将never类型从联合类型中“消掉”，因此Exclude&lt;T, U&gt;就相当于删除兼容的类型，剩下不兼容的类型。 Extract&lt;Type, Union&gt;Extract&lt;UnionType, Union&gt;用来从联合类型UnionType之中，提取指定类型Union，组成一个新类型返回。它与Exclude&lt;T, U&gt;正好相反。 如果参数类型Union不包含在联合类型UnionType之中，则返回never类型。 Extract&lt;UnionType, Union&gt;的实现如下。 Partial&lt;Type&gt;Partial&lt;Type&gt;返回一个新类型，将参数类型Type的所有属性变为可选属性。 Partial&lt;Type&gt;的实现如下。 Readonly&lt;Type&gt;Readonly&lt;Type&gt;返回一个新类型，将参数类型Type的所有属性变为只读属性。 Required&lt;Type&gt;Required&lt;Type&gt;返回一个新类型，将参数类型Type的所有属性变为必选属性。它与Partial&lt;Type&gt;的作用正好相反。 Required&lt;Type&gt;的实现如下。 上面代码中，符号-?表示去除可选属性的“问号”，使其变成必选属性。 相对应地，符号+?表示增加可选属性的“问号”，等同于?。因此，前面的Partial&lt;Type&gt;的定义也可以写成下面这样。 Record&lt;Keys, Type&gt;构造一个类型，它的所有key是Keys类型，所有value是Type类型 "},{"title":"typescript总结笔记（5）命名空间、模块","date":"2023-03-09T13:42:13.000Z","url":"/2023/03/09/typescript5/","tags":[["typescript","/tags/typescript/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、命名空间和模块1. 命名空间的意义原先叫内部空间。 当多人开发同一文件时可能会造成重名或覆盖等问题。此时可以使用namespace在同一文件里进行不同开发。即使方法名称相同，但在不同的namespace中就可以避免互相覆盖。 namespace中定义的东西只能在该namespace中使用。若需要在外部使用则需要先export 在别的namespace中使用该namespace的方法，需要import，import可以在namespace外使用。 namespace可以导出到其他文件使用，方法有两种： 可以使用模块（原先叫外部空间）导出与导入（export与import）， 还有一种不是很推荐的方法，用三斜线指令导入。/// &lt;reference path = &quot;SomeFileName.ts&quot; /&gt; 其实命名空间导出到其他文件使用这种事情，我本身就不是很推荐。。。这种情况可以直接用模块了。 代码演示： 2. 模块原先叫外部空间。 export import，如果说命名空间是在一个文件内的模块化，那外部空间就是文件与文件之间的模块化。 没啥好说的，和js一样。之前写过。"},{"title":"typescript总结笔记(2)","date":"2023-03-08T11:24:13.000Z","url":"/2023/03/08/cxy/cxddeziwoxiuyang1/js/typescript2/","tags":[["typescript","/tags/typescript/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、函数类型表达式描述函数可以使用函数类型表达式。格式： 比如在接口中使用 或使用类型别名（type）定义一个函数类型 调用签名由于在js中，函数不仅可以被调用，函数本身也可以具有属性值。用函数类型表达式无法支持声明属性，这时候可以使用调用签名格式： 具体应用： 构造签名即，使用new Function时的用法，构造函数。说实话，我没看太懂 泛型函数定义一个函数，返回数组的第一个元素。由于数组的类型不一定，用any没有用泛型好。泛型和强制类型转换都是尖括号&lt;&gt;，泛型放在变量后，强制类型转换放在变量前。 二、对象类型三、泛型 四、工具类型1. Partial构造一个类型，所有的属性均为可选。 2. Required构造一个类型，所有的属性均为必选 3. Readonly构造一个类型，所有的属性均为只读 4. Record&lt;Keys, Type&gt;构造一个类型，它的所有key是Keys类型，所有value是Type类型 5. Pick&lt;Type, Keys&gt;构造一个类型，保留Type中的Keys属性。 6. Omit&lt;Type, Keys&gt;构造一个类型，从Type中过滤掉Keys属性 7. Exclude&lt;UnionType, ExcludedMembers&gt;构造一个类型，从UnionType中排除所有可以赋给ExcludedMembers的类型。其中UnionType和ExcludedMembers都是联合类型。 8. Extract&lt;Type, Union&gt;构造一个类型，从Type中提取所有可以赋给Union的类型"},{"title":"【vue3】总结","date":"2023-02-27T10:16:25.000Z","url":"/2023/02/27/cxy/cxydeziwoxiuyang2/framework/vue/vue3/","tags":[["vue","/tags/vue/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" Vue3和Vue2的区别 Vue3支持2的大多数写法 更好的支持Typescript 使用Proxy代替了defineProperty 重写了虚拟dom的实现，及Tree Shaking的实现。 从Option api变成Composition api setup ref和reactive computed和watch provide和inject 生命周期的更改 新组件 Fragment Teleport Suspense 其他 全局api的修改 原来的全局api转移到应用对象 模板语法修改 一、新建 或 二、Composition API（组合式API）和Options API1. Composition API带来了什么？ 代码组织的更加整齐 逻辑复用做的更加清晰 更好的类型推导 composition api可以将声明的变量和方法等放在一起，这样会使代码更整齐，也方便逻辑复用。 2. 如何选择？ 最好不要共用Options API和Compositions API 小型项目就用Options API，逻辑复杂用Composition API Compositon API 就像 Hooks在React 三、 组合式api1. refref用来定义基本数据类型的响应式。 备注：ref也可以用来定义对象或数组类型数据，它内部会自动通过 reactive 转为代理对象。 在setup中使用value去获取值，在vue模板中直接使用变量名去获取。 ref 可以用来获取dom元素在dom上绑定ref=xxx，在 setup 中定义 xxx就是dom元素。当然，绑定在组件上就可以获取组件的元素和方法。 2. reactivereactive用来定义多个对象的响应式。 3、reactive和ref的区别3.1. 定义数据角度对比：ref 用来定义：基本类型数据reactive 用来定义：引用类型，例如对象、或数组类型的数据 3.2. 原理角度对比：ref通过 Class 的 get 与 set 来实现响应式的（数据劫持）reactive 通过使用 Proxy 来实现响应式（数据劫持），并通过Reflect 操作源对象内部的数据。 3.3. 使用角度对比：ref 定义的数据：操作数据需要 .value,读取数据时模版中直接读取不需要 .valuereactive 定义的数据：操作数据与读取数据，均不需要 .value 3.4. reactive和ref的关系如果用ref对象/数组，内部会自动将对象/数组转为reactive的代理对象。 5. setup5.1. setup的执行时机在vue2的beforeCreate的生命周期之前执行，且只执行一次。setup执行时，当前组件未创建，所以没有this 5.2. setup(props,context)setup函数的第一个参数为props，props不可以解构，如果解构会导致props失去响应式。setup函数的第二个参数为context，context可以解构，解构后为 即： 或者： 都是ok的。在中，引入defineProp使用props 6. computed 7. watchwatch有三个参数，第一个是监听的变量。（如果有多个变量想同时监听，可以使用数组）第二个是函数，可以监听到旧值与新值。第三个参数可以配置deep、immediate等 8. watchEffect立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。第一个参数是一个方法，方法的参数可以用来清理无效的副作用，清理回调会在该副作用下一次执行前被调用。第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。 flush的值默认情况下，侦听器将在组件渲染之前执行。 设置 flush: &#39;post&#39; 将会使侦听器延迟到组件渲染之后再执行。在某些特殊情况下 (例如要使缓存失效)，可能有必要在响应式依赖发生改变时立即触发侦听器。这可以通过设置 flush: &#39;sync&#39; 来实现。（该设置应谨慎使用，因为如果有多个属性同时更新，这将导致一些性能和数据一致性的问题。） 所以它经常被用来： 观察反应变量的变化 允许开发者执行副作用 提供一种取消副作用的方法（以防状态无效）watch和watchEffect之间的区别： watch可用于延迟触发副作用（watchEffect总是立即的）。 watchEffect自动监视任何状态更改的更改（watch必须提供一个或多个要监视的变量）。 watch提供对当前值和先前值的访问。 watch也可以用来监听非响应式的数据，但写法比较麻烦。 vue3 的 hooks（vue2的mixin）vue3在共享数据的时候，用的是hooks的方法。比如我想实现一个方法，在鼠标移动时去获取鼠标的坐标定义一个js/ts模块，封装useMousePosition 在某个vue组件中，直接用引入的方式调用 9. toRefstoRefs 可以将每一个响应式对象变为一个普通对象，该普通对象的每一个property都是一个ref。 toRefs解决问题的场景：使用reactive去定义响应式对象的时候，如果对象层级较多，写起来会显得不简洁，而如果使用...解构赋值的话，对象的属性又会失去响应式。 为了解构赋值的时候不失去响应式，可以使用toRefs将响应式对象内部的所有变量变成响应式的。 不过这种方式现在在script setup中基本没有好的实现方法，只能在setup()里面用用。。 10. toRef()toRef(obj,&#39;propname&#39;)可以将reactive的某一个属性转换为Ref 11. isRef()检查某个值是否为ref 四、组合式api 进阶1. shallowReactive和shallowRefshallowReactive包装对象，只让对象的第一层有响应。shallowRef包装对象，是生成一个非响应式的对象，就是说将对象重新赋值是可以有响应式的，但为对象的任意属性赋值都是没有响应式的。（可是就我自己实验观察。。好像ShallowRef也可以触发第一层的响应）shallowRef包装基本类型，和Ref用法一样。shallowRef官网的例子 shallowReactive 官网的例子 因为有疑惑，所以自己的代码先不贴了。 2. triggerRef()强制触发依赖于一个浅层 ref 的副作用，这通常在对浅引用的内部值进行深度变更后使用。 3. readonly、shallowReadonly、isReadonlyreadonly()接受一个对象 (不论是响应式还是普通的) 或是一个ref，返回一个原值的只读代理。只读代理是深层的。 readonly() shallowReadonly只有表层是只读的isReadonly判断某个变量是不是只读的 shallowReadonly 4. toRaw() markRaw()toRaw 把代理的响应式对象变为了普通对象 markRaw 将一个对象标记为不可被转为代理。返回该对象本身。 5. customRef()创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。myRef接收一个值，返回customRef函数的执行 结果，这个函数接收2个参数，一个track（追踪）,一个trgger(触发)。返回一个存储器对象，有个get和set方法，取值时执行get,赋值时执行set。 官网写了一个防抖的例子。 6. Fragment（碎片）和Teleport（瞬移）Fragment：vue3不需要根标签了。Teleport：让组件的html可以在父组件外的特定标签下面插入展示。（比如body） 用 标签将子组件内的一部分内容包裹，那么这部分内容就会在body中展示。 7. Suspense比如页面里面要做一些异步操作，或者说调一些异步组件，这时候可能会出现等待的情况，那么在等待过程中，可以使用suspense渲染一些后备内容。"},{"title":"【复习整理】vue生命周期","date":"2023-02-07T03:30:34.000Z","url":"/2023/02/07/vue-smcq/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、vue2的生命周期vue生命周期分别有创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载利用钩子函数完成对应的项目效果 beforeCreate( 创建前 )在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据 created ( 创建后）在实例创建之后使用，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。完成了data 数据的初始化。因为未挂载，所以el不可用。 可以使用数据，更改数据，在这里更改数据不会触发updated函数。 beforeMount (挂载前)在挂载开始之前被调用,在这个阶段是获取不到dom操作的,把data里面的数据和模板生成html，完成了data等初始化,注意此时还没有挂在html到页面上 mounted (挂载后)用于挂载之后使用，这时 el 被新创建的 vm.$el 替换了。在这个时候可以获取到dom操作，也可以通过vm.$el获取元素。比如可以获取到ref等，操作dom，在这个时候只能调用一次ajax，在这个时候el和data都可以获取的到注意这个不能保证所有子元素挂载完成了！vm.$el：vue实例使用的dom根元素。 beforeUpdate (更新前)在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。 updated (更新后)在由于数据更改导致地虚拟DOM重新渲染并更新完毕之后会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，但是在服务器端渲染期间不被调用，可以用于监听某些数据的时候使用钩子 beforeDestroy（销毁前）实例销毁之前调用。在这一步，实例仍然完全可用。可以用于销毁计时器时候使用，为了防止跳转到其它页面该事件还在执行，还可以清除dom事件等 destroy（销毁后）实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。 activated被 keep-alive 缓存的组件激活时调用。 deactivated被 keep-alive 缓存的组件失活时调用。 二、vue3的生命周期大多相同，只是将beforeCreate和created合并成了setup，并且新增了renderTracked与renderTriggered，并且将destroy和beforeDestory改成了unmounted和beforeUnmounted renderTracked在一个响应式依赖被组件的渲染作用追踪后调用。这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。 renderTriggered在一个响应式依赖被组件触发了重新渲染之后调用。这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。 serverPrefetch当组件实例在服务器上被渲染之前要完成的异步函数。 Vue2————–vue3beforeCreate -&gt; setup()created -&gt; setup()beforeMount -&gt; onBeforeMountmounted -&gt; onMountedbeforeUpdate -&gt; onBeforeUpdateupdated -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed -&gt; onUnmountedactivated -&gt; onActivateddeactivated -&gt; onDeactivatederrorCaptured -&gt; onErrorCaptured 父子组件生命周期的调用顺序created：先初始化父组件，再初始化子组件mounted：先渲染子组件，再渲染父组件beforeupdated：先调用父组件，再调用子组件updated：先更新子组件，再更新父组件beforedestroy：先调用父组件，再调用子组件destroy：先调用子组件，再调用父组件 实测的图"},{"title":"【复习整理】sass简单整理","date":"2023-02-05T17:28:59.000Z","url":"/2023/02/06/cxy/css/sass/","tags":[["css","/tags/css/"],["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 思维导图： 一、css拓展功能1. 嵌套规则Sass 内层的样式可以将它外层的选择器作为父选择器 编译为 2. 父选择器（&amp;） 编译为 3. 属性嵌套（：） 编译为 4. 占位符选择器（%foo）4.1 @extend比如，你有一些按钮需要设置样式。这些按钮都具有相同的特征，只是每个按钮的颜色不同。你可以创建一个 .button 类以包含按钮的所有通用代码，然后为每个类创建额外的类，为了添加背景颜色之前扩展 .button 类。 4.2 占位符选择器写法和class(.)以及id(#)是一致的，但前面的符号为%，必须配合@extend使用。它取代以前 CSS 中的基类造成的代码冗余的情形，因为 %placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码， 编译后： 5. 注释/* */与 //没啥说的多行注释会被完整输出到编译后的文件，单行注释则不会。 6. SassScript6.1 Interactive Shell用来测试SassScript的功能，在命令行中输入sass -i燃弧输入想要的测试SassScript查看输出结果 6.2 变量$ 变量有块级作用域，如果想转换为全局作用域，需要添加!global声明 编译为： 6.3 数据类型sass支持6种（喵？）数据类型 数字，1, 2, 3, 10px 字符串，&quot;foo&quot;, &#39;bar&#39;, baz 颜色，blue，#04a3f9 布尔，true，false 空值，null 数组，$list: (1.5em 1em) 或$list: (1.5em, 1em)，可以去掉括号 maps，相当于object，(key1: value1,key2: value2) 6.4 运算+ - * / %颜色也可以运算 6.5 函数sass提供了一些函数，详细看文档吧。 6.6 自定义函数 6.7 插值语句 #{}想要在选择器中使用变量的话，就可以使用插值语句。 6.8 type-of()检测数据类型可以使用type-of()检测变量的类型 7. 指令7.1 @import@import “foo.scss” 8. 控制指令8.1 @if @else if @else 编译为： 8.2 @for@for from through@for from to from…through 与 from…to 的区别: from 1 through 3 表示1/2/3from 1 to 3 表示 1/2，不包括3 8.3 @each@each in 编译为 九、输出格式1. 命令sass :style option或sass --style option 2. 常用的style值:nestedNested （嵌套）样式是 Sass 默认的输出格式，能够清晰反映 CSS 与 HTML 的结构关系。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。当阅读大型 CSS 文件时，这种样式可以很容易地分析文件的主要结构。 :expandedExpanded 输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。 :compactCompact 输出方式比起上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。 :compressedCompressed 输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。 "},{"title":"【日常】ChatGPT初探","date":"2023-01-27T06:10:51.000Z","url":"/2023/01/27/cxy/other/chatgpt/","tags":[["实用开源代码or工具","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81or%E5%B7%A5%E5%85%B7/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"],["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" ChatGPT官方说明： Optimizing Language Models for Dialogue We’ve trained a model called ChatGPT which interacts in a conversational way. The dialogue format makes it possible for ChatGPT to answer followup questions, admit its mistakes, challenge incorrect premises, and reject inappropriate requests. 我们训练了一个叫做ChatGPT的模型，它以对话方式进行交互。 对话格式使ChatGPT能够回答后续问题、承认错误、质疑不正确的前提和拒绝不适当的请求。 ChatGPT能做什么？我自己是随便玩了一下 写脚本 “帮我写一段nodejs发送邮件的脚本吧” 答： 写信（不太靠谱） “你朋友的手机摔坏了，写一封信安慰他吧” （ai是比我大方的） “你把朋友的手机摔坏了，写一封信安慰他吧” 你这样说话不会被揍么。。。 还有很多其他的食用方式，自己去探索拉~ vscode插件 使用该插件可以直接在vscode与chatGPT交互，相当于连接到官方web网页，这样子如果提问的是代码，那么程序员就可以快速发现代码的问题（因为我实测发现chatGPT现在写出来的代码是多多少少有问题的） 相关链接chatgpt: 点击访问openai api key:点击访问"},{"title":"【vscode】vetur插件在vue3中报错","date":"2022-12-30T03:31:49.000Z","url":"/2022/12/30/cxy/other/vscode-vetur/","tags":[["开发效率","/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" vetur是vue2支持的插件，volar(vue language features)可以支持vue3。可以直接搜索安装然后禁用vetur，重启vscode即可。 如果不想禁用vetur，又想启用volar，可以在当前项目中的.vscode文件夹的settings.json文件中配置禁用如下： 重启即可。"},{"title":"【blender】blender+pr，做史上最便宜的全息投影","date":"2022-12-25T08:23:04.000Z","url":"/2022/12/25/jianmo/bl-qxty/","tags":[["blender","/tags/blender/"],["pr","/tags/pr/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 做了一个模型嘿嘿嘿~然后本来说是想做动态捕捉的虚拟人物 做好了之后。。喝口水的功夫突然想到，诶可以拿水瓶儿做全息投影什么的！ 于是就又用pr剪好了视频，然后做了投影嘿嘿嘿具体原理就是下面酱紫~ "},{"title":"随便画画","date":"2022-11-26T10:23:38.000Z","url":"/2022/11/26/paint/paint-picture5/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"],["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 下载了一个叫画吧的软件，在里面画了一张西红柿唔，软件不太好用呢~全程不好开压感的。而且笔有延迟，幸亏只是画一个西红柿。延迟还挺严重。有点劝退。不知道有没有人一起什么的。。。。/ "},{"title":"【人像】好久不画人像了","date":"2022-11-24T05:23:38.000Z","url":"/2022/11/24/paint/paint-picture1/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"],["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 小练一下素描~过程录屏在微信视频号中 "},{"title":"【prettier】vscode + prettier自动格式化","date":"2022-11-21T15:11:49.000Z","url":"/2022/11/21/vscode-prettier/","tags":[["prettier","/tags/prettier/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 1. 搜索并安装prettier，并确定该插件是启用状态 2. 在项目中安装prettier 3. 在项目根目录新建.prettierrc和.prettierignore文件 .prettierrc: 配置格式化规则，如以下配置 .prettierrc更多的配置内容可以点击这里 .prettierignore: 配置不需要格式化的文件，如下： 4.打开vscode的setting(快捷键command+,)，搜索Format，并勾选Editor: Format On Save 5. 随便打开一个项目中的js文件，右键，点击使用…格式化文档 6. 在顶部点击配置默认格式化程序…，选择Prettier 配置完成，改动文件并保存就可以生效了。"},{"title":"【blender】着色器基础","date":"2022-11-11T07:21:08.000Z","url":"/2022/11/11/jianmo/bl-zhuoseqi/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 着色器部分国内文档太少，这段时间翻了很久的国外文档，请教了几位油管及discord大神，自己也做了不少东西后做出的总结。 不同颜色节点的含义首先，着色器节点固定从左向右流动。绿色节点：着色器本身如各类bsdf黄色节点：颜色信息如：基础色、次表面色表面并不是一定只能连接一个颜色。新建一个平面，切换到shading，新建一个材质槽。shift a新建一个图像纹理，添加一张图片，连接到bsdf的基础色，就可以将这张彩色图片的颜色信息显示在平面上。（其实可以直接拖进去，但不知道为什么自从我更新了3.3我就再也拖不进去了。）灰色节点：值，bsdf的很多设置都是值着色器上的值与颜色一样，很多时候表面是不想用同一个值来设置所有位置的。如糙度，很多情况下表面的材质并不是同一糙度，所以这时候需要一张描述表面糙度的图，通过0（黑色）至1（白色）之间的值，使用黑白或灰度着色，将值映射到不同的表面位置。即：pbr贴图中的粗糙度文件。如以下这张就是一张粗糙度描述图片，它黑色的地方表示完全不粗糙（0）白色的地方表示粗糙度满点（1），其余灰色的地方，灰色越深，越接近于零，也就越不粗糙。 如图，将上面的粗糙度文件连接至糙度后，可以看到表面有不同程度的粗糙纹理。紫色节点：矢量信息。 蓝色节点：表示属性，多和几何节点结合使用，不属于这里的讨论范围。 当然，不同颜色节点之间可以互相转换，只是会丢失读取不出来的信息。将粗糙度图片连接到黄色节点，如基础色，由于粗糙度图片只有黑白灰的值，基础色无法读出其他颜色信息，所以无法显示彩色。次表面：光穿透过表面后，在其下方散射发生的情况。最常见的就是人体皮肤。 透射&amp;&amp;投射粗糙度透射：决定多少光可以通过材料，而不是从材料反射光。透射值越大，透过材料的光越多。透射粗糙度：透射光的粗糙度，只有cycles下可以使用，且分布为GGX。说简单点儿，透射粗糙度的高低差别就是镜面玻璃和磨砂玻璃的区别。 自发光（发射）：从材料实际发出的光，拥有自己的颜色和强度。alpha：材料透明度。 以上这些值都是可以通过为不同位置传入不同的值来做不同的设置，就如同上述说的粗糙度设置。 法向：用于法线贴图，在不用更改网格几何形状的情况下，伪造材质的深度与阴影。 ##着色器节点 不多叙述，分为表面着色器和体积着色器两类。原理化bsdf着色器理论是可以做出所有表面着色器的效果。但使用其他的表面着色器可以更快捷的实现想实现的效果。比如玻璃、透明、半透、毛发等。以玻璃bsdf举例 折射率：当bsdf为玻璃或半透明时，物体内部可以进行折射，折射的情况就由ior设置。水、不同厚度的玻璃、塑料瓶都有不同的折射率。粗糙度：物体表面粗糙度越高，越不容易进行折射。而这两个参数都是可以在原理化bsdf中进行设置，所以理论上来说原理化bsdf可以实现玻璃的效果，但使用玻璃bdsf来制作单纯的玻璃会更加的便捷。 体积着色器可以连接至体积输出，有原理化体积、体积散射、体积吸收。原理化体积理论上是可以实现体积散射和体积吸收，且可以综合二者进行设置，但直接使用体积散射和体积吸收可以更快捷的实现对应的效果。体积吸收：表示光线穿过物体时，体积会吸收光线体积散射：更接近于雾的效果，通过体积散射，光会撞击物体体积并进行反弹。 体积着色器经常用于实现一些场景的烟雾、或者表现场景的空气透视感时会很常用。如下面这张我建立了两个立方体，对外层大一些的立方体使用了体积散射，在两边设置了两个不同颜色的光源，就会有这种透光的烟雾效果。我做的这张小场景的练习，为了表现出远处的空气透视感，也在中间加了一个体积散射的平面。 体积bsdf的实际运用也可以和噪波纹理相结合，生成不同形状的烟雾，也可以用噪波纹理增加噪点等效果。 混合bsdf：现在我将两个原理化bsdf使用混合bsdf连接，混合bsdf拥有上下两个叫混合器的插槽和一个系数插槽。我将红色bsdf放在下面的混合器插槽，蓝色bsdf放在上面的混合器插槽，若系数为0.5，即上下着色器等比混合，正常情况下物体表面应该为紫色。如下图系数越大，混合结果越偏向于下面的着色器。 若混合bsdf系数给一个灰度描述，如马氏分形纹理，那么表面就会因为不同的系数而做不同的着色器显示。将顶部着色器放在有黑色的地方（0），将底部着色器放在有白色的地方（1）。而灰色的地方进行两个着色器颜色的混合 ##纹理节点blender自带的一些材质节点，可以根据不同材质节点生成不同的灰度纹理。 以马氏分形纹理做简单说明简单说一下3d和4d的区别，4d比3d多了一个w值，w可以使纹理随时间推移改变w，一般用于设置动画。（按i可以设置关键帧，或在节点上右键 - 插入关键帧）如果将纹理直接连接着色器的基础色，那么就是灰度显示，因为材质节点本质就是生成不同位置的灰度信息。如果想让其显示彩色，可以连接一个colorRamp，也就是渐变 沃罗诺伊纹理是一种很常用的纹理，可以生成漂亮的图案及形状。就我个人而言，连接颜色时感觉很像一堆马赛克做了变换的纹理 其他像砖墙纹理、棋盘格纹理就不再多说，纹理与纹理可以相互连接，组合生成不同的有意思的图案，需要多加尝试。除了纹理与纹理之间相互连接外，还有另一种方法，使用mixRgb（混合rgb）混合rgb与混合着色器的使用方法相当像，区别是混合rgb用于颜色输出，而混合着色器用于着色器输出。混合rgb可以控制灰度的信息，所以当两个纹理连接到混合rgb时，可以通过混合rgb去控制两个纹理的强弱。混合方式可以点击自己调节，不详细介绍了，如果用过ps应该是熟悉的。 还有一些不太常用于着色器表面信息的纹理节点，比如ies纹理（用于描述灯光）环境纹理（用于描述环境）等，之后我会再整理。 ##如何将纹理映射到对象上？与几个节点息息相关。 纹理坐标节点：用不同方式告诉纹理如何在blender中进行映射，不同的用途可以有不同的输出。常用的两个是物体和生成，生成是默认的形状，物体适合生成程序化的纹理。 映射节点，可以调节纹理的位置、旋转和缩放 运算节点，可以使两个值做对应运算 "},{"title":"blender三渲二","date":"2022-10-25T19:21:02.000Z","url":"/2022/10/26/jianmo/bl-sanxuaner/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 听说了灌篮高手剧场版上映后，看片花知道是三渲二做的。不太喜欢三渲二的效果，但还是想自己尝试一下。 怎么说呢。。就是三渲二实际上也只是搭个架子，内部的阴影结构明暗交界线什么的要想细化还是得根据光源去画贴图或者顶点着色才可以。如果是普通雕刻人物也就罢了。一般来说可以固定光源在物体的一个角度进行绘画，但如果是会动的物体或者光源不固定就比较讨厌了。就比如灌篮高手剧场版，这次删掉了原本井上的硬朗排线风格。如果灌篮高手剧场版要去全部加这些细节的话，那人物一动光源就跟着被影响，那么每一帧的人物按理说阴影和明暗交界线的排线都需要重新画了。想想可能不比传统动画简便呢。。特别是打篮球本来就是要一直动的。"},{"title":"【zbrush】曲线弯折","date":"2022-10-15T02:21:49.000Z","url":"/2022/10/15/jianmo/zb-quxianwanzhe/","tags":[["zbrush","/tags/zbrush/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"],["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 做头发的时候总在想如果zbrush有类似blender的硬表面操作就好了，然后摸了一下，录了一个视频。 "},{"title":"【画画】把心血来潮想画的东西扔在这里","date":"2022-10-11T05:23:38.000Z","url":"/2022/10/11/paint/paint-pictureall/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"],["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 有段时间很流行画各类月野兔的时候画的 不知道为什么，ipad画完导入手机再看，两边色偏还是挺大的 这破玩意儿我点点点了一周。 第一次画的水彩，没学任何技法，凭感觉瞎怼，那个树叶画的还真丑。 第二次画的水彩，画完之后就再也没动过水彩了。 第一次画的彩铅第二次画彩铅第三次画彩铅第四次画彩铅，一年多前的画，结果。。到现在彩铅找不到了都还没画完"},{"title":"zbrush/blender雕刻工作流gob交互","date":"2022-10-05T02:21:49.000Z","url":"/2022/10/05/jianmo/zb-bl-gob/","tags":[["blender","/tags/blender/"],["zbrush","/tags/zbrush/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 希望下次我再看我自己讲话能听懂。 "},{"title":"【人像】人像练习","date":"2022-10-03T07:23:38.000Z","url":"/2022/10/03/paint/paint-picture2%20copy/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"],["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 这次顺带录了屏嘿嘿~其实没画完拉 "},{"title":"【人像】画个刘亦菲","date":"2022-09-19T07:23:38.000Z","url":"/2022/09/19/paint/paint-picture2/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"],["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 画了个刘亦菲，四五个人都说是宋祖儿hhhhh，好好好那这个画的就是宋祖儿 "},{"title":"【blender】积累的一些杂七杂八","date":"2022-09-15T04:21:08.000Z","url":"/2022/09/15/jianmo/bl-zaqizaba/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" blender3.3更新了，毛发新增了编辑模式，但我没有找到。 只有原先的雕刻模式，在雕刻模式左侧有一些工具可以操作毛发 官网写开启实验功能后的调试后，在实验特性prototypes开启new curves tools我并没有这个选项。。 low poly相关 "},{"title":"【亂七八糟】到底咩係比特幣","date":"2022-09-12T04:25:49.000Z","url":"/2022/09/12/other-xbtb/","categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":"我真係唔明，不是學金融的人。所以查咗一些文章整理咗一下。 簡單解釋比特幣的起源比特幣最初是由一個或一組名為中本聰（Satoshi Nakamoto）的人或團隊在2008年提出的。中本聰通過一個白皮書《比特幣：一種點對點的電子現金系統》（Bitcoin: A Peer-to-Peer Electronic Cash System）來描述比特幣的概念和運作原理。隨後，在2009年1月3日，中本聰開始釋出比特幣的原始程式碼，啟動了比特幣的運作。然而，中本聰的真實身份一直是個謎。他的身份、背景和動機都不明確，並且在2011年末，他從比特幣項目中消失了，從此不再參與開發或管理。 比特幣是以一種去中心化的方式運行的，沒有任何中央機構或個人控制它。比特幣的發佈是通過開源程式碼，並由全球的比特幣節點（也就是參與比特幣網絡運行的電腦）共同管理和維護的。這使得比特幣成為一個完全開放和透明的系統。 比特幣的發佈者和維護者不像傳統的貨幣系統一樣由中央銀行或政府控制，而是由一個由全球節點共同運行的區塊鏈網絡來管理。這就是比特幣的獨特之處，它使得交易變得去中心化、透明和安全。 簡單解釋比特幣的概念中本聰的論文提出了一個新的電子支付系統，這個系統允許人們直接從一個人傳送貨幣給另一個人，而不需要通過銀行或其他中間機構。這個系統利用了一種被稱為「區塊鏈」的技術，這是一個分散式的賬本，記錄了所有比特幣交易的紀錄。 簡單來說，中本聰提出的概念就是：每個人都可以擁有一個「比特幣錢包」，這個錢包裡有一個地址，就像是一個獨一無二的帳號號碼。你可以用你的錢包地址給別人發送比特幣，這個交易會被寫入區塊鏈，這樣就完成了一次交易。比特幣的交易記錄是公開的，所有人都可以查看。 因為交易是直接發生在兩個人之間，而不是通過銀行或其他機構，所以它可以被稱為「去中心化」的支付系統。這樣的系統可以更快速、更便宜地進行交易，並且更具隱私性。 這就是中本聰提出的革命性概念，它讓人們可以創建一種不需要銀行或政府控制的貨幣系統。 簡單解釋區塊鏈想像一個很大的數字記錄本，裡面記錄著所有的交易。這個記錄本不由一個人或一個公司控制，而是由許多人共同擁有。這就是區塊鏈，一種分散式的數據庫。 1. 分散式數據庫：就像一個大家共同使用的筆記本，每個人都有一本，上面記錄著所有的交易。這樣，就不會有一個人能夠控制或修改全部的交易記錄。 2. 區塊：這個記錄本被分成很多個區塊，每個區塊裡面記錄著一段時間內發生的交易。比如，一個小時的交易記錄就放在一個區塊裡。 3. 連接：每個區塊都和前一個區塊連接在一起，形成一條鏈。這樣，所有的交易記錄就連成了一個長長的鏈。 4. 去中心化：這個記錄本不由一個中央機構控制，而是由很多電腦共同管理。每個人都可以在自己的電腦上保存一份完整的區塊鏈副本。 5. 安全：因為所有的交易都是公開透明的，而且需要很多人的共同認可，所以很難偽造交易或修改記錄。這樣就確保了交易的安全性。 總的來說，區塊鏈就像一個公開透明、不可修改的交易記錄本，它保證了交易的安全和可信度，而不需要依靠中央機構。這是一個讓人們可以更信任的交易方式，不僅僅適用於加密貨幣，還可以應用在許多其他領域。"},{"title":"【blender】给你跳段舞？","date":"2022-08-31T08:23:08.000Z","url":"/2022/08/31/jianmo/bl-vroid/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" vroid搞得基础模型大概花了一周时间在blender加的骨架然后搞了一段小动画~ "},{"title":"【blender+scatter5插件】两分钟做好一个漂亮的地形","date":"2022-07-31T22:21:49.000Z","url":"/2022/08/01/jianmo/bl-caoping/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 想录个随风摇摆的动画视频，结果粒子系统卡死我 因为这个插件本质是生成一堆粒子系统，所以要对自己的配置有自信。所需blender版本: 3.1及以上 ##1. 安装Landscape插件 ##2. 新建地形，在网格 - Landscape中。##3. 点击后，左侧下方有一个下拉菜单，点开后可以进行地形的详细设置##4. 物体 - 应用 - 全部变换或command + a 调出应用面板，也可以选择应用变换 。##5. 下载安装 Scatter5 插件并启用下载地址：点击查看下载后解压，通过插件引入，点击安装，导入解压后文件夹内的压缩包scatter5.2.zip，点击确定。点击展开，然后进入enter manager点击install a scatter package选择解压文件夹中的另外三个文件，，点击install即可。##6.右侧n面板中，选择该插件，点击吸管，选择创建好的地形。点击后面板变为以下模样子。然后点击图片，选择想要的预设。点击Biome Scatter，点击Open Biomes选择喜欢的地形。加载完成后，会有很多粒子系统被自动导入，默认不开启。点击每一个System List中的粒子系统，在下方wind中，开启Wind Waves 加载一个天空纹理点击渲染模式并播放即可。 ###说明：&ensp; &ensp; 1. 操作项预设&ensp; &ensp; &ensp; &ensp; 可以设置一些预设的地形，比如石头、湖泊、山等。 &ensp; &ensp; 2.SubdivisionsX / Y&ensp; &ensp; &ensp; &ensp; 细分，细分自然是越高细节越多。但渲染也越慢。 &ensp; &ensp; 3. mesh SizeX / Y&ensp; &ensp; &ensp; &ensp; 设置平面的尺寸。 其他的设置也有很多，可以多尝试 ##其他积累：&ensp; &ensp; 1. scale 平面，之前只知道是按s，但不知道按下数字键可以直接按比例缩放，比如按s，向外拖，再按2，就是放大两倍。按s，向内拖，再按下2，就是缩小两倍了。"},{"title":"blender各种光源的设置","date":"2022-07-24T22:21:49.000Z","url":"/2022/07/25/jianmo/bl-guangyuan/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 场景 - 世界自带光源与hdri光源。首先，场景 - 世界中的自带光源，与hdri光源是互斥的，二者只能有一个生效。当勾选 视图着色方式 - 场景世界 时，将强度/力度调为0，且没有建立其他光源的话，则世界场景完全无光源。将强度/力度调高世界场景也会亮。所以一般如果不需要这个的话，在渲染前需要调为0。 场景世界若不勾选，可以显示hdri，世界不透明度改为0的时候就可以只显示物体上的hdri效果。hdri图有360度的场景。相当于一个懒人全景打光，将场景中物体放入了已经定义好的一个360度的环境中。 各种光源的详细介绍1. 点光源颜色：调整颜色能量：调整瓦数半径：半径越大，向周围发送的光就越散点光源离物体越近，物体越亮。点光光源半径越大，阴影越散。 注：当沿点光源像物体两边作切线，离物体越近的光源切线范围越大。所以点光光源离物体越远时，阴影反而越硬朗， 2. 日光日光本身建立在什么位置都无所谓，完全无所谓。日光的位置不会影响影子的角度、影子的强度。比如下图，日光在物体正上方，影子依旧向右。就算日光放到物体底下，影子依旧不会受日光的位置影响。 影响日光角度的只有这个调节手杆儿 手杆儿角度越大，阴影越长 角度和强度： 太阳光强度一般1-3就很亮了。角度0-180度，和手柄调节的角度不是一个概念。试下来感觉角度越大阴影越散越亮。可以观察下面两张图的角度值，同时观察墙面的投影区别。 3. 聚光灯对物体的照射方式基本像点光，但它的角度可以调节，且只朝向一部分角度。就像是360度的点光截了几十度（1）光源半径光源半径越大，光越散，投影边缘越柔和，越暗。。（2）光斑尺寸越大的光斑尺寸，越大的光斑范围。光斑尺寸不影响边缘模糊与否。 混合，数值 0 - 1，聚光灯下两个圆环数值越接近1 ， 聚光灯底部在中间的小圆的半径越小，光的边缘越模糊，不怎么影响投影的边缘。 ###4. 面光不具体说了，像一个有方向可调节大小和尺寸的太阳光。 hdri切换到world，点击颜色前面的点，点击图像纹理。 勾选hdri后，就在左图设置hdri相关。右边的设置基本就没什么用了。 渲染时如果不想有hdri背景，勾上透明就不会渲染hdri了。 用物体自发光来打光。自发光的物体相当于一个点光源在场景内新建一个球，为球指定自发光颜色及强度切换到渲染模式，就会发现球成为了一个光源照亮了周围的物体。 ####补充：在cycles模式下如何设置辉光？现在只能在渲染层设置，没办法预览，所以需要渲染后才能看到效果。 四、使用ies 纹理进行打光ies纹理概念：ies纹理用于匹配基于IES文件(IES)的现实世界的灯光。IES文件存储光源的方向强度分布。常用的ies纹理免费下载网站：点击下载 下载的ies贴图对应的能量和建议的灯光类型。 举例：第一张没有ies纹理。第二张有纹理。可以看到普通点光是均匀过度的。而用了有ies纹理的灯光是有可能不均匀的。接近现实世界的光。着色器中有一个叫黑体节点，黑体值越大，越接近原本设置的颜色，越小，颜色越暖。 黑体温度为1111111和为1的对比。 "},{"title":"【菜谱】自己做的菜合集 + 简单描述的菜谱们","date":"2022-07-23T04:33:23.000Z","url":"/2022/07/23/caipu/","tags":[["菜谱","/tags/%E8%8F%9C%E8%B0%B1/"]],"categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 日记本来一直在有道云写的，因为有道云太辣鸡吞了我好多图所以当做日记一样复制过来。所以图拍的不是那么讲究，背后很多杂物，甚至很多是吃了一半才想起来拍一张。。。好多图都被有道云吃了，现在只能找回这些了，真惨。 ##香辣鸡翅尖 鸡翅尖开水焯水，加一点点盐，两三分钟捞出备用。 切葱、蒜、干辣椒段、花椒、准备一点熟白芝麻。 锅中热油，放入蒜、干辣椒段（泡水）、花椒，炒香。 倒入一点点火锅底料，炒化后倒入鸡翅。 炒出香味后，倒入鸡翅尖，翻炒均匀后加生抽、糖、蚝油、孜然等尝味道。 撒入香葱翻均匀，撒入芝麻，留一点点香葱装盘后洒在表面做点缀。 ##炸鸡翅根 鸡翅洗净剪开，露出骨头。 酱油、糖、蚝油、花椒粉、辣椒粉、孜然粉、五香粉、蒜、葱、水淀粉进行腌制，二十分钟左右可以拿出。 低筋面粉+淀粉1:1进行混合，腌好的鸡翅根放入其中粘上粉末，捏紧实。搓一搓，再次裹上粉。 如果想脆皮厚一些，可以准备一个放了清水的碗，裹好粉的鸡翅放入水中浸一下就捞出，然后再重复裹上粉，搓一搓的步骤。 油温三成热下入鸡翅，小火炸一会儿翻一下面，炸八分钟到十分钟。用筷子插鸡翅如果可以插透表示熟了。 捞出鸡翅控油，大火让让油温十成热，下入鸡翅，炸制表面金黄且完全脱水，变为脆脆的感觉即可。 ##仿南大门米糕做的桂花糕比较麻烦，快赶上烤蛋糕那么麻烦了，但很好吃。 材料：粘米粉、糯米粉、糖粉，桂花糖，干桂花，还需要准备切刀，30+目筛子，最好是60目，最好备个电子秤，模具，我的是四寸方形慕斯蛋糕模具。 比例：粘米粉：糯米粉：糖粉 = 3:1:1，我用的是四寸方形模具，粘米粉：糯米粉：糖粉 = 150g:50g:50g。还多出一些，做了两次。水：约为糯米粉or糖粉的两倍，如糯米粉五十克，则水要一百克。 详细过程： 糯米粉、粘米粉混合，然后一点一点慢慢加水，搅成一个个松散的小坨坨。 过筛成细细的粉，不要按压细粉，多过几遍筛会让口感更细腻。 蒸锅垫布，模具放入蒸锅，倒入细细的粉，千万不要按压千万不要按压千万不要按压！用刮刀把表面刮平整，，，，，小心翼翼的切分为3*3的九宫格，如果这时候不切开，蒸好后切开就容易碎不好看。 水开后转小火，放上去东西蒸20分钟左右。蒸到五分钟左右的时候其实模具就可以拿掉了，不要等最后才拿模具，因为水会聚集在底部，底部会显得很湿。 蒸完后拿出来，每一块上挤上桂花糖，撒上桂花，趁热吃吧。 ##桂花蒸鸡蛋羹 普通的蒸鸡蛋，就是鸡蛋打了之后加水到鸡蛋一倍左右，然后加盐，把表面气泡用勺子或者别的撇干净。 裹保鲜膜扎洞小火蒸，出锅后表面撒上桂花，切一半圣女果摆上去，沿碗边加上酱油即可。 蒜蓉粉丝娃娃菜 至少一颗整蒜，切末，红尖椒，切碎，切葱、准备几颗花椒。 小火加入油三四成热，油多倒一点，下入花椒炸出香味，下入尖椒翻炒一下，加入蒜末炸至金黄。 倒入生抽、白糖、蚝油、一点点孜然，尝味道合适了备用。 娃娃菜洗净铺在盘底，上面放上泡软的粉丝，倒入炒好的蒜香油。 烧开水，上蒸锅蒸二十分钟。 端出来，加入香葱点缀即可。 鸡蛋杂菜薄饼太简单了，不写做法了。 当然也可以卷了切开做鸡蛋卷，中间加了些肉松。以前的我还真讲究摆盘。。 ##杂菜饭团 米饭煮好，香菇、火腿、玉米、肉松、海苔/裙带菜切碎，切葱蒜小米辣。 小火炒香蒜小米辣，下香菇碎、火腿碎、玉米粒、裙带菜/海苔，加盐、味精调味至合适倒入米饭中搅拌。捏成团摆入盘中，芝士切片铺在饭团上，蒸锅蒸化芝士即可。 ##麻辣鸭掌 鸭掌凉水下锅焯水，焯水后大火转小火，煮四十分钟以上，想要软烂则一小时以上最好。 捞出洗净，准备四五个蒜瓣切蒜末（or蒜瓣拍碎，喜欢吃蒜可以切蒜末），稍微多一些的干辣椒，三根香葱，花椒一小把，熟白芝麻。 大火热油，加入一小块火锅底料炒化，下入蒜末、干辣椒（泡水）、花椒翻炒出香味，下入鸭掌翻炒均匀，加入一点点老抽调色，加入生抽、蚝油、糖调味，（尝一下锅铲的味道。。。合适的话），翻炒几下即可出锅了，关火后加入香葱翻一下，再加入白芝麻翻一下，可以加一点点鸡精翻均匀。 装盘再在表面撒一些香葱和白芝麻即可。 ##蛋挞蛋挞皮是现成的，蛋挞液是炼乳+蛋黄+牛奶+白糖，过筛后倒入蛋挞皮，180度预热烤箱，然后放进去烤20分钟左右就好了，反正烤箱是可以看表面状态的。下次拿出来的时候要小心烫手，我把自己手指烫了。 ##麻辣花蛤 花蛤泡的久一点让他吐沙，然后剥出来。 开水加料酒焯水两三分钟让它熟了，捞出备用。 准备干辣椒花椒小葱蒜瓣拍碎，干辣椒蒜瓣花椒大火下锅炒出香味，加入花蛤翻几下，加生抽蚝油糖翻几下，加一点点孜然翻几下，嫌颜色不够可以加一点点老抽，然后就可以出锅了。 ##年年有余 吉利丁粉在热水中一点一点加，一定要一点一点加。慢慢融化慢慢融化，加入糖，加入枸杞。 倒入模具中冷藏一小时or更长，发现凝固了就拿出来脱模就完成了。如果是很薄的塑料膜可能会沾膜，拿根牙签稍微挑一下就行了。 周围撒上枸杞。说真的真好看，但口感一般，也就果冻的味道，却没有果冻的添加剂。平时我一个人过节的时候，或者还剩吉利丁消耗不掉的时候才会做一做，我是羞于拿它的口感出来招待客人的。 ##糖葫芦 - 小番茄版 圣女果洗净两两穿好备用 糖：水=2：1，放入小锅（重要）小锅中加热，先大火将糖融化至起大泡，然后小火至起小泡，继续加热，至用筷子蘸取糖液，若能拉丝，则放入冰水中，结成块且尝起来易脆则ok。全程不要搅动。 串好的圣女果在锅中沾满糖液，小心拿起避免拉丝，然后放入冰水中浸泡至定型，放入盘中即完成。 ##冒红薯粉 红薯粉开水下锅加一点盐煮20分钟，捞出凉水洗一下。 切小米辣、蒜末（多多多）、葱末（多多多）、香菜（半根）、辣椒面、准备白芝麻大半勺、花生酱一两勺（or花生碎+芝麻酱）、孜然、白糖、蚝油，混合，倒入热油（多一些）搅拌均匀，冷一会儿后加入鸡精、生抽再搅拌。 与粉混合均匀，完成。如果想更好看些，可以再混合后加入小葱香菜在表面做点缀。 ##自制钵钵鸡汤底炖鸡汤，一部分鸡汤放盐备用素菜开水加盐焯熟，荤菜凉水加盐焯熟魔芋要先泡水之后，再煮二十分钟，魔芋不熟有毒，不泡水会去不掉碱味的炒些辣椒油（孜然/辣椒面/花椒/糖/盐/味精/炸花生米/熟白芝麻/其他，热油泼进）干辣椒多些（稍微泡水再过水），花椒多些（稍微泡水再过水），八角，辣椒面，葱段，蒜瓣拍碎锅中稍多点油，放入两勺豆瓣酱，炒出红油，放入上述干辣椒等材料片炒出香味，然后加高汤，然后大火煮沸，转小火加盐调味。五分钟左右关火，捞出那些调料扔掉，加入炒好的辣椒油（一点一点加，防溅锅），然后加大量鸡精调味。汤底倒出汤碗中，放入食材浸泡越长时间越好即可。 ##鸡胸肉饼 鸡胸肉搅碎，加玉米粒、豌豆粒、葱、小米辣、二荆条辣椒，盐、鸡精、花椒粉、生抽。 锅中放入涂上油的圆形模具，倒入油，小火加热，加入鸡肉铺好，待定型取下圆形模具，盖上锅盖焖一下，开锅翻面煎。 怕碎可以加淀粉，但我是不加的，我也没碎，只要鸡胸肉处理的够筋道就不会碎，多摔打，多搅拌，像搅饺子馅那样。 ##牛奶桂花土豆泥 土豆洗净切块蒸熟，混合白糖用料理机打成泥，加入 牛奶拌匀，倒入碗中搅拌均匀，铺上桂花，铺上桂花蜜。 ##狼牙土豆 土豆用狼牙刀切成条状，浸泡去淀粉。 锅中水烧开加盐，土豆放入水中焯熟，不要煮太久，捞出控水。 碗中放辣子面、孜然、花椒（多）花椒粉、糖（灵魂）、白芝麻、葱、蒜末（一个都不要少）、味精、盐，油烧滚泼入，搅拌至盐融化。 土豆控水后，将调料倒入即可。 ##干煸辣子鸡. 鸡腿肉去骨，剪成小块儿 花椒粉+辣椒粉+生抽+一点点老抽+白糖+五香粉+孜然粉，腌制十五分钟。 干辣椒、花椒切段泡水，蒜切片，准备一小段大葱。 锅中入油，小火加热至三分热倒入鸡腿，加入大葱葱段、花椒、蒜片一起炸，鸡腿炸去水分微金黄捞出控油，油十分热再炸一遍。 油倒掉，锅中重新加入多一点的油，倒入辣椒段、花椒、蒜片翻炒出香味，加入鸡腿肉翻炒一分钟即可出锅。特别好吃！ ##红烧后腿肉五五分的肉，比较肥，感觉还是红烧比较有味道。就是普通红烧肉的做法，不说了。##香菇炖鸡腿汤 新！鲜！的鸡全腿用剪刀剪出露出骨头，放入锅中焯水，倒些料酒，放入花椒、大葱段一小段。 捞出洗净，炖锅中倒入许多凉水，放入鸡腿，加入三两颗花椒、一片姜片，放入两三朵新鲜香菇，大火烧开转小火，炖越久肉越烂。 其实更简单的方法就是放进电饭煲按煲汤模式。。火候不用自己看，到时间了就自然好了。 ##烤口蘑 口蘑小心去蒂，放入空气炸锅160度烤十分钟。 锅中放玉米油，蒜切碎（或打成蒜泥），切小米辣、蒜苗，炒蒜蓉酱，先小火加热油，倒入蒜末，小火炒制发黄，加入小米辣碎，搅几下，关火加入白糖、盐、味精搅化。 倒在烤好的口蘑上，撒上蒜苗和葱花即可。 ##清炖狮子头 五花肉/后腿肉/前腿肉/梅花肉洗净，切碎，加入葱、蒜末（要切的很碎很碎）、马蹄碎（建议加，没有也可以不加）、淀粉，反正别用纯瘦肉。 向一个方向搅搅搅，直到感觉有那种韧劲儿了，就比饺子馅还有韧劲儿的那种感觉，然后摔打，多摔几下。 做成大丸子，凉水烧一会儿大概有温度了就下炖锅，慢慢放下去小心碎了，然后大火烧开，小火四五十分钟就可以了。 ##鸡蛋饼裹生菜太简单了都不想说了就是鸡蛋+低筋面粉加了些调味料（盐、花椒粉、糖、孜然，反正根据自己口味加。），搅拌至没有面粉沉淀，然后加入自己喜欢的配菜搅拌成均匀的糊糊，比如玉米粒、香葱、小米辣碎、火腿等等热锅凉油下入上面说的糊糊，小火小火小火，均匀撒上黑芝麻，一面定型后翻至另一面煎熟，然后拿出裹上生菜，表面挤上番茄酱即可。 ##炸香菇 一勺淀粉一勺低筋面粉一个鸡蛋，搅拌均匀，加一些花椒粉、五香粉、盐、孜然、糖。 香菇放里面裹上糊糊，然后小火加热油，油温三成热下香菇，炸至油温七成热熟了捞出。 大火加热油温到十成热，快速放入刚刚炸好的香菇，把表面水分彻底炸干，炸一会儿就捞出，然后表面撒上椒盐，就行了。 ##娃娃菜粉丝汤没啥说的，奶白色汤的秘诀是，加入的配料比如火腿或者皮蛋是要先炒一下的，用除了菜籽油之外的油炒一下然后再加水炖，就会有奶白色的汤了。菜籽油其实也可以用，但炖出来的汤是黄的~味道没有太大差别。 #油炸花生没啥说的，小火凉油倒入花生不停的翻炒，噼噼啪啪的声音出来就是好了。酥脆的秘诀就是捞出之后加入料酒然后用筷子不停的搅，加入料酒会有刺啦的声音，搅拌的时候也会冒烟 ##好看不好吃的空气炸锅杏鲍菇 一个淀粉一个鸡蛋混合均匀加入花椒粉生抽孜然粉五香粉调味调味 面包糠放入另一个碗中备用。 杏鲍菇切条，放入淀粉鸡蛋液中滚一滚，再裹上面包糠，再放入鸡蛋液滚一滚，再裹一次面包糠，放入空气炸锅刷一层油，200度烤十分钟即可。 因为是面包糠，再加上空气炸锅虽说叫炸锅实际上是烤，所以表面很干很干，并没有那么好吃。无奈我只能就这个形态又去油炸了 一遍，味道才变得好吃， 注：面包糠的特性是虽然脆，但不会像淀粉+面粉那样油炸之后边的膨胀，所以要想好看的话面包糠是要裹至少两遍的。 ##烤豆腐 - 空气炸锅版 豆腐横刀一刀，竖刀三四刀将豆腐切块。 空气炸锅平铺锡纸，豆腐摆入空气炸锅，180十分钟翻面，再烤十五分钟（或更长），考好拿出摆盘。 调酱汁，蚝油+糖（天下无双）加自己炒的特辣辣椒油和辣椒面，加一点孜然粉，加小葱和蒜和一点醋（这个料绝了，味道超级好）也可以加一点小米辣，我没加懒得切，倒在豆腐表面，完成。 ##烤苕皮酱汁：辣椒面、花椒面、孜然、熟白芝麻、韩式烧烤酱或糖各一勺，搅拌后淋上热油。炒些花生。刷上酱汁，苕皮一点油小火煎，煎至起泡，翻面刷上酱汁，煎至两面起泡，撒上香葱、韭菜、花生、榨菜，折三折，用竹签穿好即可。 ##烤五花肉片选新鲜的五花肉，新鲜的五花肉，新鲜的五花肉，腌个十来分钟，然后锅里小火煎熟就行。 ##烤鸡腿腌料腌半小时–三小时，烤二十分钟中途翻面。我的腌料：花椒粉、生抽蚝油糖、孜然粉、辣椒粉、蒜末、葱烤的时候表面刷蜂蜜 ##娃娃菜豆腐汤豆腐煎一下，加入水烧开，加入娃娃菜小火炖十几分钟，捞出撒入香葱。这个豆腐使用菜籽油煎的，所以汤变成了黄色。如果用玉米油煎就不会是黄色而是奶白色。 ##拔丝土豆简单但麻烦，麻烦的点在于，锅如果当时做完不洗干净，等锅里的糖凉了就很难洗干净。。做菜五分钟洗锅一晚上。 水糖1:2熬糖，大火冒大泡转小火，熬一会儿拉丝了加入炸好的土豆块搅拌均匀即可。 炸土豆块就不说了，土豆块焯水七八成熟控水，下入三分热油锅炸熟，大火十成热油复炸就行了。 ##圆圆的煎鸡蛋~让它圆圆的秘诀在于不要用平底锅，要用普通炒锅，因为普通炒锅打鸡蛋下去不会跑偏。平底锅就容易跑偏。 ##月饼装到盒子里也很好看啵 酸菜鱼酸菜切了，加葱姜蒜花椒泡椒炒一炒鱼片成片，加花椒粉淀粉盐腌，鱼头骨炖汤。炒后的酸菜加鱼汤煮，煮到沸腾转小火，放入鱼片煮熟（一般鱼是熟的很快的）。碗底铺焯好水的豆芽和金针菇，然后捞出鱼片放在表面，倒入汤。表面再放花椒、干辣椒段、蒜末、香葱。热油淋上去表面撒上香葱即可。"},{"title":"【2022-10-09】前几天在咖啡厅画速写","date":"2022-07-02T05:23:38.000Z","url":"/2022/07/02/diary/diary-1009/","tags":[["生活","/tags/%E7%94%9F%E6%B4%BB/"],["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 还被画的小姐姐发现了，但她坐了很长时间之后，默默的走了，走之前和同行小姐姐说“看不看？”最后也没过来看。 "},{"title":"平面构成入门","date":"2022-07-02T05:23:38.000Z","url":"/2022/07/02/paint-color%20copy/","tags":[["构成","/tags/%E6%9E%84%E6%88%90/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 先把思维导图放好，之后慢慢配图 一、形式美的原理与法则一类是“有秩序的美”，一类是“打破常规的美” 平衡对称：反射、移动、回转、扩大 对比调和节奏变异二、点线面1. 点1.1 什么是点？点是一切形态的基础，是造型的最小单位。 点的大小是有限的：点的确定是由点与环境空间对比而决定的，关键在于点在空间中所占的面积是极小的。 点的形状是多样的：可以分为规则形状与不规则形状。规则形状：圆，方，三角，星形，菱形，梯形。。。不规则形状：随意自由和偶然产生点的形状，大场景下的小物体，如海洋上的帆船，高空下的房屋，形状各异的水滴，机场的飞机等等。。 1.2 点的作用点是 "},{"title":"blender的cycles引擎如何使用辉光效果","date":"2022-07-01T08:23:04.000Z","url":"/2022/07/01/jianmo/bl-cycles/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 一般辉光是只在eevee引擎下如果cycles下也想用的话照我下面这样设置就可以拉"},{"title":"blender练习蜡笔工具","date":"2022-06-23T04:21:49.000Z","url":"/2022/06/23/jianmo/bl-grease/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 上上手蜡笔工具吧。挺好玩的，有点费事儿，比三渲二效果好多了。 "},{"title":"色彩构成入门","date":"2022-06-22T20:57:38.000Z","url":"/2022/06/23/paint/paint-color/","tags":[["构成","/tags/%E6%9E%84%E6%88%90/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 思维导图 1. 基本概念首先，有光线才有色彩。物体表面会吸收一部分光线，反射另一部分光线，反射的光线到达我们的眼睛，被视锥细胞（感知颜色的细胞）和视杆细胞（感知明暗的细胞）所接收，再通过神经传输到大脑，我们就产生了颜色的映像，从而具有色彩感。 我们已经知道，牛顿用三棱镜将光分成了七色，从红到紫正是我们人眼能感知到的颜色范围，从光学的角度看，就是波长从 380 纳米到 780 纳米的光线。低于 380 纳米的，叫做紫外线，高于 780 纳米的，叫做红外线，都是我们人眼无法看到的。 我们已经知道，光线具有波长和振幅，其中，光波的波长反映光波的频率，给人色彩感，光波的振幅反映光的强弱，给人明暗感。人眼中的两种细胞正是分别感知这两种参数，其中，视锥细胞感知波长，视杆细胞感知振幅。所以，我们看到的颜色，其实就是不同波长、不同振幅和不同比例的光线在人眼中的反映。 通常，我们所称的自然光都是指太阳光，物体在自然光下呈现的颜色我们称为物体的固有色。但是，自然界中还有其它的光源，比如月光、闪电、灯光、烛光等，而在其它光源的照射下，物体颜色会发生改变，所以，我们平常所看到的颜色都是物体固有色和光源色的结合。 如果照射到物体表面的全部光都被吸收，物体就呈现黑色，如果全部光都被反射，物体就呈现白色，不过，纯粹的黑白只存在于理论中，现实中没有物体可以全部反射或吸收光线。 1.1 色彩的三要素就像度量衡一样，色彩也需要一个标定体系，像红、黄、蓝、绿这样的简单命名是模糊的，不足以区分不同的色彩。色彩的标定体系就是色彩的三要素：色相（Hue）、明度（Value）、纯度（Chroma）。 色相字面上理解，就是色彩的相貌，用来区分不同的颜色，比如牛顿分解的光谱色：红、橙、黄、绿、青、蓝、紫，就是七种不同的色相。在我们后面会学到的色相环中，色相包括三原色和由它们按不同比例混合成的各种间色和复色，理论上，色相的划分是没有极限的，但是人眼的感知有极限，人眼只能分辨出大约 180 种不同色相的颜色。还要注意的是，无论色相环包含的色块有多少，每两块之间都有本质的区别，色块越多，仅仅是色差越小。 从光学意义上讲，色相的不同是由光波波长的长短和不同光线的比例决定的。 明度简单的理解，就是色彩的明暗程度。每一种色相都有自己的明暗度变化，而且都以白为最高明度，黑为最低明度。色彩的明度受两个因素影响：一是光源色的强弱，光线越强，色彩明度越高；二是黑与白的介入强度，加入黑色可以降低色彩明度，反之，加入白色可以提升色彩明度。 明度在光学角度的本质是光的振幅（即强弱），所以黑和白的介入也可以这样理解，加入黑增强了物体吸收光线的能力，因此降低了它的明度，而加入白增强了物体反射光线的能力，因此提升了它的明度。 除了色相本身的明度变化外，不同色相本身就有明度的差别，其中，黄色明度最高，紫红色明度最低。纯粹的黑白色也有明度的变化，这就是不同级别的灰色。 纯度纯度指的是色彩的鲜灰程度或纯净程度，也叫做饱和度。意思是一个色彩包含该种色素成分的多少，当该色素成分为 100% 时，就是该色相的纯色，所以加入其它任何颜色都会导致纯度的下降，不过，通常降低某色彩的纯度，都是通过混入无彩色系列的黑白灰或混入该色的补色完成的。 从物理的角度讲，一个色相的纯色就是单一波长的光。 黑白灰这三种颜色没有纯度的概念，因此叫做无彩色，其它有纯度的颜色叫做有彩色。 1.2 色彩混合大部分的色彩都可以通过混合其它的色彩得到，但是，一定有几种是最基本的颜色，是不可拆分的，这就是原色。光的三原色是红、绿、紫，颜料的三原色是红、黄、蓝。 任意两种原色混合得到的颜色叫间色，颜料的三间色是橙、绿、紫。 将间色彼此混合，就形成了复色。由于间色本身就是原色混合而成的，复色就意味着是不同比例的原色混合，原色混合的不同比例加上纯度和明度的变化，就构成了我们所看到的丰富的颜色世界。 光线彼此混合，亮度会不断提升，最后形成白色光，这叫做加色混合，计算机的显卡就属于 RGB 加色配色系统。通过改变每种原色电子光束的强度，得到深浅不同的色彩，从而合成丰富的色彩； 颜料彼此混合，亮度会不断降低，最后形成黑色，这叫做减色混合。最后一种混合叫做中性混合，是利用人眼对空间的感知产生的一种混合方式，包括两种，一种是具有运动特点的旋转混合，比如具有两种颜色的陀螺旋转会呈现这两种颜色的复色，另一种是具有静止距离特点的空间混合，例如马赛克镶嵌画和点彩画。 1.3 色相环色相环也称色环，是将色相以一定的变化规律顺序排列形成的一个环，反映了色相之间的数理关系，对色彩的使用具有很大的指导意义。常用的是 RGB 的 3 色相环、瑞士约翰内斯·伊顿的 12 色相环、德国奥斯特瓦尔德和日本色彩研究所的 PCCS 色彩体系的 24 色相环、美国孟赛尔的 100 色相环。所有的色相环都是以 120⁰ 的三原色为基础，在一个完整的圆内等量分割，形成变化均匀的等量过渡色。 下面是伊顿的十二色相环，在 120° 的位置上是 3 个原色，每对原色中间加入一个间色，每对间色中间再加入一个复色，180° 的直径两端叫做互补色。 1.4 色立体色立体是色彩理论的数学模型，是色相、明度和纯度三元素借助三维空间的表达，也是唯一区别每个颜色的标准。 目前，主要的色立体体系有美国的孟赛尔色立体、德国的奥斯瓦尔德色立体、日本色彩研究所 PCCS 色立体、国际照明委员会 CIE 色立体等。虽然各自之间有一定的区别，但是理解了其中一种，剩下的就都很容易理解了。 以如下的孟塞尔色立体为例，水平的圆环等量分成 10 份，分别是红、黄、绿、蓝、紫 5 个基色和它们的 5 个间色，共构成 10 个基础色域，每个色域再等分成 10 分，总计 100 个色相，这个圆环就是我们之前说的色相环；纯色在圆环的最外层，从最外层到圆心，纯度不断降低，直到变成圆心的灰色，纯度一共有 12 个等级；中间的轴代表无彩色，最下方是黑色，最上方是白色，黑白之间还有按明度变化的 9 个灰色，因此，纵轴就代表了明度的变化，每一种色相和纯度确定的色彩在纵向上都有明度的变化。 下面是构造出的完整孟塞尔色立体。 2. 色彩的对比色彩的对比是将两个以上的色彩放到一起，由于相互作用和相互影响而显现出差异的现象。事实上，对比是构成色彩的必要因素，如果整个世界只有一种颜色，没有彼此的对比，那也就失去了色彩的意义。 根据前面所学的一些概念，色彩的对比可以分为：明度对比、色相对比、纯度对比、冷暖对比、面积对比等。 2.1 色相对比因色相差别而形成的色彩对比称为色相对比。将不同色相的色彩并置在一起，可以使对方的特征更加突出。 根据各色相在色相环上距离远近的不同，可以形成不同的色相对比，距离越远，对比效果越强烈，相距 180° 的两个色相对比最为强烈 同类色对比：色相环上距离在 15° 以内的两个色相的对比，对比的效果一般比较弱，通常还需要拉大明度和纯度来进行区别； 邻接色对比：色相环上距离在 15°-30° 之间的两个色相的对比，这样的两个色相就有了一定的区别，对比效果一般比较统一、和谐、柔和，适合背景处理； 类似色对比：色相环上距离在 60°-90° 之间的两个色相的对比，类似色对比一般显得丰满、活泼，即保持了随和统一的优点，又克服了视觉上不够饱满的缺点； 中差色相对比：色相环上距离在 90° 的两个色相的对比，由于差别比较明确，对比效果比较明快； 对比色相：色相环上距离在 120° 左右的两个色相的对比，对比效果比较强烈、鲜明，但过于刺激易产生视觉疲劳，处理不好容易出现烦躁和不安定的感觉； 互补色相：色相环上距离在 180° 左右的两个色相的对比，是最强烈的对比关系，更富于刺激性，但是画面比较直白，不够含蓄和雅致，同意易导致视觉疲劳。 在我所阅读的几个材料中，对色相对比的分类和称呼各有不同，比如，在有的书籍中同类色指的就是距离 15° 的两个色相对比，因此，上述分类只能作为参考，唯一确定的是，距离越远，对比效果就越强烈。 除了以上的色相对比外，还有两种特殊的色相对比 全色相对比：指的是色相环上所有色相都出现，由于人的视觉系统需要全色刺激，这种对比比较协调； 有彩色和无彩色的对比：无彩色又可以称为万能色，无论什么样的有彩色，和无彩色对比都可以呈现和谐的视觉效果。 2.2 明度对比指因明度差别而形成的色彩对比。两种不同明度的色彩并列时，会使明色更亮，暗色更暗。 根据孟塞尔色立体，由黑到白等差分为 9 个等级，加上黑白两色一共 11 个等级。0 级为纯黑，明度最低，10 级为纯白，明度最高。 我们将明度在 0-3 级的色彩称为低明度，明度在 4-6 级的色彩称为中明度，明度在 7-10 级的色彩称为高明度。以低明度色彩为主的构成低明度基调，以中明度色彩为主的构成中明度基调，以高明度色彩为主的构成高明度基调。 注：“……为主” 指该色彩在画面上的面积超过 70%，占绝对优势。 同时，我们将明度差在 5 个级别以外的对比称为强对比（长调对比），将明度差在 3-5 个级别内的对比称为中对比（中调对比），将明度差在 3 个级别以内的对比称为弱对比（短调对比）。 这样，不同的基调和明度对比程度就构成了一个 9 种明度对比方案，称为明度 9 调，分别是：高长调、高中调、高短调、中长调、中中调、中短调、低长调、低中调、低短调。举个例子，高长调指的就是主色调为中明度，明度差在 5 级以上的对比。一个明度 9 调的例子如下图： 2.3 纯度对比因纯度差别形成的色彩对比叫纯度对比，不同纯度的色彩并置，鲜的更鲜，浊的更浊。 和明度相似，纯度也有 3 种色调和 3 中等级差： 高纯度色彩占 70% 左右叫鲜调（高彩对比） 中纯度色彩占 70% 左右叫中调（中彩对比） 低纯度色彩占 70% 左右叫低调（低彩对比） 纯度差为 8 级以上叫强对比 纯度差在 5-8 级叫中对比 纯度差在 4 级以内叫弱对比 因此，纯度也有九调，分别是：鲜强、鲜中、鲜弱、中强、中中、中弱、灰强、灰中、灰弱。 2.4 冷暖对比冷暖色形成的对比，关于冷暖色的定义可参考本文番外部分。根据孟塞尔色相环的十个主要色相，以最暖色橙为暖极，以最冷色蓝为冷极，可划分为 6 个冷暖区 其中，两个冷暖极的对比是最强的，剩下的分三种 强对比：冷极和暖色，暖极和冷色； 中等对比：暖极、暖色和中性微冷，冷极、冷色和中性暖色； 弱对比：暖极和暖色；冷极和冷色；暖色和中性微暖色；冷色和中性微冷色；中性微暖色和中性微冷色。 以暖色为主可构成暖色基调，以冷色为主可构成冷色基调，两者给人不同的感觉，如下表 冷 暖 阴影 阳光 透明 不透明 镇静 刺激 稀薄 稠密 空气感 土质感 远的 近的 轻的 重的 潮湿的 干燥的 理智的 感情的 流动的 静止的 冷静的 热烈的 2.5 面积位置对比形态作为视觉色彩的载体，总有一定的面积，因此面积也会对色彩的表达产生重要影响。 色彩对比与面积的关系有： 色调组合，只有相同面积的色彩次啊能比较出实际的差别，互相之间产生抗衡，对比效果强烈； 对比双方的属性不变，一方增大面积，取得面积优势，而另一方缩小面积，将会削弱色彩的对比； 色彩属性不变，随着面积的增大，对视觉的刺激力量加强，反之削弱。因此，色彩的大面积对比可造成炫目效果； 相同性质与面积的色彩，大面积色稳定性较高，在对比中对它色的错视影响大，反之受它色的错视影响小。 色彩对比和位置的关系有： 对比双方的色彩距离越近，对比效果越强，反之越弱； 双方互相呈接触、切入状态时，对比效果强烈； 一色包围另一色时，对比效果最强； 在作品中，一般将重点色彩设置在视觉中心部位，最易引入注目，如井字形构图的四个交叉点。 注意，色彩对比从不是单一方面的，而是多个方面共同作用。 3. 色彩的调和 对比是手段，调和是目的 色彩的调和是指两种或两种以上的色彩，有秩序、协调和谐的组织在一起，形成和谐统一的色彩搭配。色彩调和是色彩设计的基本法则，色彩调和有两层含义 使有明显差别的色彩经过调整，形成和谐而统一的完美整体； 合理的组织选择色彩搭配，使其形成具有目的性的美的色彩关系。 调和方式包括：同一调和、类似调和和对比调和。 3.1 同一调和同一调和指在色彩的三属性中保持一种属性相同，将另外两种属性进行变化，因此又可以分为同色相调和、同明度调和、同纯度调和，还有一种特殊的无彩色调和。 [图片上传失败…(image-b5b89-1674499821595)] 3.2 类似调和类似调和是类似要素的结合，与同一调和相比，具有稍多的变化，但并没脱离以统一为主的配色原则。 [图片上传失败…(image-518ad2-1674499821595)] 3.3 对比调和对比调和是以强调变化而组成的和谐色彩搭配。在对比调和中，明度、色相、纯度三种要素都处于对比的状态，因此色彩更富于活泼、生动、鲜明的效果。 对比调和的方法有：秩序调和、混入调和、分割调和、呼应调和和面积调和。 秩序调和指在画面组织时时多种色彩呈现一定的秩序规律，常见的有 在伊顿色相环中选择位于等腰三角形、等边三角形、长方形、正方形等几何图形顶点上的色相来组织； 对色彩的色相、明度、纯度做渐变推移处理，使最强和最弱的色彩间呈多个梯次的等差、等比关系，弱化对比强度； 九宫调和，将 9 个按顺序排列好的色块放入九宫格中，源自我国传统的「明堂九室」，是多年累积的视觉经验。 混入调和指遇到不和谐的色彩组合时，选择一个同化元素（色彩要素中的任何一个），将其加入到所有的不同色彩中，使之都含有共同的因素，从而达到和谐的目的。 对于色相，应使所有色彩都具有共同的色彩倾向，比如夕阳下的所有色彩都带有暖暖的橙色，可以看作色相混入的结果；对于纯度，可使所有色彩降低自己的纯度，形成统一的色彩饱和度，比如雨雾中的所有色彩都变得灰蒙蒙的；对于明度，可使所有色彩同时降低或提升明度。 混入调和一般用在色彩调配阶段。 分割调和指遇到不和谐的色彩组合时，在它们之间嵌入金、银、黑、白、灰任何一种颜色，或者嵌入这几种对比色的中间色，使之产生过渡，从而缓解直接对比的强度，使配色达到调和。 分割调和主要用在画面的色彩组织中。 呼应调和指将合适的色彩添加到原画面中，使新色彩和原有色彩达成彼此呼应的调和关系。呼应的内容同样可以从色彩各要素触发，最常用的是色相的呼应。 注意，呼应的色彩对象多为画面中的主体、中心色，起到呼应作用的色彩多在面积、位置、数量、形状等方面处于弱势。 面积调和使某种色彩的面积占据支配地位，可以削弱对比关系。另外，伊顿根据歌德的色彩面积研究成果提出：相等面积比例的红色和绿色能够产生中性的灰色，而黄色和紫色、橙色和蓝色则需要不同的配色比例。用数学比例来显示它们的配比关系为红色:绿色=1:1、黄色:紫色=1/4:3/4、橙色:蓝色=1/3:2/3，这也是著名的“面积对比调和色轮图”。 红色和绿色，黄色和紫色、橙色和蓝色，不论哪一方超过这个比值，都将破坏两者间的调和关系，将两者转化到对比关系中。越接近这种调和比例，对比就越强烈，最终回到最熟悉的红花与绿叶的对比关系之中。 番外冷暖色从色相环的分布看，红橙色类为暖色系，蓝紫色类为冷色系，黄绿色类为中性，黑色感觉为暖色，白色感觉为冷色。色彩明度和纯度的改变也会影响色彩的冷暖感，明亮色偏冷，深暗色偏暖，纯色保持原色的冷暖感，而纯度的降低会使冷暖感趋于中性化。对于太阳光而言，时间也是影响冷暖的因素，一般来讲，早晨的阳光色彩偏冷，傍晚的阳光色彩偏暖。各种不同的光源提供的颜色本身就有偏向，比如，白炽灯的光源色偏暖黄，荧光灯的光源色偏冷蓝。 色调我们常说一幅画、一张照片或一个场景是什么色调的，色调其实指的是占主导地位的一种视觉因素，色彩的三元素：色相、明度和纯度都可以作为色调，比如，从色相上，可以有红色调、蓝色调、黄色调、绿色调等；从色彩明度上，可以有明亮色调、暗色调等；从色彩纯度上，可以有清色调、浊色调、纯色调、灰色调；甚至从色彩的特性上，可以有暖色调、冷色调、中性色调。 一般情况下，当某种类型色彩占据超过 70% 时，就称为该色调。"},{"title":"【2022-06-12】这种试稿我再也不想参加了","date":"2022-06-12T05:23:38.000Z","url":"/2022/06/12/diary/diary-0612/","tags":[["生活","/tags/%E7%94%9F%E6%B4%BB/"],["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 虽然都不难，按他的风格去画都是半小时内就画完的东西，画完两张试稿通过后觉得好不值得，关键画完说通过了才给合同，好家伙，一看一单抽六成，你们咋不去抢呢？？？ "},{"title":"docker安装jenkins","date":"2022-03-21T11:36:26.000Z","url":"/2022/03/21/dockerjenkins/","categories":[["undefined",""]],"content":"明天写拉 docker pull jenkinsdocker run xxx 一、目的本文介绍如何在本地搭建一个基于 Docker 和 Jenkins 的自动化部署系统，并通过 GitHub 的 Webhook 实现代码的自动化部署。 二、准备工作首先，我们需要安装 Docker。根据操作系统的不同，安装方式有所不同： 对于 macOS，请點擊下載。 对于 Windows，请點擊下載。 对于 Linux，请使用以下命令安装： 安装完成后，通过输入 docker -v 命令来验证是否成功安装。 接下来，我们安装 Jenkins。首先搜索 Jenkins 镜像并拉取稳定運行的版本。 确认镜像拉取成功后，使用以下命令启动 Jenkins 容器： 启动成功后，你将会收到该容器人唯一的假的 ID。 打开浏览器，访问本地的 8008 端口，你将看到 Jenkins 的解锁页面。 获取初始化密码接下来，我们需要获取 Jenkins 的初始化密码。进入容器内部并查看密码： 输入控制台返回的密码，即可进入配置页面。选择安装推荐的插件，如果有安装失败的插件，重试即可。 创建用户安装完成后，输入相关信息创建用户。创建完成后，继续点击下一步。系统将会重启，重启完成后使用刚创建的用户登录。接下来进行配置环节。 三、配置接下来，我们对 GitHub 和 Jenkins 进行配置。 在容器内生成 SSH 公钥首先，我们需要在 Jenkins 容器内生成 SSH 公钥： 然后，将公钥添加到 GitHub 上。在 GitHub 中的个人设置中找到 SSH and GPG keys，添加新的 SSH key，填入公钥即可。 添加私钥到 Jenkins接下来，我们需要将生成的私钥添加到 Jenkins 中。在 Jenkins 中的系统管理中，添加凭证。 类型选择 SSH Username with private key。 描述和用户名随意填写。 创建任务在 Jenkins 中创建一个新任务，选择构建一个自由风格的软件项目。配置源码管理为 Git，输入远程仓库地址，并选择之前添加的凭证。指定分支为 master。 尝试项目构建手动点击构建项目，查看日志。如果配置正确，可以看到构建完成的状态为 SUCCESS。 自动化配置完成自动化部署主要通过 GitHub Webhook。GitHub Webhook 通知 Jenkins 进行构建。在 GitHub 上生成一个 Personal access token，并拷贝生成的 token。 配置 GitHub在 GitHub 仓库设置中，添加 Webhook。 Payload URL 填入 Jenkins 容器运行端口映射出去的公网域名 + /github-webhook/。 Content type 选择 application/json。 Secret 填入之前生成的 token。 配置 Jenkins首先，我们需要在 Jenkins 中创建一个凭证： 类型选择 Secret text。 然后对该凭证进行配置： 在系统配置中，配置 GitHub，覆盖 Hook URL 并输入 Webhook 地址，并选中创建的凭证。 配置完成后，当代码仓库更新后，Jenkins 将会自动进行构建。 打包项目项目代码需要打包后才能正确使用，接下来在 Jenkins 端进行代码构建操作。 首先，安装必要的插件 NodeJS 和 Publish Over SSH。 配置全局 NodeJS 插件： 在全局工具配置中，新增 NodeJS。 配置项目中的 NodeJS 构建环境： 在项目配置中，选择 NodeJS 环境。 在构建操作中，执行 shell 安装依赖項并打包。 发送到服务器全局配置 Publish Over SSH 插件： 在系统配置中，配置 SSH 服务器。 项目中配置： 在项目配置中，配置 SSH Server 的 Transfers。 脚本示例： 至此，你已经完成了本地 Docker + Jenkins 的自动化部署系统的搭建。你可以尝试推送代码，验证自动化构建部署的流程是否成功。"},{"title":"搭建web部署系统","date":"2022-03-21T02:55:58.000Z","url":"/2022/03/21/c0ks/","tags":[["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 安装jerkins docker ，准备好代码仓库（github/gitlab）在自己的机器上跑起来 done使用jenkins将码云上的git仓库拉到服务器将代码拉到服务器后，可以手动触发构建、部署完成自动化部署开发一个自己的插件，具体做啥还没想好 在开发服务器上既部署了jenkins也部署了项目，通过不同的端口号访问，很不安全也不好。 我将Jenkins部署系统和网站运行在同一台服务器上，但它们使用的不同端口号。部署系统是8008，网站是8009 Jenkins是一款开源的自动化部署工具，可以通过插件来实现各种不同的功能。其中，SSH Remote Hosts插件允许Jenkins在远程服务器上执行命令。 先使用publish over ssh插件将内容发送到服务器上，然后再使用ssh remote hosts配置去远程执行服务器上的命令。 ssh remote hosts 的作用该插件允许Jenkins将指令发送到远程服务器，并获取执行结果。这对于自动化部署和持续集成非常有用。通过SSH Remote Hosts插件，您可以配置Jenkins与多个远程服务器之间的连接。您可以指定服务器的IP地址、用户名、密码、端口号等信息。在建立连接后，您可以在Jenkins上执行各种命令，如运行shell脚本、安装软件包、复制文件等等。 在使用SSH Remote Hosts时，需要注意以下几点： 在远程服务器上安装SSH服务，以便Jenkins可以连接到服务器。确保您在Jenkins服务器上安装了SSH插件。在SSH Remote Hosts插件的配置中，确保您提供了正确的IP地址、用户名、密码和端口号。确保您在Jenkins中的作业中使用了正确的SSH Remote Hosts插件的配置。使用SSH Remote Hosts插件时，需要小心，确保您使用了正确的权限和正确的命令。同时，要定期更改您的密码，以确保安全性。"},{"title":"【chrome调试】使用chrome调试已发布页面的文件代码","date":"2022-03-12T07:01:49.000Z","url":"/2022/03/12/cxy/other/chrome-tiaoshi/","tags":[["开发效率","/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 让这个脚本跑了一晚上，并顺便水了一个视频，骗了两个硬币。熬了一整夜剧都没掉下去 已经编译上线的代码，在需要进行浏览器调试的时候，改文件会相当不方便，有时候只是改一些小条件也需要繁杂的操作，并且浏览器一刷新就又要重新改。为了解决这个问题，可以使用chrome的snippets调试已发布页面的文件，通过拦截network 打开sources - Snippets 2. 点击Select folder for overrides，选择一个文件夹，用于存储需要调试的在线文件。 3. 上方点击“允许”，可以看见文件夹就显示在Overrides里了。 4. 比如在google首页，打开network，随便选择一张图，右键 - Save for Overrides5. 回到source，就可以在你的文件夹中看见这张图了6. 现在可以把它替换成其他logo，比如百度7. 也可以去调试代码，搞些有意思的小事情~比如很久之前有段时间很流行的b站风叶穿行游戏，我是用这种方法改脚本自动跑的成绩 使用chrome的Snippets比较省事的是，即使刷新很多次，只要勾选了Enable Local Overrides就会一直生效，有时候本地未经过编译的代码怎么测试都没有问题，但放到线上就是有奇奇怪怪的问题，如果能调试压缩后的代码也会比较直观~我是一直很喜欢这个方法拉。"},{"title":"【乱七八糟】不要陷入自证的陷阱中","date":"2022-02-10T18:21:45.000Z","url":"/2022/02/11/story-wzx/","tags":[["生活","/tags/%E7%94%9F%E6%B4%BB/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":"伍子胥与渔夫伍子胥被追捕，正处在绝望的边缘，前方是一条江，他毫无头绪，不知如何是好。 突然，一个好心的渔夫出现了，他愿意载伍子胥过河。 这个渔夫在人群中一眼就认出了伍子胥，因为楚王为了抓捕他，张贴了他的画像，还悬赏了重金，任何认出他并报告的人都可以得到丰厚的赏金。 因此，伍子胥就像一个通缉犯一样，走到哪里，都有人能够认出他，他感到无比的恐惧和不安。 伍子胥感激渔夫的帮助，却担心他泄露自己的行踪，于是将他身上的宝剑赠予渔夫，希望他能保守秘密。 渔夫理解伍子胥的疑虑，但并未收下这把价值连城的剑，并仰天长叹，对伍子胥说道：“我救了你，却要被你怀疑。如果你被追兵抓到了，我该怎么证明自己的清白呢？” 说罢，渔夫竟然投江而死。 伍子胥非常难过，继续逃亡的生活。 瞬间跳出自证陷阱 把自证变成他证：谁主张，谁举证 （你拿出证据，你有证据么？没有证据你这叫造谣） 反过来泼脏水，让对方掉入自证陷阱（你既然有这种想法，是不是你这么干过？你用这种方法冤枉过多少人） 争取到更多的人和你站一起，给对方压力。 要记住，想否定你的人，有无限的说辞，你永远都解释不完的。 "},{"title":"github pages 自定义域名","date":"2022-01-26T07:01:49.000Z","url":"/2022/01/26/cxy/other/dns/","tags":[["实用开源代码or工具","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81or%E5%B7%A5%E5%85%B7/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" ping xxx.github.io找到域名 在购买域名的提供商为域名添加解析，如下设置（阿里云的） 在Github中，找到托管博客的xxx.github.io项目：setting - pages中，在Custom Domain填上刚刚添加解析的域名并保存即可。 完成，请点击"},{"title":"【github】使用my-json-server建立线上测试api库","date":"2021-11-27T14:21:49.000Z","url":"/2021/11/27/cxy/other/git-my-json-server/","tags":[["实用开源代码or工具","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81or%E5%B7%A5%E5%85%B7/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" my-json-server点击访问：my-json-server 1. 创建db.json文件并提交至master/main 2. 请求方式访问 [你的用户名]/[你的仓库名]，可以获取到api列表 比如，我的地址为： 点击页面提供的链接就可以访问到对应的api posts接口数据接口数据"},{"title":"【粤语】從電視劇積攢詞彙  1125","date":"2021-11-26T04:01:04.000Z","url":"/2021/11/26/other-yuewenziah1125/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 蚀 sit6動詞，吃虧 我哋一分钟都唔好蚀畀佢啊 我們一分鐘都不要吃虧阿 开茶 hoi caa在香港，去茶樓吃東西飲茶的時候，選用某種茶葉（jip）的動作叫開茶。 茶客找到位子后，侍应会开一张「点心卡」，上面写上人数（又称「茶位」)，然后会问客人「饮咩茶?」，一般有铁观音、普洱、香片、寿眉等可选择。 热茶送到后，茶客习惯先用滚茶冲洗碗筷和茶杯，才开始叹茶。 乜解救 mat1 gaai2 gau3= 點解，為什麼。 解救，辦法。 手機嘅图标都变白咗，有乜解救? （手機的圖標變白，有什麼辦法解決呢？） 乜解救啊？下午茶啫㖞，搅到好似中咗六彩噉啊？（為什麼阿？下午茶而已，搞得好像中六合彩似的。） 麻雀 maa4 zoek2= 麻將 我使靠呢啲？ ngo5 sai2 kaau3 ni1 di1 ？我需要靠這些東西阿？ 使：需要 周街 zau1 gaai1滿街，整條街，到處都。 梗系你周街啦又发埋啲不义之财。 識 sik1認識 jing6 sik1 鸡仔媒人 gai1 zai2 mui4 jan2 爱管闲事的人。我今日都嚟做翻一次鸡仔媒人啦！（我今天也来做一回管闲事的人吧！） 指随便、不管结果好不好的配媒。贬义， 𡃁仔 leng1 zai2少年及年轻人，有时带贬义”。亦有长辈如此称呼后辈，以表示亲昵。 注意同“靚仔” leng3 讀音的區別。 贪威识食 taam1 wai1 sik1 sik6愛出風頭，又喜歡揮霍。 个𡃁仔你睇个样啊，贪威识食啊。你因住害咗高小姐啊！ 因住 jan1 zyu6小心 你因住害咗高小姐啊。 熟面口 suk6 min6 hau2= 熟口熟面 形容對某人或某物有熟悉的感覺。 唔怪知咁熟面口啦～ 唔怪知：唔怪知得 白手兴家 baak6 sau2 hing1 gaa1= 白手起家 话时话 waa6 si4 waa6轉折（不過）話說回來。。。。。。。。 不过话时话，点解你可以介绍啲噉嘅笋盘畀阿高小姐㗎 拣 gaan2選 你拣人，人拣你 着紧 zoek6 gan2 對事情上點心哦。哩份資料趕住要用，你要著緊啲搞掂佢。 着急（gap）开完会,他着紧去施工现场 大上头 daai soeng tau期望好大。 一封利是仔加一杯珍珠奶茶，你就咁大上头噉？ 至得 zi dak。。。才行。 啊不过如果你想有高质素嘅男人咧就要成为鑽石级会员至得 佛都有火谁都会发火的 劳气 lou4 hei3生气的状态 唔好咁劳气啦 別這麼生氣喇。 鬼用以加強語氣。 争 zaang 意思之一係：差啲，差的意思。 其实大家姐同二家姐都拍紧拖㗎啦 你都识讲咯，系争你啊嘛 狗窦 gau2 dau3狗洞，狗窩 嗰条红衫魚啊，一定成世都黐住喺你个狗窦度嘅。 㷫 hing3生氣。 条气唔顺 tiu4 hei3 m4 seon6咽不下這口氣。 即但系我条气唔顺啊嘛，噉咪驳返佢咯 断正 tyun5 zeng3有人正進行某些非法行為，當場被「捉到正」（逮個正着）的講法。 吓陈师奶今次仲唔断正？ 吓！陈师奶這次還逮不到你？（金城安故意跌落錢畀陳师奶揀，然後當場逮到她揀到錢。） 回水 wui seoi退錢 啱嘴型 ngaam zeoi jing合得來，談得來 二撇鸡 ji6 pit3 gai1 依足 ji1 zuk1完全依照 你依足后生版嘅我帮佢揾个男朋友嗯 声大夹惡 seng1 daai6 gaap3 ok6指人大聲惡脾氣、無理取鬧。 你仲声大夹镬，系咪打得少啊？ 断线吉他冇得弹“冇得弹”是指无可挑剔、非常棒。 直头系断线吉他冇得弹啊～ 直头 zik tau 简直 直头系断线吉他冇得弹啊～ 径直；直接 直头揾佢哋董事长倾。（直接找他们董事长谈。） 应承 jing sing答應 应承我， 熄机 sik1 gei1關機。 需要電的東西通常用熄，“熄灯”“熄机”“熄火”。那么它们的反义词应该怎么说呢？叫“着咗个机”“着咗盏灯”。 收科 sau1 fo1收场、结局。 用于喻指较难收拾的场面 如果你唔去嘅话收唔到科㗎 如果你不去嘅話事情沒法收場。 ？到加零一非常，特別，極其。。。 蠢到加零一： 極其愚蠢。 衰到加零一：極其壞。 叻到加零一： 厲害嘅不得了哇吖！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ 爆樽 baau zeon用酒瓶爆頭。 响度 喺度 hai2 dou6 响度 hoeng2 dou6 響度 hoeng2 dou6 喺道 hai2 dou6 响道 hoeng2 dou6 響道 hoeng2 dou6 (廣東話) 放喺動詞之前，標示動作進行；同動詞後綴「緊」類似 (英文) placed in front of a verb to indicate that an action is on-going 例句： (粵) 我ngo5喺hai2度dou6諗nam2，人jan4生sang1嘅ge3意ji3義ji6係hai6乜mat1呢ne1？ (英) I was pondering, what’s the meaning of life? (廣東話) 表示對所描述嘅動作嘅蔑視或者不滿，要同有限定意思嘅副詞（「淨係」）、後綴（「晒」）或者語氣詞（「之嘛」、「啫」）一齊用 (英文) used to describe despise or contempt; must be used together with words or suffixes that indicate a sense of “limitation” 例句： (粵) 我ngo5喺hai2度dou6睇tai2下haa5書syu1之zi1嘛maa3。 (英) I’m just reading some books. (粵) 你nei5唔m4好hou2喺hai2度dou6阻zo2住zyu6晒saai3啦laa1！ (英) Don’t stand in the way! "},{"title":"【粤语】從電視劇積攢詞彙 1123","date":"2021-11-25T14:23:04.000Z","url":"/2021/11/25/other-yuewenziah536/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 1123 雞髀 （gai1 bei2）雞腿，單位：只 使唔使用不用 阴功猪可憐 呢啲噉嘅這樣的，這種的 喺埋一齐同。。。在一起，一般指情侶（leoi）在一起。 企埋一起： 站在一起 跌过落地掉在地上過。 嚿 （gau6）量詞：舊 一团，一件，一块 一嚿石头、一嚿面包 我都特登夹嚿跌过落地嘅鸡髀畀佢食 我專門夾（gaap）一個掉過地上的雞腿給（kap）他吃。 唔单止（ng4 daan1 zi2）不止 咪得咯（mai6 dak1 lok3）可以令到洪尚善踢走育（juk6）英咪得咯 激到成个弹起（gik dou seng go daan hei）激到：氣到 成個彈起：爆跳（tiu3）如雷 激到成个弹起：氣的爆跳如雷 挂住思念（si nim） 你挂住我啊？ 你想我喇？ 探（taam）探望 恁住嚟探下根叔啫嘛 無任歡迎（mou4 jam6 fun1 jing4）非常之歡迎 睬（coi2）理睬 人哋嚟咗你又唔睬我 人家來咗你又不理我。 明啲又唔明啲有些明白（baak），有些不明白。 邪花入宅風騷（sou）的女人進屋（uk），比如被不正經的女子纏（cin4）住 can/chan –&gt; caan caam cim cin 浸（zam3）淹（jim1） 碌落山坡（luk1 lok6 saan1 bo1）滾下山坡 碌：滾。 碌落山坡挂喺个树度一日一夜 醋埕 （cou cing）醋罈子 原来熊尚善系个大醋埕 专登= 特登 特意 兼且 gim1 ce2並且 闹衰 naau6 seoi1罵 兼且冒（mou6）你个女个名上网闹衰我 冒名頂替（mou6 ming4 ding2 tai3） 大龙凤 daai lung fung鬧劇（kek） 影相 jing soeng拍（paak）照（ziu） 家阵 gaa1 zan2現在 家阵 = 而家 家阵你噉样老屈你自己个女 老屈 lou wat= 屈 冤枉 你噉样老屈你自己个女 九唔搭八 x莫（mok）名其妙 真系唔用一啲人哋睇唔明嘅文言文，九唔搭八嘅文字落去咯。 开抽水post hoi1 cau1 seoi2 pou3聊天搬弄是非（bun1 lung6 si6 fei1）的帖子（tip3） 立乱 laap6 lyun2隨便，亂 听我讲，以后真系唔好立乱试枪 以后唔好再立乱用我个名出post 点算 dim syun怎麼辦 挛住挛住 lyun1 zyu6 lyun1 zyu6肚挛住挛住咁痛 晏昼 aan3 zau3下午 莫若我怪可別怪我 点点正正 dim dim zing zing恰好，剛巧，恰恰（hap）。 点点正正就系佢㖞 正好就係佢和。 實 sat6肯定，實在 佢實嬲咗育英 他肯定生育英氣喇。 帮手 bong1 sau2幫忙 熊尚善仲叫玉英帮手写剧本 一于 jat1 jyu1乾脆（gon3 ceoi3） 一於咁話：就這麼決定喇。 隻豉油 醬油，單位係只 ————————————————————— 動詞：攞=拎 執 掟=揼 撳 碌 浸 一粒（laap）女：一個女兒 惡俗（zuk）、任（jam6）何、不堪（ham1）入目（muk6）教育（juk6）垃圾（laap saap）趕稿（gon2 gou2）勸（hyun）踢（tek3）妒忌（dou gei）吝嗇（leon6 sik1）甚至（sam）之類 口吻（hau2 man5）集數（zaap sou ） 接近（zip3 gan6） 一于等我借故（ze3 gu3）接近（zip3 gan6）熊尚善 歡迎（fun1 jing4） 吸引（kap jan） 纏（cim） 盡量（zeon2 loeng6） 斷絕來往（tyun5 zyut6 loi4 wong5） 戀愛（lyun oi） 融洽（jung4 hap1）"},{"title":"【粤语】從電視劇積攢詞彙  1302","date":"2021-11-23T04:03:04.000Z","url":"/2021/11/23/other-yuewenziah1123/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 驚 geng擔心 （daam sam） 零舍 ling4 se3表非同一般的高程度；特别；尤其。 佢做得零舍快。（他干得特别快。） 咁多个当中呢个零舍好（这么多个当中这个尤其好。） 又写作：令舍。 嗯哇妈咪煲嘅嘢咧，0舍好食㗎啊 千秋 cin1 cau1秋千 饮啖水 jam2 daam6 seoi2喝口水 一系你哋咧出去饮啖水返嚟再讲过啊 孭 me1背 孭仔 ： 背小孩子。 平时舅父𠱁我瞓觉系会孭住我孭通宵㗎 淨係只係 我都唔敢要求你哋两个噉做，净系叫你哋讲古仔我听，估唔到你哋都唔系好情愿噉 撚烦 nan2 faan4= 捻烦，打扰，麻烦。 《西游记》第六九回：“ 行者道：‘无事不敢捻烦，请你来助些无根水，与国王下药。’” 讲哎呀我哋撚烦你啫嘛 仲使讲咩 zung6 sai2 gong2 me1那還用說？？ 唔觉唔觉 ng4 gok4 ng4 gok3不知不覺 唔觉唔觉买多咗咯 硬系 ngaang6 hai6非要，硬是，不聽勸（hyun3） 过桥 gwo kiu利用其他人去達成自己嘅目的 佢哋真系分明揾你过桥㖞 铲爆粗口（cou） 等我去铲爆佢哋上天花板 恶啃 ok3 kang 2形容难以应对某事或某人 你成日噉样真系好恶啃㗎 核突 wat6 dat6噁心 你估我唔知我扮女人好核突咩 估 gu 猜（caai） 覺得：你估我唔知我扮女人好核突咩 嚟紧 lei4 gan2之後，指不遠的將來 嚟紧我都会好似妈妈噉样去照顾你㗎 求其隨便 啖啖 daam6 daam6每一口 系咪啖啖都充满爱咧 搦 lik相當於 拎 ，拿 我搦返出嚟冇事嘞你放心啊 暗瞓 am3 fan3哄你睡覺（gok） 我每晚嚟暗你瞓觉，我暗完你我先瞓啦好唔好？ 古仔 gu zai故事 低庄 dai1 zong1卑劣，低劣（bei1 lyut3） 撩耳仔 liu2 ji5 zai2掏耳朵（tou4 ji5 do2） 佢话咧次次同philip仔撩完耳仔之后，philip都会瞓得好舒服㗎 污糟 wu zou髒（zong） 損 syun2傷 只系刮损少少啊 噉佢耳屎大嚿啊嘛 凑大 cau3 daai6照顧大 湊：照顧，湊仔：照顧小孩 织冷衫 zik1 laang1 saam1織毛衣 一学识啦 jat hok sik laa一學就會喇 肚饿 tou5 ngo6肚子餓 肚屙 tou5 o1拉肚子 刨书 paau4 syu1超級認（jing）真的讀（duk）書 都系因为你晚晚喺度刨书刨通宵喺度学织躝衫畀我，先会搅到病咗咋 重皮 cung5 pei2成本高，费用高，闊綽（fut coek） 啲餐好丰富（fung fu），Terry好重皮㖞 重手 cung5 sau2 闊綽，慷慨、大方。出手闊綽，不吝嗇。 重，粗魯 难得试镜成功重手少少都要㗎啦 畀心机 bei sam gei用心 你好畀心机帮我 你很用心的幫我。 乜都抵翻嗮一切（cit）都值得 抵 dai值得（zik dak） 急（gap） 叫（giu） 作（zok） 接（zip） 亦（jik） 色（sik）"},{"title":"【粤语】從電視劇積攢詞彙  718","date":"2021-11-23T04:03:04.000Z","url":"/2021/11/23/other-yuewenziah718/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 反口 faan hau否定自己原来说过的话。 系你自己讲㗎。你而家反口啊？ 睇蚀晒 tai sik saai畀人用眼睛吃豆腐。 我系惊我女朋友畀人睇蚀嗮，正常男人都会噉諗㗎啦。 好心= 唔該（動詞） 好心你个人啊，唔好咁保守啦。 一忽肉 jat1 fat1 juk6忽：單位 我畀人望一眼我系唔会冇咗一忽肉㗎，好心你个人啊，唔好咁保守啦。 ～硬一定要做某事。 但系而家我拍硬！ 听讲 teng gong聽說 唉听讲咧辑相系仁哥影㗎嘛，影完啊仁哥都眼啊生嗮眼挑针啊。 眼挑针 ngaan5 tiu1 zam1針眼 唉听讲咧辑相系仁哥影㗎嘛，影完啊仁哥都眼啊生嗮眼挑针啊。 痕痕哋 han4 han4 dei2唔舒服。 对眼仲有啲痕痕哋啊 死守烂守 sei2 sau2 laan6 sau2拼命守住。。。啲東西咁啩。 拗凸 aau3 dat6吃虧。 得滞 zung1 hoeng3 dak1 zai6太。。。過度 碟牛肉咸得滞。(这碟牛肉太咸了。) 乜滞： 不是很多。 呢班懒鬼冇上堂乜滞。(这班懒鬼没有怎么上课。) 咁滞：差唔多。 佢做起篇文咁滞。(他几乎做好了论文。) 就 zau 遷就（cin1 zau6）佢咁大男人咯，我咪就下佢咯。 抌 dam2動詞，扔（jing4） 抌咗佢，眼冤啊 眼冤 ngaan5 jyun1礙眼 抌咗佢，眼冤啊 ​ 裙拉裤甩 kwan4 laai1 fu3 lat1忙，手忙腳亂。 真系讲到裙拉裤甩啊。 激 gik動詞：氣 你头先系恁住激阿Lily baby嘅啫 禾稈冚珍珠 wo4 gon2 kam2 zan1 zyu1真人不露相（zan1 jan4 bat1 lou6 soeng3） 大细超 daai6 sai3 ciu1不公平的意思。 超是（用眼睛）看的意思。 大是瞧得起，细是瞧不起。 【说明】若有人偏心，处事不公平，可以用“大细超”形容他。 细妹参加选美着住泳衣去见人都系噉咯。冇理由一个畀一个唔畀噉咪即系大细招咯系嘛？ 嚟紧 lai4 gan2接着要到来的。 有几个嚟紧仲会准备出道拍戏。"},{"title":"【粤语】從電視劇積攢詞彙  550","date":"2021-11-22T15:03:04.000Z","url":"/2021/11/22/other-yuewenziah550/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 後生仔 hau6 saang1 zai2年輕人 落袋 lok6 doi2賺取純利，係可以收起俾自己 後生仔如果你等钱使咧，将你嘅千八蚊啊卖畀大陳，肯定有100万落袋。 唔怪得知 m4 gwaai3 dak1 zi1怪不得 串/寸形容某個人的行為好囂張 唔怪得知你唔睇投标结果，你惊衰咗畀大陳串。 萬歲 maan6 seoi3請人食飯 多谢嗮你喎阿辉，酒吧赚到钱就萬歲我哋下午茶吓。 肯 hang2願意 想揾人同佢调班，唔知有冇人肯制 找数 zaau2 sou3 結帳 今日呢餐我找數, 今天這頓飯，我來付款 ; 找錢 你仲未找數噃, 你還沒找錢 ; 履行之前答應過的承諾，於走數相對。 「計數」可以表示「計算」，也可以表示「算帳」，普通話照注音讀就行了。 「講數」普通話叫「談價錢」、「談判」；「找數」叫「結帳」。例如︰「老細同佢講緊數，唔知幾時先可以找數」可以說成「老闆正和他談價錢，不知道甚麼時候才能結帳。」 「著數」普通話可以說成「（佔）便宜」、「好處」、「甜頭」等等。「跟佢搵食冇乜著數」可以說成「跟他混飯吃佔不著便宜」，或者「跟他混飯吃沒有甚麼好處／甜頭。」 「算數」普通話說成「算了」，比如「過去嘅事算數喇」可以說成「過去的事就算了。」 夠晒數 • 入我數 • 出公數 粵語的「夠晒數」普通話叫「（全）齊了」，例如︰「交返來嘅子彈夠晒數」可以說成「交回來的子彈齊了。」 「入我數」普通話說成「算我的」、「算在我頭上」，比如「佢做錯嘅嘢都入我數」可以說成「他做錯的事也算我的／算在我頭上！」 「出公數」普通話叫「報銷」，也就是本地人常說的「claim錢」。例如︰「今次嘅機票唔可以出公數」可以說成「這回的機票不能報銷。」 踢嗮脚 tek3 saai3 goek3指忙得不可開交，事情都亂套了 /- Kai叔啊两杯斋啡 /- 喂等多阵啊，家下踢嗮脚啊 家下：呢一刻，= 而家 / 依家 / 家陣 / 現在 琴晚 kam4 maan5= 尋日（cam jat） 昨天晚上。 佢琴晚居然由得你饮醉酒 秘撈 bei3 lou1正式职业（全职）之外，秘密从事其它职务或者事务赚取外快。 你攞正牌秘捞㗎嘛，仲要保住寻宝图份工㗎。 攞正牌 lo zing paai有正当理由做不正當的事情 你攞正牌秘捞㗎嘛，仲要保住寻宝图份工㗎。 乸 naa2乸： 雌性動物，髒話。 呢度咧一定好多乸嚿嘢唔见得光，所以咧避你 企理 kei5 lei5整齊，有條理 不过睇落呢间嘢咧都算企理 立亂 laap6 lyun2乱，随便 佢唔係立亂介紹女仔畀你識㗎喇 唔声唔声 ng4 seng1 ng4 seng1不聲不響 唔好睇佢唔声唔声啊，嗰日你係名人飯堂走咗之后咧，佢喺佢老板面前赞你做嘢醒目。 醒目 sing2 muk6聰明，會來事。 拉埋 laai1 maai4将两人的关系拉近，或者是将两人之间的联系加强或者加固。 “拉埋天窗”指结婚。 人哋求我啊帮你拉埋。 人家求我撮合你們。 咪噉啦別這樣喇。 別這樣喇 捉錯用神 zuk1 co3 jung6 san4指揣摸别人的用意揣摸错了；误会别人的用意。你 哇原来大家都捉错用神。 （前因係今集大龍生話介紹一個大齡離過婚嘅女仔畀阿輝，阿輝以為係大小姐，其實係趙秘書。熊樹仁知道後對阿輝嘅說話。你） 恁返转头 nam6 faan1 zyun3 tau4回頭想想。 不过恁返转头都觉得自己天真，佢有乜可能会介绍自己个女畀我识啊？ 兜巴星 dau1 baa1 sing1 唔系兜巴星啊嘛？ 执生 zap1 saang1在事前没有准备或临时有变时，要懂得灵活应对。 你自己执生啊吓 你自已看着辦喇。 踎 mau1蹲 伏 计 gai3辦法 帮我执好嗮佢 bong1 ngo5 zap1 hou2 saai3 keoi5執：撿拾，收拾，準備 帮我执好嗮佢。 唔通 m4 tung1難道 唔通有人啊见钱唔开眼咩 夹份 gaap3 fan2夾：一起做。。。事情。 夾份：一起湊錢（cau3 cin2） 夾計：合謀（mau），串通。一起諗辦法。 ———————————————— 牵强（hin1 koeng5）"},{"title":"【粤语】從電視劇積攢詞彙 534","date":"2021-11-11T03:03:04.000Z","url":"/2021/11/11/other-yuewenziah534/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 𠱁/氹 tam3哄女仔 如果你啊再唔去𠱁返佢咧，佢迟早就畀人哋抢埋喇。 探 taam3探望 人哋下次嚟探你嗰阵时，你唔好喺度乱讲嘢啦。 人家下次來探望你你的時候，你不要在這裏亂講啦。 搏命 bok3 meng6拼命 呃呃氹氹 ngaak1 ngaak1 tam3 tam3騙一騙 ，哄一哄 搲 waa1/waa2抓，抓，用手指或爪抓：搲損面（抓破臉）．咪畀貓搲親（別給貓抓傷） 喂水啊你冇再搲啦，你睇你啲头皮多到好似落雪噉啊诶 搽 caa4敷、塗抹 衬 can3配（pui3）對，登對 冇，我只不过觉得你同阿龔都几衬咯 不是喇，我只不過都覺得你同阿龔都挺登對的。 無啦啦 mou laa laa= 無端端， 無緣無故 無啦啦做咩提到阿龔啫？ 無緣無故為什麼要提到阿龔呢？ 錫 / 惜 sek3疼愛，親吻（can1 man5）= 咀佢 怕丑 cau2害臊 害羞 不好意思 讲下笑啫，咁怕丑做咩啫？ 開過玩笑，這麼害羞做咩啫？ 咁啱啱可以指“對”，都可以指“巧”（kiu2） coupon kiu1 pon4我知係 coupon 嘅意思㗎，但係唔知佢哋點解話“kiu pon” 唔拘 ng4 keoi1無所謂， 睇多次都唔拘嘅 再看一次都無所謂嘅。 搅作 gaau22 zok3搞法，动作，新意思，新创意 原来华仔嘅演唱会咧今晚有新搅作啊 原來華仔的演唱會（jin2 coeng3 wui2）有新花樣。 饮歌 jjam2 go1指自己最擅長（sin6 coeng4）的歌 系我饮歌嚟㗎 是我擅長的歌嚟㗎。 咁恨恨：want 咁恨：want，want to do very very very much，really want to do it 唔通 ng tung難道 唔通你都同我一样咁钟意佢？ 難道你同我一樣這麼喜歡他？ 擘大口張大把口 胳肋底 gaak3 laak1 dai2抄 caau1翻 抄嗮啲衫裤鞋袜出左衬右衬。 翻出衣服褲子鞋子搭（daap）配半天 擗喺地下 pek6 hai2 dei6 haa2 x= piu1 扔（jing4）在地下 哩啡 le1 fe1不整齊；凌亂。 你間屋咁哩啡?。 你的房子這麼凌亂。 茄哩啡 ke le fe無關緊要嘅人，比如話。。。 赶头赶命 gon2 tau4 gon2 meng6急急忙忙趕時間 唉赶头赶命做起个promotion，攰死人啦 走數= 找數，履行諾言（lei5 hang4 nok6 jin4） 你哋想食啲咩去食我走数。 你們想吃咩，去吃，我請客。 掉（deu6）= 掟，扔咗 呢块饼做咩喺你度㗎？我明明掉咗㗎。 系世伯执返畀我㗎。 惊 geng1怕，恐懼。 你真系想听真话咩？我惊你唔敢听 呢番说话 ne faan syut waa這番話 你呢番说话咧，我之前已经听过。你唔系想𠱁我讲完真话之后，今次又再拒绝（ keoi zyut ）我啩？ 呢啲噉嘅 ni1 di1 gam2 ge3這個樣的 我唔会钟意你呢啲噉嘅贱精先生 飛 fei1動詞係：同你分手。甩（lat1）掉你你（fare） 甩底）（））：放鴿之，放飛機 平 ping便宜 亂噏 lyun6 ngap1亂講，噏：講，說。 照直 x有話就說 隔篱 gaak3 lei4 n隔壁（bik） 你你唔系去咗隔篱街嗰个灯柱度等我咩？ —————— 攝像機：sip3 zoeng6 gei1 合約：hap6 joek3 比較：bei gaau 說法：syut faat 戀愛：lyun oi 結婚禮物：git3 fan1 lai5 mat6 —————— 大多數時候“在”的適（sik1）用場景可以用“喺”代替嘅 正在做某事，正在=緊，緊放在後面，比如：正在走過嚟 == 行緊 啩，做為句末嘅語氣詞，有一種“假設（cit4）”嘅語意在呢度。 再做某事一次：用x多次，比如，再看一次—–&gt;睇多次。 係，可以表示“是這樣”，係至好阿，你是這樣做才好阿。 扎 —–&gt; 量詞，一束花。 hurt 傷害，但系我唔可以将你摆喺第一位㖞，你唔惊会hurt到你？？ 冻 —–&gt; 冷，出便 入便，裏邊。 "},{"title":"babel配置","date":"2021-10-24T22:21:49.000Z","url":"/2021/10/25/cxy/cxydeziwoxiuyang2/framework/babel/","tags":[["babel","/tags/babel/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、使用安装 配置文件Babel 有两种并行的配置文件格式，可以一起使用，也可以独立使用。 全项目配置babel.config.json/babel.config.js文件 注：可以是js文件，可以是json文件 Babel在项目根目录中自动搜索babel.config.json文件，或使用受支持扩展名的等效文件 文件相关配置.babelrc.json/.babelrc.js文件 注：可以是js文件，可以是json文件Babel通过从正在编译的“文件名”开始搜索目录结构来加载.babelrc.json文件，直至找到包含package.json的目录下。 二、预设预设是指预先在babel内部设置好的插件，可以直接使用。 示例： 1. preset @babel/preset-env 用于编译 ES2015+ 语法 @babel/preset-typescript for TypeScript 编译ts，替代了ts-loader @babel/preset-react for React使用preset预设在配置文件中添加presets字段，执行顺序是从右到左。 2. targettargets 是需要兼容的浏览器版本 他的值有： android, chrome, deno, edge, electron, firefox, ie, ios, node, opera, rhino, safari, samsung 可以设置成一个string，比如 &gt; 0.5%, last 2 versions, not dead 意思是有大于百分之零点五的人使用，前两个版本，并且没有废弃 3. useBuildInsuseBuildIns需要安装corejs使用 比如： false： 默认值，不做任何语法转换 usage：Babel 将检查你的所有代码，以便查找targets环境中缺失的功能，然后只把必须的 polyfill 包含进来 entry：引入所有的polyfill包，必须在入口文件加入 import &quot;core-js/stable&quot; 才会生效 4. corejs安装的corejs版本号 ####什么是corejs?babel编译只能针对浏览器行为，es6语法规定的，如promise、async/await则无法转义。这种情况下则需要配置corejs。之前这个操作通过babel-polyfill插件，但在7.4之后该插件已被废弃。"},{"title":"【粤语】從電視劇積攢詞彙 523","date":"2021-09-30T00:18:49.000Z","url":"/2021/09/30/other-yuewenziah523/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 523 發筍盤 sseon2 pun2原本係指一啲優質嘅樓盤，喺種種優越情況底下，呢種樓盤往往好快賣得出；後嚟呢個名詞，泛指一啲重未娶妻嘅男士，佢哋通常都喺樣貌或者事業方面有優勢。 食水深 sik6 seoi2 sam1= 獅子大開口 群姐，你都食水好深㗎 弊 bai6糟了，出问题=(廣東話) 大鑊 搅得掂 gaau2 dak1 dim6KC搅唔搅得掂㗎 KC行不行 掂（dim）：1. 得，滿意，做得好。2. 輕輕的觸摸（cuk1 mo2） 视像 si6 zoeng6視頻通話 哦噉即刻打个视像畀KC啊 喺齐度 hai2 cai4 dou6 x所有人都在這裏 姐夫乜你哋喺齐度啊 一齐 jat1 cai4一起 我哋仲一齐饮马头佬出嚟庆祝添啊 合時 hap6 si4 x正好 真系合时 叻 lek犀利，擅長（sin6 coeng4），666 好彩 hou2 coi2幸運（wan6），好運。 唔话得 ng waa dak无可指责，没话说 你真系唔话得 阻住 zo2 zyu6== 阻咗 防礙，阻礙。 你飞过嚟帮我会唔会阻咗你㗎 攞咗假 lo2 zo2 gaa3請好假 我今日都攞咗假嘅，所以冇事嘅噉 一阵间 jjat1 zan6 gaan1等會兒，稍後 话嗮 waa6 saai3 x到底，毕竟，好歹，说到底，不管怎样，不论怎么说 啊你太睇小你舅父饿喇，话嗮葡语啊系世界最广泛嘅四大语言 衰 seoi1不好 最衰寻日你又请咗假，如果唔系你葡語咁叻啊去澳门抢返单生意返嚟 嗮 saai 咗 zo晒：完全，全部 威嗮：讓你厲害完了 唔使畀大房威嗮啊 （就不至於讓大房咁威風巴閉） 住晒：整個都是你住的？ 在别人问你住哪里的时候， 你回答&quot; 住北京“，然后对方说：”你住晒咩？” 意思是“难道整个北京全都是你住的？” 属于调侃。 咗：完成，了的含義。 吊香鬼 diu hoeng gwai2= 吊靴鬼，跟屁蟲（gan1 pei3 cung4） 三尖八角 saam1 zim1 baat3 gok3比喻物体有周边有棱有角，难以触摸。后引申为形容人的外貌奇形怪状，或性格古怪，难失禮。 巖巖巉巉 ngaam4 ngaam4 caam4 caam4形容個面或五官凹凸不平，唔整齊兼唔好睇。 哇如果畀咗啲咧巖巖巉巉，三尖八角嘅女人戴嘅话咧，会变成点啊？又干又旱啊。 乞人？ hat jan讓人覺得？ 乞人憎：討人厭（jim） 係咪 hai mai是不是 提 tai4提醒 冇嘢啊？我请你返嚟提我嘢㗎。要我提你噉？ 你沒事吧？我請你回來是提醒我，反而要我提醒你？ 定啲嚟 ding6 di1calm down！冷靜點～ 累 leoi連累 真系系我累咗你啊 拗柴 ngaau2 caai4扭傷 （nau2 soeng1） 喂你次次走火警都话拗柴嘅？ 你為什麼次次走火警都說你扭傷呢？ 乜 mat在句頭用可以表示點解，怎麼？ 哎呀我都系为咗配合你哋㗎咋，乜你噉样讲嘢嘅啫？我都唔怕蚀底咯～ 蚀底 sikdai吃虧 （hek kwai） ↑ 食炸糊 sik6 zaa3 wu4失敗（sat baai） 空歡喜一場。 舅父你又食炸糊喇 卖剩蔗 maai6 zing6 ze3= 箩底橙，剩女 唔好以为我系卖剩蔗。 尽 zeon6過分 你使唔使讲得咁尽啊 揼 dam1扔 黑仔 haak1 zai2唔好彩 搽 caa4圖藥水 粒 lap1量詞，蚊子咬嘅包等等 一粒 兩粒 咁多粒 痛唔痛呀 饮得杯落 jam2 dak1 bui1 lok6 x舉杯暢飲啦，飲到杯都落埋tim 你今次出（ceot）手咁快系就饮得杯落喇 成功了就舉杯暢飲喇 预 jyu zo準備（zeon2 bei6）咗 睇小 tai siutai siu laa ######## —————— 咗其他 lift嘅量词係 架（gaa3）所有嘅大型機械都係 架 嚟㗎啵 樹嘅量词係 樖（po1）两樖树 石頭量词係 方（fong1 ）一方石 次數量詞係 鑊 （wok6）见你一镬，打你一镬 電器量詞係 部 （bou6）一部洗衣機 味道可以用 浸 （zam3 ）一浸味。 預約 book 嘅 —–&gt; 有疑惑嘅意思，在句尾。末（mut6）用佢賢良淑德飛 穿 —–&gt; 着 （zoek） 冇话佢听 —–&gt; 別告sou他 "},{"title":"【粤语】從電視劇積攢詞彙 541","date":"2021-09-30T00:18:49.000Z","url":"/2021/09/30/other-yuewenziah541/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 撑台脚撑台脚原本是指情侣吃饭时，双脚在台下都甜蜜地“依偎”一起。这个亲密动作后来专指情侣、夫妻拍拖用餐。之后，这个词的意思进一步扩展，泛指二人用餐 但我哋都公然喺度撑台脚㗎嘞㖞,咁样都叫地下情？ 储定人情嗌 aai3叫， 嗌交（吵架） 唉嗌埋单啊 唔觉意 m4 gok3 ji3唔经唔觉”意为不经意间、不知不觉的意思。 嘥gas saai1 saai3 gaaisi= 嘥氣，講完都冇用，浪費咗講嘅嘢。做嚟都冇用，浪費心力，徒勞無功。 好彩咧，有阿龔喺度啊。如果唔系啊，你听咗阿Mary姐讲老点，表错情啊，放错电啊，嘥嗮gas喎。 讲老点 gong lou dim广东省人和香港人都有人常用”老点“表示针对个人来做事，或骗那个人做某些事！ 例：你一味老点我。意思就是说你一味玩我。 講老點：誤導。 好彩咧，有阿龔喺度啊。如果唔系啊，你听咗阿Mary姐讲老点，表错情啊，放错电啊，嘥嗮gas喎。 拍得住 paak3 dak1 zyu6比得上。同“拍得过 (paak3 dak1 gwo3)”。佢啲“屈功”直成拍得住你㖞（他冤枉人的本事比得上你喔） 呢个牌子咧，只系做得身家要拍得住大龙山噉嘅客人嘅生意嘅啫。 开估 hoi1 gu2公开谜底。 仲估唔倒我就开估喇。（还猜不出我就说出谜底了。 倾偈 king1 gai2头先同你倾偈嗰两个trainee，边一个先至系陆爵士个仔啊？ 唔忿气 ng4 fan6 hei3不服氣 我话你冇眼光啫，唔使唔忿气都要嚟上诉嘛 疏爽 so1 song2形容一个人性格爽朗或出手大方。 我明明见到佢系乐于助人，佢好疏爽嘅啊。 顶肚 ding2 tou5充饥，解饿。 老友啊，嚟，买个饭盒顶下肚啦（豹叔畀錢乞兒） 揸水 zaa1 seoi2小便 我去揸水 心水 sam seoi2喜欢、偏爱。 我今晚刨咗好耐嘅心水骑士嚟嘅。 瞓身 fan3 san1全力，全身投入 麻烦你眼光帮我睇睇，边个有机会拉頭马，噉我就瞓身。 你幫我看看誰有機會贏，我全押上去這匹。 你你谂你 nei5 nam2 nei5你自己拿主意 褛 動詞，披。你褛住我件衫先得 名詞，外套。= 大褸 衣襟 执几剂= 执返剂，执返剂是粤语词汇，拼音是zhí fān jì，意思是去中药房选择几剂中药来煲药。 男欢女爱之事时，性欲可解释为欲火焚身，这时男女欢爱之事有如普降云雨而去火，形象而贴切，故有如”执翻剂中药”下下火异曲同工之隐喻。是故简言“执番剂” 佢仲要我一日执几剂添啊。 哇一日执几剂啊，你顶唔顶得顺啊？ 上得床嚟就轻被冚咯上了床，仲想掀被蓋上。 得寸進尺，得一想二，既得隴，又望蜀；成功！。（） 正所谓上得床嚟就轻被冚咯。 神神哋 san2 san2 dei2.有毛病，神經質，出了點問題, 指有點神經不正常, 你都神神哋嘅 ###。 食过返寻味 sik6 gwo3 faan1 cam4 mei6“食过返寻味”就是对于一些好味道的菜肴，吃过以后经常牵挂，想再次品尝一番。 好多游客品尝过广东美食之后都会食过返寻味。 —————————————— “想了半晌，只能用「還嘴」來形容。” 說個方言把這個台大外文系畢業的迷惑人奇怪的優越感釣起來了，不知道怎麼來的。又普又信。 想了半晌，那你問的是不是三歲小孩還是你女兒阿？ 普通話頂嘴，回嘴，反駁，爭辯，駁斥得唔得阿？要正式有正式，要口語有口語。 “懟”得唔得阿？不比你駁嘴簡單生動？？ ——————————————"},{"title":"【粤语】從電視劇積攢詞彙","date":"2021-09-29T00:25:49.000Z","url":"/2021/09/29/other-yuewenziah/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 主要是從愛回家之開心速遞裡面選的的的的的 嗱嗱声（naa naa seng）523嗱嗱声（naa naa seng）： “嗱嗱声”表示赶紧去办某事的意思。 你嗱嗱声打印几份资料出嚟，等阵开会赶住要用。（你赶紧打印几份资料出来，等下开会急着要用。） 細個（sai3 go3） 523細個：年幼时，小时候 我細個嗰陣時成日都喊㗎。 口花花（hau2 faa1 faa1）523口花花：形容人话多，油腔滑调（jau4 hong1 waat6 diu6），爱说不中用的话或不合适的话。 佢成日對住啲女同事口花花㗎 係咪（hai6 mai6）523係咪：是不是 嬲（nao1）523嬲： 生氣 執（zap）523執：（1）撿，拿，（2）收拾（ sau1 sap6 ） 不嬲（bat1 nao1）523一直，一向如此。 阿龔不嬲都係靚仔（leng3 zai2）嗰個噃。 似足（ci5 zuk1）523十分像 佢行步路都似足佢舅父 真定假（zan1 ding6 gaa2）523真的假的？ 撳lift門（gam6 mun4）523 x按電梯門 佢上次真係幫我撳過lift門阿。 拎過來（ling gwo lai4）拎：搦（nik1），拿、提、用力按壓的意思 拿過 我咪将自己杯咖啡搦畀佢咯 我便把自己的咖啡拿畀佢 喺度（hai2 dou6）（在）這裏 企（kei5）企：站。罰企：罰站。企度：站在那兒 你傻乎乎企响度做咩 倾偈（king1 gai）傾：談，倾偈：閒談 我哋倾下 埋（maai4）1，“汇总、结算”的意思，例如：“帮我埋一埋条数”＝“帮我结算一下”。所以“埋单”就是“结帐”的意思，而非买单。2，表示完成。用法跟英语的”完成时“差不多，使用时紧跟动词后面，表示动作完成。例：”食埋饭先走“=吃过饭再走。”收埋“=放好、藏好。“扫埋一堆”=扫成一堆（相似用法不同意思，表示”进行时“的，是”紧“，例：”食紧饭“=正在吃饭，“嚟紧”=在来的路上）3，表示聚拢、走动的动作，例：“埋去、埋嚟”=过去、过来。“埋堆”=合群、加入某人圈子。4，加入、合并的意思。例：“预埋我”=算我一份（我也要加入） 一陣（jat1 zan6）“一陣”指一小段時間，相當于普通話中“一會兒”的意思，“等一陣”就是等一會兒的意思。 相反，如果要表示“等不及”，廣東話可以説“等唔切（cit3）”。 等一陣：等會 一陣present畀大小姐㗎（一會兒要present給大小姐） 容乜易（jung4 mat1 ji6）乜在這裏表示強調，反問，假設（gaa2 cit3），這裏表示好可能，搞不好會。。。 參考 caam1 haau2 容乜易搅埋我㗎 （好可能連我都受sau害hoi添tim） 容乜易佢哋投反對票 （好可能他們投反對票） 幾咁（gei gam）幾：多少 幾咁：多麼 入嚟开会有几咁唔安全啊？ （進來開會有多麼不安全阿？） 通頂（tung1 deng2）通宵 我呢两晚已经为咗个presentation系噉通顶㗎啦 報警拉你（bou ging laai nei）報警揸你 行（hang）走 口響（hau2 hoeng2）嘴硬，光說唔做。 你知道佢唔够胆行出嚟所以先咁口响嗱 （你就是知道他不敢（gam）行出（ceot1）來所以才敢這樣說掛。） 緊（gan）正在 我睇下你恶得啲咩出样（ngo5 tai2 haa5 nei5 ok3 dak1 di1 me1 ceot1 joeng2）x我看你能有什麼花樣？ 出樣：同出面，意思係行為明顯，動機一睇就知。 你nei5做zou6得dak1咁gam3出ceot1面min2，係hai6人jan4都dou1知zi1你nei5唔m4鍾zung1意ji3佢keoi5啦 嘥（saai1）浪費 睺（hau1）x趁人不注意嗰陣 睺人瞓着咗，摸人大髀（daai bei）抽人水先得㗎？ 怎麼可以趁人睡着時，摸人大髀佔便宜（zim3 pin4 ji2）cdflsjds？ 先得（sin1 dak1）：才好 要揾个唔会穿煲嘅地万收埋先得啊 先得㗎？（sin1 dak1）*：含有一種反問質疑的語氣在，怎麼（ zam mo ）可以咁？怎麼可能咁？ 冇可能嘅，宁王又点会唔识唐伯虎嘅画先得架？！ 折墮（zit3 do6）缺德（kyu3 dak1） 噉样好折堕㗎 你這樣好缺德㗎。 㩒住（gam zyu）同撳住，按住lift門嗰個詞語 掂（dim）x碰（pung） 接觸（zip3 zuk1） 咦阿龔喺呢个时候掂都冇掂过阿Mary 屈（wat）= 老屈，冤枉（jyun wong） 你做乜嘢要屈我啊 飛「Fare」門票，戲飛、演唱會飛、船飛 瞌着咗 ‘ hap1 zoek3 zo2 ‘ x短暫而且淺嘅睡眠 但系嗰日我喺度瞌着咗，感觉有人摸我大髀，我就醒咗。跟住就见到杯森林咖啡喺台面，同埋你你你你你你你你背影。。。 第日 （dai jat）x將來 掹（mang）拉，拉下來。 費事（fai si）免得，避免（bei6 min5）某事 發財（faatcoi） 凍親（dung can）凍着 天氣預報話哩兩日會有冷空氣，你要小心凍親 一係（jat hai）或者，要不。 一系吃火锅，一系吃烤肉 激嬲 （gik1 nau1）惹她發脾氣。 自拍 selfie唔夠膽（ng gau daam）不敢做某事。 搏（bok1）希望，企圖，試圖，欲望 专门将细细个啲相咧攞出嚟搏同啲女同事咧打开话题㗎嘛 得意（dak ji）可愛 定係 （ding hai）或是waak。 晒（saai）咗（zo）晒：完，全部 咗： 食咗未呀 ：”吃（饭）了吗？“回答”食咗“。“食晒未呀 ”=”吃完了吗”。所以别人问你“食咗（药）未呀”，一般情况下是一种建议和关心；而“食晒（药）未呀 ”，更关心的是食物本身的完成程度。 啲咩 （di me）啲： 一些，一點兒，唔多 我仲边有时间上睇啲咩秘密网阿 返到（faan dou） 返嚟（faan lai）返到：回到 返嚟：回去 今朝返到嚟公司个个对我都好似生人勿近噉样嘅吓 净系（ zing hai ）解釋：. (廣東話) 唯獨；只係；除咗⋯…之外，冇其他. (英文) only and no more; just. 例句：. (粵) 淨 zing6 係 hai6 得 dak1 個 go3 講 gong2 字 zi6 。 净系识讲葡语㗎啫㖞 即系（zik hai）就係話 久唔久 （gau ng gau）時不時噉搬水你 —————— 可以替代嘅字積累（zik leoi） 進 –&gt; 入 两个人点都安全过我一个啊 不知係這或者那個時，可以講“啲”或者係唔講任何代詞“佢”，阿都可以指人嘅 为咗个presentation 企度 喺度 你把聲 你的聲音，音樂（jam ngok） 即係 –&gt; 就是話 ​ ​ 啫 [ze3]，有而已嘅語氣係度 咪：不就xxx樣的做咗 hot 喝 –&gt; 呷（haap）、飲 。呷醋（cou）。 ​ 咪住先—&gt; 等陣 —&gt; 等等 幾時 —&gt; 什麼時候 跟住 —&gt; 然後，接著 台 —&gt; 桌（coek）凳 —&gt; 椅子 代詞不知係邊個人，可以用“阿” —————— 夢忙盟猛门 冇你咁好气：表示不愿意和对方继续说话 担凳：搬凳子 爭zaang1 啲di1：差點 人哋： 別人 喐下喐下：一动一动"},{"title":"【粤语】粵語語氣詞","date":"2021-09-27T00:25:49.000Z","url":"/2021/09/27/other-yuewenzi/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 粵語是一種極其豐富的語言，其句末語氣詞的使用對於溝通至關重要。如果不正確使用，就可能造成嚴重的交流障礙。在這篇文章中，我們將列舉出所有常見的粵語句末語氣詞以及它們的推薦用法，讓大家能夠寫出符合標準的粵文。 選字原則我們在選擇句末語氣詞時，遵循一個漢字對應一個語素的原則。對於音節相同的字，我們一般將第 1、3、4 聲定爲獨立的語素，而對於第 2、5、6 聲視爲變調。因此，我們推薦使用標點符號來表示變調，而不再另外指定漢字。例如，推薦使用「㗎？」來代表 gaa2，而不是使用「𠿪」。 對於大部分 aa 開音節語氣詞，我們推薦不區分 aa 和 a，例如 laa3 和 la3 視作同一語素。 注： 1. 例句与备注出自粤拼、香港粵語大詞典、粵典，以及我从电视剧中摘抄下来的例句，為防止謬誤，會單獨進行標注。仅供参考。 2. 標註為 ★ 的部分代表了我透過除上述資料外，另行資料搜集所得到的總結。然而，值得特別關注的是這些資料的來源可能存在著不一致性和雜訊，因此其準確性存疑。 句末語氣詞推薦用字表 推薦用字 拼音 例句 備註 ★ 吖 aa1 1. 唔該畀兩個橙我吖。 多用於祈使句。表示提議，請求等。 啊 aa3 1. 你去唔去睇戲啊？ 2. 做完功課先好出街啊。 多用於陳述句 呀 aa4 噉唔通乜都唔使做～。 aa5 用「呀？」表示，亦可用「咓」。 噃 bo3 1. 你唔好唔記得噃。2. 唔可以同異性私聊個噃。（爱回家之开心速递1604，龔燁台詞） 1.表示转告、商量、祈求、警告； 2.表示醒悟、赞赏；（~個噃） 𠿪 gaa2 前提係做得出先得𠿪。 表示疑問時，建議「㗎？」來代表 gaa2 㗎 gaa3/ga3 唔係噉樣～。 問句中的 gaa2 用後加問號表示，例如「冇理由㗎？」。 嘎 gaa4/ga4 1. 乜原來要收畀錢嘎？2. 你講真啲嘎？ 表示驚奇、責怪，問或反問 𠺝/嗝 gaak3 你平時好飲得𠺝，點解而家咁快就醉。 「嗝」作爲後備用字，首選唔推薦使用 嘅 ge3 1. 做乜冇人嚟嘅？2. 我點都唔會走嘅。 1. 語氣詞，疑問或反問。2. 助詞。 啩 gwaa3 1. 唔係啩！？2. 應該係啩？3.一個應該夠了啩？ 表示惊讶或不確定的疑问。 吓 haa2 1. 吓，噉都得？ 2. 你做咩对阿高大壮咁事事关心啊吓？（忠奸人08-劉淼）3. 記得食飯啊吓。 1. 吓作為前置語氣詞，表示驚訝；2. 有時單獨使用，表示聽不清（pardon？）或不理解。3. 不作為前置語氣詞時，表示囑咐、提醒。★ 嚱 he2 呢套戲幾好睇嚱？ 表示疑問 嗬 ho2 噉就夠嘞嗬？ 征求对方意见或寻求认同。 啦 laa1/la1 就噉先啦。 喇 laa3/laa4 1. 你點講佢都唔會明㗎喇。2. 噉就得喇？ 本方案用標點區分 laa 第 3 聲同第 4 聲，如例句 1 爲 laa3，例句 2 爲 laa4。 嘞 laak3/lak3/la3 係嘞，你有冇帶遮？ 了 咧 le4 我送你五萬個口罩～，好唔好啊？ 解釋 同 「哩」 哩 le5 1. 我唔系呃你哩。2. 你而家知唔得哩？ 1. 希 望對方接受或相信自己的意見。2. 用于反问句，表示不出所料 囉 lo1 噉你去囉。 咯 囖 lo4 係～，點解你自己唔去呢？ 同 「 囉 」 咯 lok3/lo3 都話咗係噉～。噉就弊家伙～。 同 「囖 」 嚕/𡀔 lou3/lu3 1. 我做完功課嚕。2. 咁我自己走先嚕。 1. 表達自己覺得慶幸、輕鬆的狀態轉變。2. 用來講出自己或者大家準備做的行動 嗎 maa3/ma3/maa1 你好～？ 嘛 maa5/maa3 唔係啊～？所以先話吖～。 咩 me1 1. 佢唔係好叻嘅咩？2. 你睇唔睇到佢拎緊咩呀？ 1. 疑問代詞；2. 「乜嘢」的合音 嗱 naa4 1. 嗱，就喺呢度。2. 你走嗱？。 1. 前置助詞，用來吸引人注意。2. 用在問句後面，表示想對方確定 呢 ne1/le1 佢係做咩嘅呢？ 問句後面疑問助詞，表示自己思考這個問題ing 添 tim1 我以爲你會去埋佢屋企添。 又寫作「㖭」同「𠻹」，這兩個字僅作後備用字，首選不推薦使用 喎 wo3 佢唔喺度喎。 表示自己的理解和事實有較大出入。 啝/咊 wo4 篇文原來係佢寫嘅啝。 同「喎」 𡁜/唩 wo5 佢話佢唔去～。 同「喎」 咋 za3/zaa3/zaa5 1. 我就得翻兩文咋。2. 哦，就係噉咋？3. 一个月三百文咋。（一个月才三百块。） 而已。本方案用標點區分 zaa/za 第 3 聲同第 5 聲，如例句 1 係 zaa3/za3，例句 2 係 zaa5。 喳 za4/zaa4 就得咁多喳？ 同「 咋 」 啫 ze1 1. 無非都係噉嘅啫。2. 我买啲咖啡请人饮都系好正常啫 表示「就那樣」的程度的 唧 zek1 究竟發生咗咩唧？ 組合語氣詞示例 漢字 拼音 例句 備註 吖嘛 aa1 maa3 / a1 maa3 1. 飲益力多，有益健康吖嘛。2. 你唔得閒去攞份文件，叫佢送過嚟吖嘛。3. 得喇，出門之前要閂窗吖嘛。 1. 表示道理、原因顯著；「對吧？」2. 表示建議，帶有教育的口吻，說話者認為自己的建議明顯比對方所想或所選 擇的好；「可不可以阿？」3. 表示說話者清楚知道和記得某事，不用對 方再提醒「對吧？」。4. 表示關心、詢問 啊嘛 aa6 maa5 / a6 maa5 唔係噉啊嘛？ 哎吖吖 ai1 aa1 aa1 哎吖吖，做乜搞成噉啊？ 「哎」字可爲 ai1 或 aai1，下同。 哎吔/哎吔吔 ai1 jaa1/ai1 jaa1 jaa1 哎吔！豈有此理！ 哎呀 哎呀 ai1 aa4/ai1 jaa5 ～，你唔係噉啊嘛？ 𠺢嘛 gaa1 maa3/ga1 maa3 佢傻𠺢嘛，使乜理佢唧？自然嘅嘢唔一定就係好𠺢嘛。 「嘅」和「吖嘛」的合音，表示這應該是對方理應知道的事兒，或是必然會認同的判斷。 㗎咩 gaa3 me3/ ga3 me3 今日唔係放假～？ 用反问句表现出惊讶 㗎嘛 gaa6 maa5 / ga6 maa5 唔係噉～？自然嘅嘢唔一定就係好㗎嘛 「嘅」和「吖嘛」的合音；加在句子後面，表示這應該是對方理應知道的事兒，或是必然會認同的判斷。 嘅啫 ge3 ze1 無非就係佢一個人～。 嘞噃 la3 bo3 / lak3 bo3 你好嘞噃！唔好再得寸進尺～！ 禁止 吓話 haa6 waa5 / ha6 waa5 1. 係得咁多吓話？2. 「呢隻股票實升㗎！」「吓話？」甲：我贏梗！ 表示難以置信，甚至完全不信 重拍？咩嚟㗎 ge le me—————— 作 zok3 明 ming4 感 gam2 看 hon3 版 baan2 挺 ting5 鬆田祥太 sung1 tin4 coeng4 taai3 來 loi4 繼續 gai3 zuk6 忘記 mong4 gei3 今天 gam1 tin1 足跡 zuk1 zik1 給 kap1 翻譯 faan1 jik6 轉換 zyun2 wun6 說 syut3 復fuk6 活wut6 冷laang5 靜zing6 對deoi3 付fu6 歸gwai1 納naap6 事si 實sat 建gin3 設cit3 堅gin1 持ci4 詢seon1 問man6 審問 sam2 man6 尋cam4 找zaau2 五ng5 六luk6 七cat1 八baat3 桌coek 子zi2 里lei5 面min6 說syut3 話waa6 存cyun4 儲cyu5 硬ngaang6盤pun2 繪kui2畫waa2 創建模型遠程 cong3 gin3 mou4 jing4 jyun5 cing4 實sat6 力lik6 除非 ceoi4 fei1 灌溉 gun3 koi3 深cam1不bat1可ho2測cak 興趣（）（hing ceoi） —————————— 523 嗱嗱声（naa naa seng）嗱嗱声（naa naa seng）： “嗱嗱声”表示赶紧去办某事的意思。 你嗱嗱声打印几份资料出嚟，等阵开会赶住要用。（你赶紧打印几份资料出来，等下开会急着要用。） —————— 夢忙盟猛门 冇你咁好气：表示不愿意和对方继续说话 担凳：搬凳子 爭zaang1 啲di1：差點 人哋： 別人 喐下喐下：一动一动"},{"title":"【粤语】粤拼总结笔记","date":"2021-09-25T00:25:49.000Z","url":"/2021/09/25/other-yueping/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 粤拼教学：点击访问 七个主要元音：aa e i o u yu oe粤语可以多个韵母组合 双元音元音和元音的组合 除了元音与元音的互相组合外，元音一般可以加：m/n/p/t/k/ng 19个声母b p m f d t n l g k h gw kw w z c s j ng 七个主要元音 + maameimouyuoe 七个主要元音 + naaneinonunyunoe 不存在加n 七个主要元音 + ng iu也有后面介绍。 七个主要元音 + p 七个主要元音 + t 七个主要元音 + k iu也有后面介绍。 aa和a长aa 短a oe和eooe发音长（🤮）eo发音短 （鹅噢）eo发音类似拼音（e）粤语里的e发音和拼音e不一样 前面说要补充的ng和k的两个ing ik ung uk"},{"title":"我的喵有时候超级聪明,有时候又超级笨","date":"2021-09-23T04:00:38.000Z","url":"/2021/09/23/diary/diary-sxh%20copy/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 可撸可抱可亲亲。怎么样都不生气。通人性，很多情况下知道我在说什么。很粘人，我上厕所因为要在浴室，总担心我淹死，只要不让它进来在我脚边蹲着，它就叫的相当凄惨。然后我站起来冲水的时候，它听见冲水的声音，就站起来往外走。明明自己超级害怕浴室。 对人如春风般和睦，对其他物种们如饿狼般凶残。我养了喵之后，屋里再也没有虫了。。自从我亲眼见到。。。算了，有些东西不能细想。 喜欢撒娇娇，我睡觉手摊在旁边，第二天起来手掌上一定会多个喵头。可以明白我的指令，如果我把它摆成一个姿势，它不喜欢就喵喵的反抗，但如果我重复五六次，它就明白了我是想让它保持这个姿势。 熟悉我的说话口气，知道我什么时候生气什么时候不生气。我普通生气的时候赶紧卖萌撒娇娇打滚滚，我生大气的时候就躲起来，可是它不知道我很生气的时候它越躲起来我越生气，特别是往特别脏的床底下钻的时候。 每天喜欢和我玩捉迷藏，它的捉迷藏理念就是我看不见你，那你肯定也看不见我。所以它总是把头藏起来，把身子露在外面，就当藏好了。唔 还有笨的情况就是可能因为从没出过门，是个路痴。我住在七楼左边，如果把它放六楼，或者五楼，或者四楼，它就会对着四五六楼左边一直喵。 每天我回来喜欢在门口迎接，以至于有一次太久不见，我半夜回来之后提着大包小包的行李，它窜到门口来接我，结果不小心给它关外面了。。我还没有意识到，然后收拾东西到四五点，听见外面一直有喵在凄惨的叫，我还想这谁家的喵大半夜的搁这儿叫，结果又收拾了一会儿才发现，吖！原来是大喵在叫。 大喵年纪比较大了，有时候我会很害怕，它的后槽牙也开始出问题了，感觉眼睛好像最近会过敏。 因为断网玩这个东西玩了半个多小时 "},{"title":"在自己的网站中集成h5音乐播放器","date":"2021-09-11T10:48:34.000Z","url":"/2021/09/11/cxy/other/aplayer/","tags":[["实用开源代码or工具","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81or%E5%B7%A5%E5%85%B7/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 简介： APlayer 是一个可爱的 HTML5 音乐播放器。（官方原话） 地址：点击访问 安装使用 npm: 使用 Yarn: 使用 使用模块管理器: 参数介绍（可见官网） 名称 默认值 描述 container document.querySelector('.aplayer') 播放器容器元素 fixed false 开启吸底模式, 详情 mini false 开启迷你模式, 详情 autoplay false 音频自动播放 theme '#b7daff' 主题色 loop 'all' 音频循环播放, 可选值: 'all', 'one', 'none' order 'list' 音频循环顺序, 可选值: 'list', 'random' preload 'auto' 预加载，可选值: 'none', 'metadata', 'auto' volume 0.7 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 audio - 音频信息, 应该是一个对象或对象数组 audio.name - 音频名称 audio.artist - 音频艺术家 audio.url - 音频链接 audio.cover - 音频封面 audio.lrc - 详情 audio.theme - 切换到此音频时的主题色，比上面的 theme 优先级高 audio.type 'auto' 可选值: 'auto', 'hls', 'normal' 或其他自定义类型, 详情 customAudioType - 自定义类型，详情 mutex true 互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器 lrcType 0 详情 listFolded false 列表默认折叠 listMaxHeight - 列表最大高度 storageName 'aplayer-setting' 存储播放器设置的 localStorage key "},{"title":"【杂七杂八】第八节 构成","date":"2021-08-19T17:12:11.000Z","url":"/2021/08/20/klgc8/","tags":[["课程","/tags/%E8%AF%BE%E7%A8%8B/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、排版排版能够为作品加高完成度 描边：为整体描边，可以强调主体。 加文字：找一些免费商用的字体，如字由 加背景：背景不要比前景复杂。不要本末倒置。 找一些样机（比如淘宝），按照平面设计样机去排版。 二、海报海报样点海报没有什么故事性。 海报要注意前后遮挡关系，透视不是最重要的。 海报要注意主次疏密。一般是画前景中近景，很少有画全景，因为很难体现重点。阿 海报的好用构图 对称构图 并不是说要轴对称，只是说图内的元素最好对称。 比如说，左边有一朵云，右边有一个兔子。但是不要完全对称。 元素边框 为整个稿子加一个边框，就像是装裱画那样。 x型构图 "},{"title":"【杂七杂八】第六节 Q版元素的结合","date":"2021-08-16T07:15:20.000Z","url":"/2021/08/16/klgc6/","tags":[["课程","/tags/%E8%AF%BE%E7%A8%8B/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、用户职业的结合好看远远大于有趣 画画中要选职业特点非常明显的，比如外卖小哥，厨师，工人，程序员 dk大百科这本书的东西有各种元素，都是现实的元素。所以直接拿来用、结合，或者自己转q版，（或者用ai。。） 参考尽量去找自己喜欢的，大家喜欢的。比如动物。 要保留识别度 一张画只有一个好点子就算一张很好的画了。所以如果有多个好的结合点子，就分开画两张 二、联想方式 颜色 元素 形状 想画出让人喜欢的东西，一是同人，二是瑟图，三是分析受众，根据受众去绘画。猫狗食物 头脑风暴 杀猪刀 小王子抓着一串葡萄飞上天 冰淇淋和圣诞树 孔雀背后的羽毛做扇子 蘑菇水母"},{"title":"【杂七杂八】第七节 配色与材质","date":"2021-08-16T07:15:20.000Z","url":"/2021/08/16/klgc7/","tags":[["课程","/tags/%E8%AF%BE%E7%A8%8B/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、 配色1. 靠刻板印象配色画画前想好自己要画什么，比如说 性格（少女？甜美？帅气？硬朗？）？ 性别（男？女？）？ 季节（春？夏？秋？冬？） 时间（早？中？晚？） 总结一些关键词，从这些关键词中，会进一步联想到的颜色。比如说甜美、少女 —&gt; 粉，然后就去想想关注过什么画粉画的很好的画师，然后去找参考。而不是上来就搜少女配色，那搜出来的不太精确。所以平时要多积累。 2. 自然色大自然中很多物品的配色是很和谐的吖，比如说水果吖什么的。 3. PCCS色调图见文章 PCCS色调图 4. 配色方式拿到喜欢的参考图，分析 明度对比？几比几 色相对比？几比几 饱和度对比？几比几 分析画面的时候，吸色没关系的拉。 一张图好看的原因吖，无外乎是造型？颜色？光影？刻画？需要好好的分析吖 最好去找一个作者的多张图，而不是多张图不是第一个作者。 具体步骤： 判断图中配色是PCCS的哪个区间？ 自己配色选取该区间 处理线稿 线稿的处理：基色的基础上，饱和度增加，明度降低。 5. 荧光色（青品黄）的配色： 画画时明度达到100%是最好的，如果更改明度会变脏。 更改明度的方法，可以通过更改一点点色相的方式。 不要饱和度达到100%，最好的区间是50%左右（及以下） 阴影色：像红绿蓝偏移，（可以适当升高饱和度），不要直接去更改明度 二、材质*材质的话最好找平面的图，而不是真的材质吖。 "},{"title":"bodymovin使用","date":"2021-08-11T10:48:34.000Z","url":"/2021/08/11/cxy/other/bodymovin/","tags":[["实用开源代码or工具","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81or%E5%B7%A5%E5%85%B7/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 最近要做一个复杂嘅年度报告交互动画，年底惊喜夜又要做年度报告又要做，时间只有一晚黑。。搵了好耐终于畀我搵到一個bodymovin同埋lottie-web可以用嘅。捻住記下先la~ Bodymovin 简介Bodymovin是一个开源的JavaScript库，它用于将After Effects动画转换为可在Web上播放的HTML5动画。它使用Adobe After Effects的动画数据，将其转换为可在Web浏览器中播放的JSON文件。 使用Bodymovin的步骤： 在After Effects中创建动画，确保它们满足Bodymovin的要求：所有元素都必须使用2D变换，而不是3D变换，并且不能使用任何第三方插件。 在After Effects中安装Bodymovin插件，它可以从Github上下载。 将动画导出为JSON文件。 将JSON文件上传到您的网站，并使用Bodymovin JavaScript库在网页上播放动画。 在网页上定制动画，以获得最佳效果。 AE端：1. 官网下载bodymovin后，安装并打开github地址提示：mac m1系统请通过ZXP Installer安装。 2. 左侧选择要导出json的图层，右侧选择导出json的文件夹。完成后点击”render”即可。 提示：若遇到写入不成功的问题，请检查是否开启脚本写入文件。位置：After-Effect - 首选项 - 脚本和表达式 详细代码（js）webpack(5)中，处理图片和json webpack4用file-loader同埋url-loader处理，代码不写了。 入口文件，安装并引入bodymovin同埋json同埋图片如果图片较多，可以像我一样处理，用webpack的require.context方法，一次性引入所有图片（es6的按需引入也行，看自己呗。） require.context是webpack提供的一个函数，它可以接受三个参数：一个要搜索的文件夹目录，一个是否搜索子目录的布尔值，一个匹配文件的正则表达式。它可以返回一个函数，这个函数可以接受一个参数，这个参数是要引入的文件的相对路径，然后它就会返回这个文件的模块。require.context可以帮助我们实现按需引入模块的功能，从而减少代码体积。 扩展：(svg矢量图形转换为标签)[]完成。！。！。！。！。！。！。！。！。！。！。！。！。！。"},{"title":"【杂七杂八】第五节 Q版全身","date":"2021-08-07T07:15:20.000Z","url":"/2021/08/07/klgc5/","tags":[["课程","/tags/%E8%AF%BE%E7%A8%8B/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、 信息量 外轮廓 2. 服装配置 3. 明暗对比 有些真人照片，确实是q版无法还原的。"},{"title":"【Midjourney】用ai绘画生成的图","date":"2021-08-03T07:23:38.000Z","url":"/2021/08/03/paint/paint-picture2%20copy%202/","tags":[["Midjourney","/tags/Midjourney/"],["ai繪畫","/tags/ai%E7%B9%AA%E7%95%AB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 今天在discord玩了特别有意思的ai绘图，生成的图有些很糟糕，有些还是挺好看的~但基本不会生成你脑海中的图，觉得可能适合策划用吧，和设计沟通时可以更具象的去描述他自己想要的那种什么五彩斑斓的黑啥的。。。 记一下我的描述关键字There are many flowers on a skull,32k, 3D shading, Tone Mapping, elaborated, Procreate, the last of us look alike scene, Cinema 4D, ROMM RGB, color grading, retouch, blender, V-ray 下面是两张discord看到感觉比较好的。lake boat blackduck bluesky one pumpkins , intricate, elaborate, by artgerm and greg rutkowski and alphonse mucha, cinematic lighting, 32k, 3D shading, Tone Mapping, Ray Traced, Diffraction Grating, Crystalline, Lumen Reflections, Super-Resolution, gigapixel, color grading, retouch, Blender, V-ray, Procreate, zBrush, UE5, Cinema 4D, ROMM RGB, Adobe After Effects, tight shot, sharp focus –ar 16:9 –test –creative –upbeta santa claus guitarist of the death metal band , HD, ultra detailed, hyper realistic, fine detail etc, cinematic high detailed, octane render, ultra realistic, unreal engine, 8k –ar 9:16 –test –creative –upbeta a 20m-long flying dragon attacking HMS Warrior in the ocean, detailed, cinematic, 4k –ar 16:9 lake boat blackduck bluesky one pumpkins , intricate, elaborate, by artgerm and greg rutkowski and alphonse mucha, cinematic lighting, 32k, 3D shading, Tone Mapping, Ray Traced, Diffraction Grating, Crystalline, Lumen Reflections, Super-Resolution, gigapixel, color grading, retouch, Blender, V-ray, Procreate, zBrush, UE5, Cinema 4D, ROMM RGB, Adobe After Effects, tight shot, sharp focus –ar 3:5 –test –creative –upbeta –upbeta –upbeta one pumpkins , intricate, elaborate, by artgerm and greg rutkowski and alphonse mucha, cinematic lighting, 32k, 3D shading, Tone Mapping, Ray Traced, Diffraction Grating, Crystalline, Lumen Reflections, Super-Resolution, gigapixel, color grading, retouch, Blender, V-ray, Procreate, zBrush, UE5, Cinema 4D, ROMM RGB, Adobe After Effects, tight shot, sharp focus –ar 3:5 –test –creative a knight holding a longsword downward on purple wasteland, dark night with heavy rain and lightening, gloomy, dark, horror –ar 16:9 "},{"title":"【杂七杂八】第四节 形体基础与变形","date":"2021-07-31T10:15:20.000Z","url":"/2021/07/31/klgc4/","tags":[["课程","/tags/%E8%AF%BE%E7%A8%8B/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、三头身和二头身 基本比例肩宽（六头身）：男四头宽，女三头宽 肩宽（q版）：男 —–&gt; 三个脖子。女 —–&gt; 两个 检查原则：肩膀是溜肩，肩宽小于头，侧身不要太薄 手的绘画将手简化为如下的三部分结构，手掌、手指、拇指 画出基本结构后，根据基本结构进行细化 二、 变形的方向下图中的每个颜色代表一个结构，通过改变每个结构的大小，做人体的变形。 趋同和差异：通过改变每部分的比例，去做趋同和差异。当比例接近则为趋同，当比例变大则为差异。 趋同时要注意：保留特征的趋同。而不能过分趋同以至于让物体的特征不明显。 差异：将特征放大，将非特征减少。 这个课程的内容基本就是做趋同。我平时好像是比较喜欢做差异。 绘画的步骤：1. 提取1级形33333拿到照片，先概括大形状 2. 趋同根据大形状，自己处理比例 3. 可以背下来这些形状进行素材积累吖，建立自己的形体库吖形体相同，内容圣斗 三、 人体比例"},{"title":"【杂七杂八】第三节 头像基础","date":"2021-07-28T10:15:20.000Z","url":"/2021/07/28/klgc3/","tags":[["课程","/tags/%E8%AF%BE%E7%A8%8B/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"头像的特点年龄越小，头像越圆，五官越紧凑 多默写，有80%相似就算过关。如果不行就继续改一下，然后继续默写。画 — 默 — 改 — 画 * 2 画表情时，鼻子是最优先可以被省略掉的，除非是不能去掉的特征，比如大象鼻子，比如小丑鼻子，比如猪鼻子。 画照片的目的：练简化。积累素材 画丑角"},{"title":"【杂七杂八】第二节 色彩基础","date":"2021-07-27T10:15:20.000Z","url":"/2021/07/27/klgc2/","tags":[["课程","/tags/%E8%AF%BE%E7%A8%8B/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、色彩基础因为有基础，所以稍微记些重点 青品黄在电脑上绘画很好看，但在产品设计中最好不要用。因为青品黄打印模式下是比较暗的 变成黑白的话，如果配色看上去不奇怪，基本配色不会有大问题（？我不认为是这样） 青品黄在rgb色谱中是最亮的，降低饱和度的方法：色相向两边偏移、降低饱和度、最好不要调整明度（也就是直接加黑，会显得很脏） 红绿蓝色系降低饱和度的方法：色相向两边偏移、降低饱和度、也可以调整明度（最好不要）。 在这门课中使用同类色配色、中差色配色是比较常见的。 冷暖永远是对比出来的 RGB用来画阴影，如何用呢？ 第一种方法：粗暴黑，然后调低黑的透明度（不推荐） 第二种方法：基本色，然后饱和度增加，明度降低，就是阴影。 第三种方法：使用rgb，rgb三个条，左右调动。降低 —&gt; 阴影， 升高 —&gt; 高光 如何变调？原本是红色调的苹果变为粉色调？ –也是rgb调色 比如说我想让它粉一点，我观察色环，绿往粉偏一点，红往粉偏一点，蓝往粉偏一点就OK了 画渐变也可以使用rgb，比如说我想给它加些绿，粗暴的加绿会很奇怪。但如果先加个黄色渐变，然后用rgb将渐变往绿色偏，就会和谐很多 比如说下面这只猫的腮红，如果直接选择粉色就会很奇怪，但如果选择固有色 – rgb色调模式 – r像粉偏移，其他两条随便调调，整个颜色就会变得超级和谐的。 比如说这个菠萝，叶子想绿一点，用rgb绿一点，色相会自动变。叶子想粉一点，rgb向粉一点，色相会自动变吖！！！！！ 次表面散射 二、 体积的表现重点：阴影和投影，以及阴影、投影的层次（即、阴影和投影可以分几层） 但在q版的简单插画中，阴影是可以省略的。因为线稿可以替代阴影。 还有就是阴影一层其实就够了。不要像下面这样 只画最关键的点。 像下面这样简化 只考虑体积，不要考虑哪里更亮哪里更暗 第二个看起来更和谐。虽然脚部是应该更暗，但如果像第一个一样涂会显得不和谐。 光和体积是分开画的。体积虽然看起来光不是从体积该有的方向，但还是会和谐 所以体积的目的：是为了好看，用好看的颜色哪怕不是正确的颜色。 三、上色的步骤的第一部：铺大色： 确定固有色，分析好固有色，然后用固有色填充整个图形。并检查素描关系，的可以检查一下剪影是否可辨识与和谐。 控制画面整体的HSB，饱和度：30 - 80。亮度：10 - 50。色调：常用暖色。 第二部： 丰富颜色，顺便表达体积： 模式用rgb看 内部结构可以用不同的颜色表示 转折时，用不同的颜色 顺序排列的地方，可以稍微用不一样的色吖！ 第三部： 体积与光影如果画亮部可以表现体积的地方，就不要去画暗部 光影和体积无关顶点 体积最重要。即使暗部比亮部亮，只要体积正确就可以。 暗部想画高光，点一点就行了。越小其实会越明。 比如上面这个蘑菇上面比下面亮，但按照光影，下面应该比上面暗的。但这么画只要能表现体积，就没有问题。 第四部： 为线稿上色。偷懒方法：吸最近的颜色涂，然后降低饱和度明度。 不偷懒方法：一笔一笔画。 降低饱和度，降低明度，一笔一笔给线稿上色就成儿！！！！！！！！"},{"title":"【杂七杂八】第一节 设计几何卡通角色","date":"2021-07-21T03:15:20.000Z","url":"/2021/07/21/klgc1/","tags":[["课程","/tags/%E8%AF%BE%E7%A8%8B/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、几何卡通角色1. 关于ip设计可以搞一个自己的ip账号，比如说表情包、周边、故事。 所有平台都要搞一个专属的账号，不要是那种私人的。 给建模师，要标注细节 2. 风格分类： 韩国、日本ip （国内大部分） 欧美全球感ip （国内一部分） 美式漫画ip 画造型活泼的风格想提高商业性建议绘画方式更加严谨一些（丑萌） 3. 注意点画的东西偏方、偏圆，会让物体更加可爱。所以画的图形可以加圆角看。 二、步骤：1. 先用简单几何形概括不规则的部分，尽量归纳为简单的几何形，像👇🏻这个汉堡顶点的菜叶子 比如菜叶，用简单的几何形概括 还有比如长方形，可以概括为接近正方形的长方形，然后加上圆角，是不是更q拉。 比如西瓜的花纹，用简单的几何形概括。 2. 关于立体感为简化的物体，加一点立体感不是不可以。 去掉一些结构线，保留必要的结构线，可以使其更加简化。 or，用其他颜色的线。 比如，保留外框结构线，将内框结构线用别的颜色 ，or选择性保留，or二者结合。 但前提是一定要分辨清楚结构，结构线如果都是错误的，那画出来的东西能对？ 需要简化到位，才会显得可爱吖~ 三、找参考1. 只保留必要部分 2. 保留最重要的元素。比如说，对兔子来说，最重要的就是耳朵个。 找到了参考，之后还会，用ps删删删，看看最简化 的是什么，然后去画基本型 基本型：正方形、长方形、三角形、梯形、石膏几何等等。正方形那些保留圆角。 作业 加上眼睛、鼻子。重心放在简化和几何的点上吖。 整体构图偏正方、偏圆，用基本几何体概括结构，有棱角的地方用圆角。 分清结构，加一些立体感，去掉内部结构线，或为结构线更换颜色 只保留必要且最重要的的元素，能让人识别的元素，比如：兔子的耳朵。 加闭塞、脚下阴影，在部分闭塞处也可以带一些阴影 作业讲解： 尽量不要做元素之间的相切，除非有很想表达的东西。 尽量将方变为圆，简单的东西就不要做复杂。 由于主要是画一头身，所以容纳在一头身中。尽量椭圆 - 圆，方 - 圆 不要有特别不美观的样子出现。 加毛的话，可以开个口，然后加两根毛 附：artstudio取消吸附 "},{"title":"【人体】","date":"2021-07-17T20:31:34.000Z","url":"/2021/07/18/rt/","categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"在默人体的过程中可能遇到的点和问题记录 "},{"title":"【npm】常见参数的区别","date":"2021-07-17T08:01:08.000Z","url":"/2021/07/17/cxy/npm-dependencies/","tags":[["node","/tags/node/"],["npm","/tags/npm/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" dependencies 与 devDependencies的区别：dependencies：它包含的依赖包是需要发布到生产环境中的，是项目正常运行必须依赖的包。devDependencies：它包含的依赖包只在开发时使用，不用于生产环境，如果只需要项目正常运行，则不必安装这里面的包。 ## npm install packageName：安装某个包到项目中 默认情况下，不加参数。会安装包，并将依赖包的名称添加`package.json`中的`dependencies`字段。 1. --save参数 添加--save参数，与默认情况效果相同。会安装包，并将依赖包的名称添加到package.json中的dependencies字段。 2. --save-dev参数 添加--save-dev参数，会安装包，并将依赖包的名称添加到package.json中的devDependencies字段。 npm install： 初始化项目####1. 无参数： 直接初始化 我们常用npm install初始化项目，安装项目所需的依赖。但更深入的细节是：直接使用npm install时，项目package.json中dependencies字段和devDependencies字段中的依赖包都会被安装。 2. –production参数 添加--production安装项目所需的依赖时，只有dependencies字段中的依赖包会被安装，devDependencies中的依赖包不会被安装。 3. –only=dev参数 添加--only=dev安装项目所需依赖时，只有devDependencies字段中的依赖包会被安装，dependencies字段中的依赖包不会被安装。与添加--production的效果刚好相反。"},{"title":"【webpack5】进阶部分总结（一）","date":"2021-05-31T00:31:49.000Z","url":"/2021/05/31/cxy/webpack/webpack2/","tags":[["webpack","/tags/webpack/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" SourceMap1. 解决问题：报错时，报错的是编译后的代码，不好调试。 2. SourceMap是什么：源代码映射，包含源代码和构建后代码每一行每一列的代码映射关系。它会生成一个xxx.map，当构建后代码出错了，会通过xxx.map从构建后代码出错位置，找到映射后源代码出错位置。 3. 使用方法：在webpack的devTool文档中，souceMap的值有很多种情况，但实际开发只关心两种情况 · 开发环境：cheap-module-source-map只包含行映射，打包编译速度快。 · 生产环境：source-map包含行列映射，打包编译速度慢 生产环境下必须得关注列，因为生成模式下代码就压缩成一行了，不关注列根本不知道在哪里报错。 HMR：热模块替换hot module replacement：提升打包构建速度解决痛点：如果只修改了某个模块代码，webpack会将所有模块重新打包，那会很慢。当项目很大的时候，打包速度会越来越慢，所以需要更快些。配置方法：其实是默认的，不需要去写hot:true也可以。 当设置了hot: false时，那么在修改文件时（css），其实整个文件是会重新打包的（浏览器会刷新）。js即使开启了热模块替换（HMR），修改了还是会整个重新加载 one of：每个文件只能被其中一个loader处理webpack的loader会被每个文件匹配一遍，性能会很慢。当确认某个文件只会被一种loader处理时，那么设置匹配到一个loader之后，就不再处理下面的loader。这样也可以提升性能。写法： include exclude开发时会使用第三方的库或插件，比如echarts、lodash等。他们是已经编译好的，在node_modules中，所以处理js文件时，要排除node_modules的文件。 ESlint和Babel的缓存：每次打包都要重新检查eslint和babel编译会损耗性能，所以可以开启缓存。只有第一次打包需要检查eslint和编译babel，之后再次修改只检查和编译修改过的文件即可了。 Thread 多进程现在处理js文件，基本都是用eslint先检查，在用babel编译，再用terser压缩。文件大的时候会比较慢。现在的cpu都是多核的，可以启动多进程。###1. 安装threadsudo cnpm i thread-loader###2. 引入thread-loader位置放在需要处理的loader的前面，比如babel-loader前面。works: threads eslint 中 压缩代码使用的terser虽然是默认的，但如果想用多线程处理，就也需要写出来 optimization中（or plugins中） 文件少的时候没有必要开启，反而更慢的。因为进程启动也是需要时间的。 Tree Shakingtree shaking依赖js模块化，不能用于commonjs，用于描述和移除没有用到的js代码自动配置，无需手动配置。 减少Babel生成文件的体积 babel-runtime点击查看babel对一些公共方法使用了辅助代码，默认情况下辅助代码会被添加到每一个需要它的文件中，这样会使打包体积非常大。为了避免这样的情况，可以将这些辅助函数提出到一个npm包中，然后在用到的时候，再单独引入，这样就做到了复用。这个包就是@babel/runtime，之后每次需要用辅助代码转换时，require进去这个包，就可以减少代码体积。 如：下面这段代码是class语法被转译时加入的辅助代码，如果每个需要转译的class就这么长，代码体积就会很大。 下面是使用@babel/runtime包后，用require引入的方式，替代了上面的辅助代码片段，可以看到使用这种方式代码比较简洁。 但如果每个用到的地方都去手动替换这个包引入，出错几率大，所以就有了@babel/plugin-transform-runtime这个包。可以帮我们自动在需要的地方引入。@babel/plugin-transform-runtime：禁用了babel自动对每个文件的runtime注入，并且使所有辅助代码从这个包引入 压缩图片一个插件。 CodeSplit多入口1. 配置方法entry改为对象，output的filename换成[name].js 2. 提取公共模块如果所有的js都在一个文件中，体积太大了。如果只需要渲染首页js，其他文件不应该加载。所以进行代码分割，生成多个js文件，渲染哪个文件就用哪个js。 单入口： 多入口： 打包出来如图： 3. 按需加载js有些暂时不需要加载的文件，如果一出来就加载，会阻塞之后的资源。所以可以在需要的时候再加载。 我新建了一个count文件，内容如下： 在入口文件中动态加载count。 效果：原本是七个js文件####点击后加载第八个js文件 ####内容是count 如果动态导入的是函数的话，用res.函数名调用4. 为动态导入的模块在编译时重命名webpack默认是可以给动态模块命名的，但有点丑。如果想自己命名的话可以使用内联注释 具体的方法：（1） 动态引入的时候这样写 （2） 在output中配置chunkFilename （3）再次打包，名字就会变成自己的命名了 5. codesplit 统一命名对入口文件来说，可以叫main.js，为了方便开发，像chunk文件可以加一个.chunk.js，然后所有的媒体文件，如果每一个loader里面都去单独指定一遍，会比较麻烦。此时可以在output中配置 6. preload与prefetch共同点： 两者的概念都是预加载，缓存下来资源 只加载不执行 都有缓存 兼容性都很差####区别： preload：告诉浏览器立即加载资源 prefetch：告诉浏览器在空闲时加载资源 preload优先级高，prefetch优先级低。 preload只能加载当前页面用的，prefetch可以加载之后页面用的。现阶段使用preload-webpack-plugin插件 7. network cache8. Core.jsbabel可以转箭头函数、…这样的，但无法转换async、await、promise，这时就需要core.js。 1. 什么是corejs?core-js 它是JavaScript标准库的 polyfill（垫片/补丁）, 新功能的es’api’转换为大部分现代浏览器都可以支持运行的一个’api’ 补丁包集合。 2. 使用方法（1）直接引进首先安装corejs 然后在入口引入import ‘core-js’这种方法的坏处是会将core-js全部引入，会使得包体积很大。所以一般不会这样引。 （2）按需引进将需要的引进去即可。比如用promise，那么就写 安装后是有提示的，不用背。 （3）智能引进配合babel使用。在babel.config.js中配置 PWA 渐进式网络应用程序基于serviceworker实现，但也有很严重的兼容性问题点击访问官网项目离线时候也可以访问。 1. 安装 2. 在入口文件引入 3. 配置webpack插件 4. 重新打包会自动在dist目录下生成service相关文件如图 5. 看效果（1）由于service在dist目录下，所以需要在dist目录部署时才能使用。（2）使用http-server在dist目录下可以模拟启动一个服务器。（3）在network这里调成ofline，可以模拟断网，刷新后，会发现页面还是会加载。由于兼容性差，所以现在的普及率不大。 module chunk bundle的区别Module：能被import的文件，都是模块，无论是js、图片或者别的。在webpack中一切都是模块。Chunk：是多个模块组合而成的，如entry、splitChunk。entry是入口文件，入口文件中import的模块可能不止一个，所以是多个模块组合而成。splitChunk是提取公共代码，很多需要提取的代码被import，所以是多个模块组合而成的。Bundle：最终的输出文件。"},{"title":"【webpack5】基础部分总结","date":"2021-05-24T22:21:49.000Z","url":"/2021/05/25/cxy/webpack/webpack1/","tags":[["webpack","/tags/webpack/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、五大核心概念mode：开发模式development/生产模式productionentry：入口，从哪个文件开始编译output：出口plugin：插件loader：写在module中，加载器 二、基本配置固定在根目录，新建一个文件名为webpack.config.js内容如下： 新建src文件夹，在src文件夹下建立main.js，然后执行npx webpack就会自动打包。 三、处理资源注：多个loader配合使用时，处理顺序是：从下到上，从右到左 的顺序 1. css因为webpack只能识别js资源，所以要处理css需要用loader如加一个css-loader，先安装css-loader在开发环境中，然后在module中加载rules 对于一条规则，也可以使用多个loader，在use中配置。 常见的处理样式文件的loader：css-loader ：处理css文件less-loader sass-loader style-loader：处理style标签内的样式stylus-loader：使用模块化的方法去写css代码stylus：是一种写css的方式，没有花括号没有分号，用缩进的方式去代替大括号，后缀名为styl 2. 图片资源webpack4使用file-loader和url-loader处理图片file-loader:将图片转换为webpack能识别的资源。url-loader:将小于某个大小的图片转换为base64处理图片并不需要loader，webpack5自带默认处理图片，只需要在loader中配置 3. 修改打包资源的路径像输出时，默认js、图片等等都会在一个目录中，现在想要配置成其他目录。 重新npx webpack就变成了这样######图片资源路径的修改：在module/rules的对应loader中配置generator 打包效果： 4. 自动清空上次打包资源webpack不会自动删除上次打包内容，可能会造成重叠，文件很多，可以配置每次打包自动删除之前的打包结果。配置方法：clean：true 5.处理其他资源如视频、字体、excel等等，想统一处理的话，可以如下配置： 官网对于type: assert的几个值的介绍： asset/resource 发送一个单独的文件到输入目录并导出 URL。之前通过使用 file-loader 实现。asset/inline 导出一个资源的 data URI（如，base64）。之前通过使用 url-loader 实现。asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。 6. ESLINTeslint：用来检测js和jsx语法，可以管理缩进、规则是否正确，让代码更加健壮。配置文件：eslintrc.js在webpack4中使用loader处理。在webpack5中使用plugins去处理。 如何使用？根目录新建eslintrc.js，然后在webpack.config.js中配置plugin官网文档：点击查看plugins要用require引入。 简单的eslintrc.js的配置 如果有不需要检查的文件，新建eslintignore可以不检查。 7. babel还是一样，webpack官网搜babel，就会出来babel-loader的配置，复制过来根据自己的需要做修改。根目录新建babel.config.json，其中配置babel 如果不写上面的options，那么会用babel.config.json中的配置去转换代码的。@babel/preset-env：智能预设，允许使用最新的js@babel/preset-react：用来编译jsx@babel/preset-typescript：用来编译ts。 targets：需要兼容的浏览器版本，可以用这些属性 ： android, chrome, deno, edge, electron, firefox, ie, ios, node, opera, rhino, safari, samsung也可以设置成一个string，比如 &gt; 0.5%, last 2 versions, not dead 意思是有大于百分之零点五的人使用，前两个版本，并且没有废弃 useBuiltIns有几个值false：默认值，不做任何语法转换usage Babel：将检查你的所有代码，以便查找targets环境中缺失的功能，然后只把必须的 polyfill 包含进来entry：引入所有的polyfill包，必须在入口文件加入 import “core-js/stable” 才会生效 useBuiltIns 需要搭配 core-js，并且需要在配置文件里面声明。目前core-js最新版本是3.x，也可以指定2.x。npm i core-js -S “corejs”: “3.6.5” 8. 处理html点击查看首先js打包文件可能名字是动态生成的，需要自动引入js到html，才会确保不出错的所以可以自动生成index.html文件，插件为HtmlWebpackPlugin 首先插件会自动生成一个index.html，template中写的index.html意思是通过template里的这个index.html生成一个index.html到dist目录中，所以两个不是一个意思。 三、搭建开发服务器安装webpack-dev-server 四、生产模式的搭建生产模式也就是线上实际使用的代码，会被压缩。因为体积小，加载就快。一般会新建一个config/webpack.dev.js做开发环境的搭建。一般会新建一个config/webpack.prod.js做线上环境的搭建。然后建立webpack.config.js，将两个配置引入。 改动的主要地方1、如果配置文件新建一个文件夹放起来，那么需要将所有绝对路径改为上层路径。2、mode的更改3、开发模式删除output，生产模式删除devServer 常见打包命令：npx webpack：自动打包命令npx webpack serve --config ./config/webpack.dev.js ：运行./config/目录下的webpack.dev.js配置文件，并启动服务npx webpack --config ./config/webpack.prod.js ： 运行./config/目录下的webpack.prod.js配置文件 五、css处理1. css单独提取之前处理css的方法：是将css用css-loader变为webpack可识别的文件后在入口文件main.js使用imort引入css再使用style-loader将css转换为网页中的style内联标签####使用MiniCssExtractPlugin：将style-loader生成的style标签内的css单独提取为css文件，注意必须要安装style-loader 入口文件main.js中： 注： 要生成页面内style标签的形式，那么css-loader和style-loader要同时使用。 要生成单独的css文件，那css-loader和miniCssExtractPlugin.loader要同时使用。（不用style-loader）2. 兼容性处理postcss-loader：兼容性处理，需要安装postcss与postcss-loader，配置在css-loader和style-loader之后，在less和sass的前面，这个是固定的噢在package.json中，配置 然后按照官网去配置loader 3.CssMinimizerPlugin压缩css一般来说，压缩操作在webpack5中都放进optimization中，虽然放在plugins中也可以，不太规范拉。~ 常见的loader总结： raw-loader 将文件导入为字符串 url-loader 将文件作为 data URI 内联到 bundle 中 file-loader 发送一个单独的文件并导出 URL 各种css-loader postcss-loader：兼容性处理，需要安装postcss与postcss-loader，配置在css-loader和style-loader之后，在less和sass的前面，这个是固定的噢##常见的plugin总结： MiniCssExtractPlugin：将style-loader生成的style标签内的css单独提取为文件，注意必须要安装style-loader CssMinimizerWebpackPlugin: 压缩css ESLintPlugin：eslint检查 terserWebpackPlugin：压缩代码 "},{"title":"Proxy略略略略记","date":"2021-05-21T01:03:38.000Z","url":"/2021/05/21/cxy/cxddeziwoxiuyang1/js/js-proxy/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、proxyproxy就是一个拦截器，拦截了原来的对象之后，可以对这个对象进行自己的更改，也可以防止别人对对象进行某种更改，然后可以输出修改后的monitor，且不影响原对象。 1. proxy的声明（1）可以声明后直接在handler里面写对象 （2）下面这种声明方式 2. get/set/has/等拦截方法 二、 reflect（1） 名称和用法与proxy一样（2） ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。（3） Reflect 对象对某些方法的返回结果进行了修改，使其更合理。（4） Reflect 对象使用函数的方式实现了 Object 的命令式操作。 为什么用reflect，要尽量避免用原生的Object方法，通过Reflect方法调用会比较合理和方便。 在vue3的源码中，原先的数据驱动视图的方法Object.defineProperty被替换成了Proxy来实现，在Proxy内部操作数据时就用了Reflect去调用对象方法。"},{"title":"【github】私有仓库如何避免每次pull都要输入用户名密码","date":"2021-05-14T22:21:49.000Z","url":"/2021/05/15/cxy/other/github-siyoucangku/","tags":[["github","/tags/github/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一. 使用https提交方式：1. 使用git config命令在本地全局设置用户名和邮箱git config --global user.name &quot;username&quot;：全局添加用户名git config --global user.email “someone@mail.com”：全局添加邮箱git config --global credential.helper store： 该命令用于为credential.helper设置值，避免重复输入用户名密码 2. 执行完成以上后，运行cat ~/.gitconfig会发现.gitconfig多出了以下代码 3. 再次git pull，只需输入一次密码，之后就可以不再输入密码了。 二、使用ssh提交方式：1. 生成秘钥执行ssh-keygen。如果原本没有秘钥，就一路回车。如果有秘钥且秘钥关联了其他网站的项目，比如gitlab什么的，那就需要重新指定目录。 2. 获取公钥执行 cat 你指定的目录/id_rsa.pub获取公钥（如果没指定，就是 ~/.ssh/id_rsa.pub） 3. github中，新建ssh 4. 复制公钥粘贴保存即可。"},{"title":"【node】path.join和path.resolve的区别","date":"2021-05-11T04:01:08.000Z","url":"/2021/05/11/cxy/node-path/","tags":[["node","/tags/node/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 参数拼接 path.join([path1][, path2][, …])path.join()方法可以连接任意多个路径字符串。要连接的多个路径可做为参数传入。 path.join()方法的参数为string，可以加多个参数，最后会拼在一起形成一个地址，若不是string则报错 路径解析：path.resolve([from …], to)path.resolve()方法可以将多个路径解析为一个规范化的绝对路径。其处理方式类似于对这些路径逐一进行cd操作，但resolve在未执行时不会校验其合法性（就是可以不存在这个地址） 相当于 举例： "},{"title":"模块化之AMD和CommonJS","date":"2021-04-13T04:00:38.000Z","url":"/2021/04/13/cxy/cxddeziwoxiuyang1/js/js-amd/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、AMD概念：异步加载模块的规范，即，加载模块不会阻塞之后代码的执行。AMD是为浏览器环境所设计的，如requirejs。 用法：1. 定义模块AMD的模块，通过define函数定义在闭包中，格式如下： id: 模块名，可选，若不写，则模块为匿名模块。 dependencies: 所要依赖的模块列表，字符串数组类型，可选。若未指定dependencies，默认值为[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]。 factory: 模块的具体实现，类型为对象或函数。 2. 引入模块通过require引入 例子：下面通过requirejs写个例子： 1. 建立如下的目录结构： 2. 在index.html引入requirejs，并通过data-main标识入口文件要注意入口文件是唯一的。 3. 在moduleA、moduleB中定义模块moduleA.js moduleB.js main.js 也可以使用require.config去定义公用路径： 运行结果： 二、CommonJS同步加载模块的规范，即，只有加载完成，才能执行后续操作。CommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，如nodejs。 用法 CommonJS 是同步加载模块，但其实也有浏览器端的实现，其原理是将所有模块都定义好并通过 id 索引，这样就可以方便的在浏览器环境中解析了，可以参考 require1k 和 tiny-browser-require 的源码来理解其解析（resolve）的过程。 更多关于 CommonJS 规范的内容请查看 。 CommonJS的写法比AMD要简单明了很多，不举例了。"},{"title":"模块化之ES6","date":"2021-04-12T04:00:38.000Z","url":"/2021/04/12/cxy/cxddeziwoxiuyang1/js/js-mkh/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、export命令1. 基本使用 或 2. export也可以输出函数和类 3. as关键字 4. 下面这种写法是错的 正确写法： 二、importimport命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 三、export default1. 基本用法 export default 导出的一定是一个匿名的东西，即使接受的不是匿名函数或变量，因为从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。 2. export default的正确写法 在export default时，import导出不用大括号，除非是解构赋值。 从其他文件导入时： 四、其他注意点1. commonJS和import虽然通过babel转码，commonJS的require和import可以写在一起，可是由于import是静态解析阶段执行，所以在require引入前，import会先于它执行，这样有可能会导致错误。 2. import的简易写法当导出下面的文件时 引入可以这样写 或 3. import 和 export 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 五、import()import()用于动态加载，它返回一个 Promise 对象。下面是一个例子。 import可以用作1. 条件加载 2. 按需加载 3. 动态模块路径"},{"title":"[2021-04-07]水仙花观察日记","date":"2021-04-07T04:00:38.000Z","url":"/2021/04/07/diary/diary-sxh/diary-sxh2/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-06]水仙花观察日记","date":"2021-04-06T04:00:38.000Z","url":"/2021/04/06/diary/diary-sxh/diary-sxh4/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-05]水仙花观察日记","date":"2021-04-05T04:00:38.000Z","url":"/2021/04/05/diary/diary-sxh/diary-sxh5/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-04]水仙花观察日记","date":"2021-04-04T04:00:38.000Z","url":"/2021/04/04/diary/diary-sxh/diary-sxh7/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-03]水仙花观察日记","date":"2021-04-03T04:00:38.000Z","url":"/2021/04/03/diary/diary-sxh/diary-sxh3/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"【chrome插件】Ajax Interceptor修改 ajax 请求的响应文本","date":"2021-04-02T22:21:49.000Z","url":"/2021/04/03/cxy/other/chrome-ajax/","tags":[["开发效率","/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、介绍Ajax Interceptor是一个用于修改 ajax 请求响应的 chrome 扩展，修改ajax请求并返回结果的chrome插件。你可以用该插件修改页面上Ajax请求的返回结果。 二、安装Ajax Interceptor下载安装地址：点击跳转 三、使用 安装完成后，点击图标并展开 点击加号，在network中找到需要修改的请求 将从network获取到的地址和json数据粘贴至框中 点击JSON Editor，即可编辑需要修改的字段 刷新或重新请求后，即可生效。 ✨注意： 1. 第一次安装完，请刷新你需要使用的页面，或者重启浏览器。 2. 当你不需要使用该插件时，建议把开关关上（插件icon变为灰色），以免对页面正常浏览造成影响。 3. 该插件只会在JS层面上对返回结果进行修改，即只会修改全局的XMLHTTPRequest对象和fetch方法里的返回值，进而影响页面展现。而你在chrome的devtools的network里看到的请求返回结果不会有任何变化。"},{"title":"[2021-04-02]水仙花观察日记","date":"2021-04-02T04:00:38.000Z","url":"/2021/04/02/diary/diary-sxh/diary-sxh/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-01] 水仙花观察日记","date":"2021-03-31T20:57:38.000Z","url":"/2021/04/01/diary/diary-sxh/diary-sxh6/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"今天我种下了一朵水仙花，我为它浇了水，施了肥，把它放到了温暖的阳光下，阿~可爱的水仙花请快快长大吧！"},{"title":"react18基础知识梳理","date":"2021-03-25T05:03:49.000Z","url":"/2021/03/25/cxy/cxydeziwoxiuyang2/framework/react/react/","tags":[["react","/tags/react/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 思维导图 一、jsxjsx中使用js表达式在jsx中js表达式是用&#123;&#125;括起来的，和vue一样。可以调用的有1.常规变量2.原生js3.三元运算符 列表渲染：map使用Object.keys去获取obj列表，再用map循环 style: 使用\\&#123;\\&#123;\\&#125;\\&#125; 条件渲染：三元表达式模版太长时，可以使用括号包裹，并可以换行。 模板精简将重合的部分提出放入函数中，在App()中可以调用 其他注意事项 jsx标签必须闭合，只有一个根节点 jsx标签换行，必须加小括号 jsx属性名采用驼峰命名法，如class-&gt;classNamefor-&gt;htmlfor 二、组件1. 函数组件 组件名称必须首字母大写 组件必须有返回值，且返回值为jsx模板，什么jsx都不返回则为null 使用函数名作为组件标签名。 2. 类组件 类组件类组件中必须使用render()方法去返回一个jsx结构，render方法必须要有返回值 类组件必须继承React.Component，并引入react 3. 事件绑定 事件格式为on+事件，函数组件可以直接调用方法，类组件调用用this.xxx方法 传递自定义参数的话，如果同时需要使用事件对象e和自定义参数的话，需要在外层套一层箭头函数传入 三、组件状态1. 类组件中数据驱动视图的基本写法在react hook出来之前，函数组件是没有状态的，所以这里统一通过类组件来讲解。现在，类组件已经不太常用了 使用state，修改state通过setState实现，setState通过继承而来 this有指向问题，要当心。在指定onClick中的方法时，必须要用this.xxx，如果没有传，则为undefined 2. react的状态不可变不要直接去修改state，修改数组和对象要重新使用setState去整体赋值 四、表单处理（input）使用react处理表单，一般有两种方式 受控组件 非受控组件（不常用） 1. 受控表单组件 受控组件就是input框可以被react组件状态控制的组件，可以实现双向绑定 双向绑定的步骤 input绑定onChange或onInput事件 value指定某个变量 事件在类中写好，然后在事件中使用setState去将input的value赋值给变量 2. 非受控组件 组件的状态和表单控件状态不同步(只是表单控件的初值和组件的state一致)。没有双向绑定使用createRef 五、组件通信1. 父子组件通信函数子组件通过参数props，类子组件通过this.props，函数组件可以通过参数解构接收， v也可以通过props接收的。父组件上定义传入子组件的变量 props：1. 只能单向，不能反过来修改。2. 可以解构赋值 如下，现在父组件的state种有一个message变量，想传入到子组件中父组件App.js： 子组件SonF（函数组件） 子组件SonC（类组件） 2. 通过子组件传递给父组件原理：子组件调用父组件传递过来的函数，并且将想要传递的数据当成函数的实参 不管是类组件或是函数组件都是以下步骤： 在父组件建立函数，传入子组件中 子组件用props接收父组件的函数，在函数中传递参数，然后在模板中执行函数 父组件形参接收子组件的传值即可。 以类组件举例： App.js中： 3.兄弟组件通信不想写了，反正就是两兄弟会通过父组件，进行数据的传递。一个子组件将数据传给父组件，父组件再将数据props给另一个子组件。 4.跨组件通信Context父组件像任意的子孙组件传值，可以使用Context。相当于vue的依赖传值。 步骤： 新建一个组件，专门用来导出Provider和Consumer，然后让需要Provider和Consumer的组件引入该组件。不可以在需要的文件中直接用React.createContext去新建，因为在不同文件中生成的是不同实例。 根组件App.js 需要引入的组件ContextComponent 中间组件SonA的内容 子孙组件内容 六、组件进阶1. children 属性（slot）children存在于props里面，所以可以通过解构赋值，也可以通过props.children去获取使用。表示该组件的子节点，只要组件内部有子节点，props中就有这个属性。类型包括： 普通文本 普通标签 jsx 函数 2. props校验有时候从父组件传过来的props，类型会不正确，比如子组件需要一个数组，而父组件传过来一个number，那么遍历就会出现问题。这种情况下，就需要props校验。相当于vue的 支持类型： 基础类型（array、bool、func、number、object、string） react元素类型： element 必填项： isRequired，也就是传属性时不能缺少这个属性。 特定的结构对象：shape 步骤： 安装prop-types 在需要的组件中导入prop-types 对应组件.propTypes = &#123;&#125;设定规则如下，表示名为ListItem的组件有一个lists被传进来，类型必须为array 完整代码： 七、组件生命周期只有类组件才有生命周期，因为类组件要实例化，而函数组件不需要。 初始化阶段：1. 执行顺序：constructor –&gt; render –&gt; componentDidMount2. 功能：constructor：创建组件时最先执行，初始化时只执行一次，现在用的不多了。render: 每次渲染时都会触发，所以不要在里面调用setState，有可能造成死循环。componetDidMount：组件挂载（dom渲染完成）后执行，初始化的时候只执行一次。所以一般进行网络请求和dom操作。 更新阶段：1. 执行顺序：render –&gt; componentDidUpdate2. 功能：render：每次渲染都会触发componentDidUpdate：组件更新后（dom渲染完成）触发。两个钩子里面都不要调用setState() 卸载阶段：componentWillUnmount：组件卸载（从页面中消失）时触发，一般用来执行清理工作（比如：清理定时器等） 三个阶段，五個鉤子 八、React HooksHooks：使函數組件更強大，更靈活的鉤子現在hooks暫時只能在函數組件中使用。因為它的作用就是為了讓hooks擁有狀態。 1. useStateuseState提供給變量修改數據的方法。 步驟： 從react中引入useState 使用useState聲明變量，聲明修改變量的方法[變量，修改變量的方法] 使用修改變量的方法修改數據注意：不能直接修改原值，必須調用修改變量的方法，在下面的例子就是setCount 2. useState數據的讀取和修改一句話：useState生成的初始值只在初次渲染生成，之後再次生成j都是用setstate修改得到的值！注意事項： 只能出現在函數組件中 不能用於if/for等嵌套結構中，只能寫在函數組件最外層處。3. useEffect 函數副作用對於react組件來說，祝作用時根據數據渲染ui，那麼副作用就是除此之外的全部操作。 常見的组件副作用1. 數據請求ajax發送2. 手動修改dom3. localStorage操作4. 当watch用：useEffect有两个参数，第一个是函数，第二个参数是数组，用来存放变量，当数组存放变量发生改变时，第一个参数逻辑处理函数将会被执行（类似于监听）vue的watch不一定是在dom渲染完畢之後執行，而useEffect一定是在dom渲染完畢後執行。5. 可以作为生命周期钩子使用，在每次render後執行（dom渲染後觸發） + 没有第二个参数时,组件的初始话和更新都会执行 + 空数组时，初始化调用一次之后不再执行，相当于componentDidMount + 有一个值的数组时，该值有变化就执行 + 有多个值的数组时，只要有一个值有变化就执行 4. useRef 用於獲取真實dom的方法 函數組件的useRef相當於類組件的createRef綁定在元素上獲取該元素，綁定在組件上可以獲取該組件的所有屬性和方法。 步驟： 引入useRef 使用useRef新建一個變量，傳入參數為null，在其中有current可以獲取到組件信息或dom元素 將該變量通過ref綁定到元素或組件上 假設現在有一個Test組件 需要在App組件中獲取Test組件的方法和屬性 testRef可以獲取到Test組件的方法與屬性，h1Ref可以獲取到h1這個dom元素。 對比類組件的createRef的用法 4. useContext 函数组件中的通信在类组件中使用createContext进行后代组件通信。函数组件中也需要使用createContext，两者在祖先组件中的写法一致。但函数组件中Consumer的部分需要变成使用useContext 在SonB这个后代组件中，使用useContext去代替Consumer，就可以获取到App传过来的count数据 5. useCallback()九、react-router1. 安装router ###1. BrowerRouter和HashRouter作用：包裹整个应用，一个react应用只需要使用一次两种常用的router: HashRouter和BrowerRouter HashRouter相当于vue的Hash模式地址域名后面会多一个#，比如 BrowerRouter相当于vue的History（html5）模式但这种模式需要后端配合，这个地址相当于前端为了好看生成的，不是真实的地址。如果直接访问某个二次跳转的链接，有可能404 2. Link用来指定导航链接 3. Routes符合Link条件的试图会渲染到Routes里。 4. Route用于指定导航链接，完成路由匹配。相当于vue的router-view 5. 编程式导航 - 跳转***react-router的跳转可以分为用Link跳转，和用useNavigate跳转两种。这里主要说useNavigate***的用法。 useNavigate直接跳转：对应vue的$router.push()，会在地址栈留下记录，可以回退。 useNavigate添加&#123; replace: true &#125;参数：对应vue的\\$router.replace()，不会在地址栈中留下记录，无法回退到该页面，一般用于登录后的回退。 步骤： 导入useNavigate 声明一个useNavigate方法 使用该方法，传入参数，第一个参数为地址，第二个参数为补充项，如上面说的是否要使用replace模式。 完整例子： 6. 跳转传参 searchParams &amp; paramssearchParams 和 params的区别：searchParams：地址为/index?name=xxx&amp;id=xxx的形式，可以获取问号后的参数params：地址为/index/111的形式，可以获取到111 #####步骤： 首先引入useSearchParams或useParams 初始化变量 通过变量获取参数若为searchParams，则使用以下的的形式获取： 若为params，则使用一下的形式获取： 7. 二级路由在route里面再配置route，然后在需要二级页面的地方导入outletApp.js中 Layout.js中 "},{"title":"面试题整理（持续更新）","date":"2021-03-20T09:58:32.000Z","url":"/2021/03/20/mst/","tags":[["lv3","/tags/lv3/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"jscall绑定nullcall和apply第一个参数为null/undefined，函数this指向全局对象 跨域解决方案cors和jsonp jsonp为什么会自动执行？又不是请求而是script标签当然会自动执行。。 css重排(reflow)和重绘(repaint) 重绘：某些元素的外观被改变，例如：元素的填充颜色 重排：重新生成布局，重新排列元素。 重绘不一定导致重排，但重排一定会导致重绘。 如何提高dom渲染性能？减少重排次数： 集中改变dom 分离读写操作 使用display: none之后再进行 dom的修改，就会避免重排 使用absolute或fixed脱离文档流，修改子元素就不会影响父元素以上的元素重排 固定会影响父元素重排的css，再去操作子元素的重排和重绘，这样就不会影响父元素之外的其他元素 优化动画，比如translate: 1s改为更长的时间，减少帧数。 网络websockethttp缓存策略"},{"title":"【乱七八糟】有趣的句子","date":"2021-03-20T09:42:43.000Z","url":"/2021/03/20/yqtc/","tags":[["生活","/tags/%E7%94%9F%E6%B4%BB/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":"有时候刷到一些有趣台词和说话小技巧，還有自己的一些感悟。 小本本总结记下来： “你怎么一点劳动人民的觉悟都没有？” “我要是一个月拿100多块钱，我的觉悟比你还要高！” 发现一个事情，很多人吵架很喜欢给别人贴标签，受过高等教育一定要怎样吗？读了很多书一定要怎样吗？和道德绑架一样。 一个回怼小技巧：用男人的方式打败男人 比如有人对你说：“你一个女孩子，脾气那么大干什么？” （可以先故意说一些话把对方激怒，然后说）“跟你开个玩笑，你一个男孩子，怎么心胸这么狭隘？一点男子气概都没有。” 不要掉入自证的陷阱，特别是这种无关瓜葛的联系；要转到让对方自证，并争取到更多的人和你站一起，给对方压力。 任天堂可以畀人一种独特的玩法，独特到虽然口碑很好却没有人模仿，这大概就是创新能力的体现，玩法是可以模仿的，但是创新是没法模仿的，这些年任天堂没有倒下，也就是这个原因。游戏必须是好玩的，老的玩法也是有很多好玩的，俄罗斯方块现在还有新作，车枪球那套东西几十年不变的，一样很多人玩。突突突，从魂斗罗开始就没有变，今天进化到超级3A大作，只要打得爽，很多人觉得画面进化就够了，原来是像素人物，现在变成CG级别的逼真度。但实质上游戏性并没有增加多少。技术的进化固然可以改进玩法，玩法的创新则不一定依赖于技术，任天堂的好多遊戲就是这种例子，用的最简单的2D画面。一个游戏的本质是追求好玩，玩了觉得好玩，你还会计较它的画面好不好看吗？就是那种你玩上手很快能够感觉得好玩的游戏。制作3A大作的游戏公司必然要做大制作，小制作也会有空间，只要有足够的创新，这也就是好多小製作能够大获成功的原因。 “誰說我不會用平底鍋？” 一鍋把正在施暴的男人人打暈的家庭婦女這麼說道。 “不要把金錢當做友誼，錢只能買來合作的關係。你需要頭腦，而我需要雙腳。騎士是需要用行動證明自己的價值的。” （陪着你走） "},{"title":"【2020-11-27】大喵的表情包上线拉！","date":"2020-11-27T05:23:38.000Z","url":"/2020/11/27/diary/diary-0612%20copy/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"],["表情包","/tags/%E8%A1%A8%E6%83%85%E5%8C%85/"],["日常","/tags/%E6%97%A5%E5%B8%B8/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 虽然全套的动态带静态表情包是我两天就全部做好的超级赶工品。。还是希望会有人下载用用看啵~ 之后有机会的话我会认真画的！绝对！可能。大概。。。也许。。。。。"},{"title":"【bash】bash 重定向符號","date":"2020-10-10T21:18:18.000Z","url":"/2020/10/11/bashsd/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"输入重定向符号 &lt;&lt;在 Bash 中，&lt;&lt; 符号允许你将一段文本作为输入传递给命令或脚本。这段文本通常位于脚本文件中，但也可以直接在命令行中使用。 下面是使用 &lt;&lt; 符号的示例： 在上面的示例中，command 是接收输入的命令，&lt;&lt; 符号后面的 EOF 是一个标记，用于表示输入的开始和结束。在这里，我们可以输入多行文本作为命令的输入。 输入重定向符号 &lt;&lt;&lt;在 Bash 中，&lt;&lt;&lt; 符号可以将一行文本作为输入传递给命令或脚本。 下面是使用 &lt;&lt;&lt; 符号的示例： 在上面的示例中，command 是接收输入的命令，&lt;&lt;&lt; 符号后面的引号内包含了一行文本作为命令的输入。 输入重定向符号 &lt;在 Bash 中，&lt; 符号用于从文件中读取输入，而不是从命令行或字符串中读取。 下面是使用 &lt; 符号的示例： 在上面的示例中，command 是接收输入的命令，&lt; 符号后面是输入文件的名称。该命令将从文件 input.txt 中读取输入。 总结： &lt;&lt; 允许输入多行文本。 &lt;&lt;&lt; 允许输入一行文本。 &lt; 是从文件中读取输入。 使用这些输入重定向符号，您可以在 Bash 中灵活地处理输入数据，无论是来自命令行、字符串还是文件。希望这篇文章能够帮助您理解并正确使用这些符号！如果您有任何进一步的问题，请随时提问！"},{"title":"typescript总结笔记","date":"2020-09-10T07:20:18.000Z","url":"/2020/09/10/cxy/cxddeziwoxiuyang1/js/typescript/","tags":[["typescript","/tags/typescript/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 什么是typescript？typescpt是一种静态类型语言。添加了类型的js，完全兼容js，写完后可以编译为js我觉得是用另一种更为严格和规范的方式去写js##静态类型语言静态类型语言中，变量的类型必须先声明，即在创建的那一刻就已经确定好变量的类型，而后的使用中，你只能将这一指定类型的数据赋值给变量。如果强行将其他不相干类型的数据赋值给它，就会引发错误。在静态语言中，一旦声明一个变量是int类型，之后就只能将int类型的数据赋值给它，否则就会引发错误，而动态类型则没有这样的限制，你将什么类型的数据赋值给变量，这个变量就是什么类型 强类型 VS 弱类型强弱之分，体现在对类型的检查严格程度上，弱类型语言对于变量类型的检查比较宽松，容忍隐式类型转换这种事情的发生。何为隐式类型转换，一般有两种形式： 相关类型之间隐式转换 不相关类型之隐式间转换一、基础类型1. ts有哪些基础类型？布尔、数字、字符串、数组、元祖、枚举、any、void、null、undefined、never、Object2. 定义数组： 3. 定义元组： 注意：访问越界元素会报错 4. 枚举：定义类型 5. nevernever是任何类型的子类型，可以复制给任何类型，但没有类型是never的子类型或可以赋值给never类型（除了never本身），即使是any也不能复制给never。never经常用于抛出异常的函数，或是死循环。 变量也可以是never类型，当他永不为真的类型保护所约束时。 6. voidvoid表示没有任何类型。和any完全相反。函数没有返回值时可以写void void变量没有什么作用，因为void变量只能赋值null或undefined。 7. 类型断言我可能有时候比ts更了解这个变量是什么类型，这时就可以用类型断言语法有两种第一种：尖括号 第二种：as 二、变量声明ts用const、let代替了var 三、接口1. 对象类型定义一个类型，让变量按照这个类型来具体实现 2. 函数类型 上面代码意思是，一个函数类型叫Square，它应该有两个参数，一个source类型string，一个subString类型string，返回boolean类型的值。 3. 类类型 接口亦可以继承 四、类 1. public、protected、private的区别：protected：可以继承，不可以在类外部使用private：不可以继承，不可以在类外部使用public：可以继承，可以在类外部使用 2. readonly： 3. getter、setter 4. 静态属性、静态方法使用static定义，只能用类名.方法/属性使用 5. 抽象类与抽象方法 6. 抽象类和接口的区别（1）abstract类abstract类是定义用来被继承的类。抽象类中可以有抽象方法，可以有普通方法。非抽象类也可以。但抽象类不能创建对象，普通类继承抽象类必须实现其方法，或将其定义为抽象方法。抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。 1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。2）抽象类不能用来创建对象；3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。4）非抽象类中可以有抽象方法，比如继承的时候，如果子类不想实现父类的抽象方法，则必须将该方法也定义为抽象方法(2) interface接口： 是对类的补充接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误） 而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现 抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。 五、函数 六、泛型（尖括号）1. 泛型变量一个函数在公用的时候，若同一个参数可能有多个类型or可能有多种返回值的情况下，如果写成any会不严谨 用下面这个就可以保证返回值与参数相同类型 2. 泛型类、泛型接口 七、枚举 八、高级类型1. 类型别名 2. 交叉类型也就是用’&amp;‘ 3. 联合类型也就是用’|’let arg: number | string = ‘sfsdfds’###4. 类型保护和类型断言typeof和instanceof （1）typeof （2）instanceof只对类有用。 九、Symbols十、迭代器for of 与for in 十一、模块（原：外部模块） “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 ECMAScript 2015里的术语保持一致，(也就是说 module X &#123; 相当于现在推荐的写法 namespace X &#123;)。 用法和js一致。 十二、命名空间（原：内部模块） “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 ECMAScript 2015里的术语保持一致，(也就是说 module X &#123; 相当于现在推荐的写法 namespace X &#123;)。 1. 命名空间的基本用法在一个文件中，有时候有些变量是不想定义为全局的，比如有ab两个类被c类引用，如果都定义为全局的变量，不好维护容易出错，可以只对外暴露出c类接口（export class C）给该文件其他部分使用。。 2. 复用将逻辑与业务分离，可以将一个namespace用另一个namespace引入如下面，用page引入components的命名空间components.ts文件： page.ts文件： 由于这种写法很难搞懂命名空间是在哪个文件中，所以最好在path.ts头部中用三斜线指定进行指定 ###3. 子命名空间 十三、三斜线指令三斜线指令仅可放在包含它的文件的最顶端。放在其他地方则会被当做注释去解析的。包括下面几个指令，去看官网吧 tsc -w 监听，自动编译tsc init 生成tsconfig.tsconfig的配置：outFileoutDirmodulerootDirtarget 十四、声明文件使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。说人话：就是第三方库定义的一些东西直接引进来ts识别不了，ts只能识别js有的和ts已经定义的东西。所以需要另外写一份声明文件告诉ts，然后ts就知道这个第三方库有这些变量就不会报错了。文件叫*.d.ts declare 就是用在声明文件中的。 全局变量 全局函数 带属性的对象 函数重载 可重用类型（接口） 可重用类型（类型别名） 组织类型 类 十五、项目配置tsconfig.json"},{"title":"【vue】vue2和vue3分别实现数据侦听","date":"2020-08-21T10:16:25.000Z","url":"/2020/08/21/cxy/cxydeziwoxiuyang2/framework/vue/vue-defineProperty/","tags":[["vue","/tags/vue/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" Object.defineProperty(obj, prop, descriptor)在js原生对象中，实现数据侦听的方法就是defineProperty。 使用示例如下： vue2中使用defineProperty中实现数据侦听建立一个html文件，dom结构如下 编写侦听函数 实现侦听的函数 当数据更改时，更新视图 proxy拦截代理，拦截对应的操作后，进行处理，会新生成一个对象，然后通过proxy生产的对象去改变原对象。 使用方法："},{"title":"Javascript是单线程语言，是如何实现异步的","date":"2020-08-10T21:30:40.000Z","url":"/2020/08/11/dxc/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"Event Loop单线程的JavaScript实现异步的方式是通过事件循环（Event Loop）机制。 在JavaScript中，代码是按顺序执行的，当遇到需要等待的操作时（例如网络请求、文件读取等），传统的同步方式会阻塞代码的执行，导致程序无法做其他事情。为了解决这个问题，JavaScript引入了异步编程模型。 异步操作通过回调函数、Promise、async/await等方式来实现。当需要执行一个异步任务时，JavaScript将其添加到事件队列中，而不会等待任务完成。一旦主线程的执行栈为空，事件循环开始检查事件队列中的任务。 事件循环的机制如下： 执行栈中的同步任务按顺序执行。 当遇到异步任务时，将其添加到任务队列中，并继续执行下一个同步任务。 当执行栈为空时，事件循环开始从任务队列中取出一个任务，放入执行栈中执行。 当执行栈中的任务执行完毕后，回到步骤1。 这种机制使得JavaScript能够处理异步任务而不会阻塞主线程的执行。异步任务的完成后，会触发相应的回调函数或Promise的处理函数，从而继续执行相关的逻辑。 举个例子，假设我们有一个网络请求的异步操作，可以使用XMLHttpRequest或fetch API。当调用这些API时，JavaScript会将请求添加到任务队列中，并继续执行后续的代码。一旦请求完成，它会触发相应的回调函数（例如onload）或Promise的then方法，以便处理返回的数据。 总结起来，单线程的JavaScript实现异步的关键是通过事件循环机制，将异步任务添加到任务队列中，并在适当的时机执行这些任务，从而实现异步操作，避免阻塞主线程的执行。这种异步编程模型使得JavaScript可以处理各种I/O操作和耗时任务，提高了应用程序的响应性能。 单线程的JavaScript为何可以实现异步的成？单线程意味着 JavaScript 在任何给定的时刻只能执行一段代码，也就是一次只能做一件事情。但通过异步机制，JavaScript 可以实现非阻塞式的异步操作，从而在一个任务等待的时候继续执行其他任务，以提高效率。 在执行异步操作时，JavaScript 将任务交给底层的运行时环境（比如浏览器或 Node.js），然后立即继续执行后续的代码，而不是等待异步操作完成。当异步操作完成后，会将相应的回调函数放入任务队列中，等待 JavaScript 主线程空闲时执行。 这种方式使得 JavaScript 单线程的事件循环可以不断地处理任务队列中的任务，以保持整个应用的响应性。虽然 JavaScript 在同一时间只能执行一个任务，但通过合理地安排和处理异步任务，可以在任务之间切换，使得整个应用看起来是在同时处理多个任务。 举个例子，当 JavaScript 遇到一个耗时的网络请求时，它可以将请求发送给浏览器引擎处理，然后立即继续执行后续的代码，而不会等待请求返回。一旦请求完成，浏览器引擎将触发相应的回调函数，并将其放入任务队列中，等待 JavaScript 主线程空闲时执行。 需要注意的是，JavaScript 的单线程模型并不意味着所有的操作都是异步的。部分操作（如一些计算密集型任务）仍然是同步执行的，可能会阻塞主线程。因此，在设计 JavaScript 应用程序时，需要合理选择使用异步机制来处理那些可能会导致阻塞的操作，以确保整个应用的流畅性。 综上所述，虽然 JavaScript 是单线程的，但通过异步机制，它可以在一个任务等待时继续执行其他任务，提高效率，并保持应用程序的响应性。"},{"title":"理解二进制、十六进制、十进制和八进制：不同进制间的转换","date":"2020-08-10T06:18:37.000Z","url":"/2020/08/10/bitzhd/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"在计算机世界中，我们经常会遇到不同的进制，如二进制、十六进制、十进制和八进制。这些进制用于表示和处理数字。让我们一起来了解它们之间的转换方法。 十进制（十进制）：我们常用的数字系统十进制是我们日常生活中最常用的数字系统。它是基于10的系统，包含数字0到9。我们使用十进制来计数、计算和表示数字。 举个例子，当我们看到数字87时，我们理解它表示的是八十七。 二进制（二进制）：计算机的基础二进制是计算机中最基本的数字系统。它是基于2的系统，只包含0和1这两个数字。计算机内部的所有信息都以二进制形式存储和处理。 举个例子，数字1010在二进制中表示的是十进制的10。 在二进制中，每一位数字称为位（bit）。八位的二进制数字组成一个字节（byte）。二进制是计算机中理解和表示数据的基础。 十六进制（十六进制）：简化二进制表示十六进制是一种常用的数字系统，它是基于16的系统，包含数字0到9和字母A到F，分别表示10到15。它经常用于简化二进制表示。 举个例子，二进制数1111可以用十六进制表示为F。 由于十六进制可以表示较长的二进制数，因此它在计算机中广泛使用。每两位二进制数字对应一个十六进制数。 八进制（八进制）：简化二进制表示八进制是一种数字系统，它是基于8的系统，包含数字0到7。类似于十六进制，八进制经常用于简化二进制表示。 举个例子，二进制数111可以用八进制表示为7。 八进制每三位二进制数字对应一个八进制数。 进制转换方法现在让我们来看看不同进制之间的转换方法： 二进制转十进制 将二进制数的每一位乘以2的幂，幂的值从右向左依次为0、1、2、3… 将得到的结果相加，即可得到十进制数的值。 举个例子，二进制数101转换为十进制： 十进制转二进制 将十进制数不断除以2，直到商为0为止，记录每一步的余数。 将得到的余数按照计算的顺序从下往上排列，得到二进制数。 举个例子，十进制数10转换为二进制： 从下往上排列余数，得到二进制数1010。 十进制转十六进制 将十进制数不断除以16，直到商为0为止，记录每一步的余数。 将得到的余数按照计算的顺序从下往上排列，将10到15分别用A到F表示，得到十六进制数。 举个例子，十进制数23转换为十六进制： 从下往上排列余数，将10到15分别用A到F表示，得到十六进制数17。 十六进制转十进制 将十六进制数的每一位乘以16的幂，幂的值从右向左依次为0、1、2、3… 将得到的结果相加，即可得到十进制数的值。 举个例子，十六进制数AB转换为十进制： 十进制转八进制 将十进制数不断除以8，直到商为0为止，记录每一步的余数。 将得到的余数按照计算的顺序从下往上排列，得到八进制数。 举个例子，十进制数27转换为八进制： 从下往上排列余数，得到八进制数33。 八进制转十进制 将八进制数的每一位乘以8的幂，幂的值从右向左依次为0、1、2、3… 将得到的结果相加，即可得到十进制数的值。 举个例子，八进制数62转换为十进制： 进制转换的小数当涉及到小数的转换时，我们可以将小数部分分别转换为不同进制，然后将整数部分和小数部分的转换结果合并在一起。 以十进制转二进制为例，我们将整数部分和小数部分分开处理： 十进制整数部分转二进制 将十进制整数部分不断除以2，直到商为0为止，记录每一步的余数。 将得到的余数按照计算的顺序从下往上排列，得到二进制数的整数部分。 例如，将十进制整数部分14转换为二进制： 从下往上排列余数，得到二进制整数部分1110。 十进制小数部分转二进制 将十进制小数部分乘以2，取整数部分作为二进制小数的一位。 将得到的整数部分作为新的小数部分，再次乘以2，重复上述步骤，直到小数部分为0或达到所需的精度。 例如，将十进制小数部分0.375转换为二进制： 依次取得的整数部分，得到二进制小数部分0.011。 最后，将整数部分和小数部分合并，得到完整的二进制数14.375。 其他进制的小数转换也是类似的原理，只需要将对应的进制数应用于整数和小数部分即可。"},{"title":"class总结","date":"2020-07-21T05:03:15.000Z","url":"/2020/07/21/cxy/cxddeziwoxiuyang1/js/js-class/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" ## 思维导图 一、基本写法类的方法、属性、静态方法、静态属性、私有方法、私有属性继承、接口（没有）、抽象（没有）、final（这个有） 构造函数constuctor 实例属性可以使用this.xxx写在constructor方法中，也可以写在类的顶端。 实例属性不存在于原型链上，而是存在于单个实例中。如果constructor写了赋值，在创建实例时却没有赋值，那就会变成undefined拉 原型属性（使用prototype赋值）存在于原型链，用“类.prototype.属性名”可以调用到。 类的方法是默认定义在原型链上，供所有实例共享的。但在类内部定义的变量是属于单个实例的，不存在与原型链上。如果想在类外通过赋值的方法，定义属于原型链的属性，当然所有实例也都可以共享，但一旦修改所有实例的该属性都会修改，其实没有什么意义还容易出问题。所以虽然可以在原型链上定义实例，但一般来说没必要。除非真的确定这个属性在所有的实例上都是相同的。 getter、setter方法在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。get/set方法定义的变量不需要提前定义。set方法必须要传入value name在类内部，可以使用类名.name去调用，获取类的名字 Class表达式类可以用表达式的形式定义，在类外部调用时只能用表达式调用，如下面的例子，外部只能使用MyClass调用，但MyClass的实例还是属于Me 属性表达式类的属性名可以用表达式表示 ####静态属性静态属性定义在类上，不在实例上，所以只能用类名.属性名调用。定义静态属性的方法是在class外部，用类名.属性定义该属性 es6的规定，class内只有静态方法，没有静态属性，但现在有个提案是用static在内部定义静态属性，所以也可以如下定义 静态方法的定义： 私有方法和私有属性使用#定义私有属性。只能在类的内部使用(this.#count)，无法继承，无法在外部调用。暂时没有提供私有方法。 ####静态块有时候在类内部有一部分代码，是不用每次创建实例时都去调用的，比如静态属性的赋值。所以es2022规定了静态块，在类生成时只执行一次，主要用于对静态属性的赋值，之后新建实例就不再运行了。 new.target该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令，new.target会返回undefined ##二、类的继承 super方法与super关键字1. super方法super方法可以且只能在子类构造函数中调用，用来调用父类的constructor()，在子类的构造函数中必须要调用一次super() 2. super关键字super作为对象时，在普通方法中，指向父类的原型对象（Point.prototype）；在静态方法中，指向父类。由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。因为类中定义的方法本就是定义在原型链(prototype)上，所以super可以调用到类内的方法。但super没办法调用到类内的变量，因为类中定义的变量是存在于实例的。 在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。 在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。 "},{"title":"【2020-07-15】打游戏","date":"2020-07-14T23:44:59.000Z","url":"/2020/07/15/diary-0714-1/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"云外镜感觉好好苟吖当血少逃跑时，对面离得越近，越开大开那个反面追击的话我血多，对面血少，开正面如果贴脸的时候对面血少，开反面的大"},{"title":"【第4-1章】event-loop、宏任务和微任务","date":"2020-07-10T21:42:55.000Z","url":"/2020/07/11/cxy/cxddeziwoxiuyang1/js/js-eventloop/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 宏任务和微任务微任务：promise async为微任务宏任务：浏览器自己规定的一些api，比如settimeout、dom事件、ajax请求微任务的时机在宏任务之前。顺序是同步任务、微任务、宏任务 以下代码执行顺序为3、2、1 js是如何执行的？先执行同步，再执行异步从前到后，一行一行执行若某一行报错，则停止执行下面的代码先把同步代码执行完，再执行异步 event-loop与dom渲染event-loop： 微任务和宏任务是两个不同的队列，微任务在micro task queue，宏任务在callback queue。 总结event loop过程同步代码一行一行向下执行遇到宏任务，先记录下，等待时机（定时、网络请求）微任务放入微任务队列（micro task queue）宏任务时机到了，移动到宏任务队列（callback queue）若call stack为空（即同步代码执行完）eventloop开始工作先执行当前的微任务，一条一条推入栈中执行如果当前有微任务，还是放入微任务队列微任务执行完毕，尝试dom渲染（不一定渲染，dom有更改则渲染）轮询查找宏任务队列callback quene，如有则移动到call stack执行然后继续循环以上过程。除了放置异步任务的事件，”任务队列”还可以放置定时事件。也就是settimeout和setinterval，所以他们只是类似异步，但不是异步函数 虽然dom事件不是异步，但也用event-loop注意dom事件（dom事件不是异步）像click是立即执行，click事件中的代码才是需要等待event-loop轮询执行的代码promise也是一样，promise.then之后的才是异步回调。比如下面的例子 结果：123before timeoutalso before timeout45 从event-loop解释，为什么微任务执行时机更早微任务是es6语法规定的 宏任务是浏览器规定的微任务存储于micro task queue，不存储在web apis中同步代码执行完毕–&gt;清空call stack–&gt;执行微任务–&gt;dom渲染–&gt;执行宏任务 for循环里面有1000次循环，前500次每次都是把data赋值为1，后500次每次都是把data赋值为2，问：dom一共渲染了几次？DOM一次都没有渲染，因为for循环是一个js执行的持续过程。js和DOM渲染是共享一个线程，js执行时DOM不会渲染。js 和 DOM 渲染是共享一个线程，js 执行时 DOM 不会渲染。除非其中有宏任务。"},{"title":"理解比特、字节、千字节、兆字节和千兆字节：计算机存储的基本单位","date":"2020-06-21T02:55:58.000Z","url":"/2020/06/21/byte/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"当我们谈论计算机存储时，经常会听到一些单位，如比特、字节、千字节、兆字节和千兆字节。这些单位帮助我们描述和量化计算机存储容量的大小。让我们来逐一了解它们的含义。 比特（bit）：信息的最小单位比特是计算机中最基本的存储单位。它表示一个二进制位，可以是0或1。比特是计算机存储和传输信息的最小单位。通常用小写字母”b”表示。 以一个开关为例，当开关打开时，表示为1，当开关关闭时，表示为0。这就是比特的概念。比特可以被视为信息的基本颗粒。 字节（byte）：常见的存储单位3·字节是计算机存储容量的常见单位。一个字节由8个比特组成，可以存储一个字符或一个整数。字节用大写字母”B”表示。 字节是计算机处理和存储数据的基本单元。我们可以把它想象成一串开关，共有8个开关，每个开关都可以是0或1。这使得我们能够表示更大范围的数字和字符。 千字节（KB）、兆字节（MB）和千兆字节（GB）：存储容量的扩展为了表示更大的存储容量，我们引入了一些更大的单位。 千字节（KB）：1 KB等于1024字节。它是字节的一千倍。KB是Kilobyte的缩写。 兆字节（MB）：1 MB等于1024 KB，或者约100万字节。MB是Megabyte的缩写。 千兆字节（GB）：1 GB等于1024 MB，或者约10亿字节。GB是Gigabyte的缩写。 这些单位使我们能够描述和量化越来越大的存储容量，例如硬盘、内存和文件大小。 以文字文档为例，一个典型的文本文件可能只有几千字节（KB）大小。而一部电影的文件可能有几千兆字节（GB）的大小。 总结比特、字节、千字节、兆字节和千兆字节是我们在计算机存储中经常遇到的单位。 比特是信息的最小单位，表示为0或1。 字节是计算机中常见的存储单位，由8个比特组成。 千字节（KB）、兆字节（MB）和千兆字节（GB）是字节的扩展单位，用于描述更大的存储容量。 "},{"title":"【练字】硬笔书法","date":"2020-05-24T05:23:38.000Z","url":"/2020/05/24/paint/paint-picture3/","tags":[["练字","/tags/%E7%BB%83%E5%AD%97/"]],"categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":" 字没几个，写都写了一天而且我发现即使练了字，我正儿八经写字还是那么难看虽然看起来没几个字，其实我写了一下午 "},{"title":"blender场景练习(low poly)","date":"2020-04-19T07:21:49.000Z","url":"/2020/04/19/jianmo/bl-practice2/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 这次在渲染方面学习到了粒子系统和着色器。着色器节点之后我会写文总结。就现在的bl版本，变化太快，这个版本有的节点，到下个版本可能就会被删除了。这一点让人很头大。改天需要下载keyshot，我还是喜欢用zb。雕刻什么的最好玩了吖~！~~~~！~~~~"},{"title":"blender场景练习1","date":"2020-04-03T04:21:49.000Z","url":"/2020/04/03/jianmo/bl-practice1/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 这是我初次学到用体积散射可以做出空气透视的效果，在场景透视中是很常用的。 c "},{"title":"【乱七八糟】生鱼片的种类","date":"2020-01-24T01:10:38.000Z","url":"/2020/01/24/ssyplx/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"金枪鱼 金枪鱼，在香港被称吞拿鱼。蓝鳍金枪鱼、马苏金枪鱼、大眼金枪鱼和黄鳍金枪鱼是生鱼片原料鱼，其中又以蓝鳍金枪鱼肉质最佳。我们经常吃的金枪鱼肉为红色，是瘦肉部分。而带有脂肪的部分呈现的是桃红色，油脂感更重。 三文鱼 三文鱼，学名“鲑鱼”。鱼鳞和鱼刺少，肉色橙红，配上厨师不凡的刀工，呈现出漂亮的纹理。肉质细嫩鲜美，口感爽滑。针对三文鱼出现的寄生虫，日本规定三文鱼一般要经过冷冻-解冻或者无菌处理之后，才可以食用。 鲣（Jiān）鱼 当下正是鲣鱼肥美时，这种鱼一般以碳烤至半生熟的形式制成刺身，更能品尝出鱼肉质的鲜甜滋味。日式料理中经常用到的柴鱼高汤就是用鲣鱼制成的，剔除鱼刺并反复烟熏后的鲣鱼还是日本家常的调味料。 鰤（Shī）鱼 日本人似乎特别钟情于鰤鱼。他们对鰤鱼称呼多种多样，甚至在每个生长阶段都不同，生长到10公斤以上的被称为“出世鱼”（日本语中的“出世”有升官的意思）。鰤鱼最好的食用季节是在冬季，价格低廉却美味，肉质偏硬。 竹荚鱼 竹荚鱼，世界主捕鱼种之一。主要食用品种是宽竹荚鱼，鱼肉肥瘦适中，鲜美的口感深受人们喜爱。除了制作生鱼片外，竹荚鱼还可烤制，外焦内嫩，口味多样，是搭配便当的上佳食材。 鲷（Diāo）鱼 日本关西地区喜欢的白色鱼肉中就有鲷鱼。鲷鱼是一种上等的食用鱼类，肉质细致嫩滑且清淡，除了刺身之外，还可以采用红烧、煨汤等方法烹饪。因发音与日语中的“吉祥”相似，也是宴席中的常见料理。 鲈鱼 中文里很多种鱼类都可以成为鲈鱼，食惑君今天要说的是海鲈鱼，学名是“日本真鲈”。这种鲈鱼肉是几乎不带血的白色，口感上和鲷鱼类似，口味清淡、肉质柔软。夏天的海鲈脂肪含量更多，最为肥美。 秋刀鱼 秋刀鱼应该是日本料理秋季的代表。我们常见的烹饪方式就是烧烤了，鱼肉配合盐粒的滋味，猫和你都想了解。而在做成刺身时，为了去腥会搭配生姜等食材。 章红鱼 章红鱼，又叫红甘鱼，在日本被称为kanpachi（堪八鱼）。紧实的肉质富含嚼劲，同时又有平衡的肥感，是生鱼片的上等原料。除了制作刺身外，也可以用来煲汤、煎食。 青花鱼 这种鱼只有在新鲜的时候才能被作为刺身的材料，一但食用不新鲜的青花鱼会引起食物中毒。除了制作刺身之外，还可以烤制、醋浸、熏制等方法处理。 鲱（Fēi）鱼 没错，就是黑暗料理鲱鱼罐头里的主角。鲱鱼也是刺身的一种材料，这种鱼一般长度18cm - 40cm，鱼骨较小，脂肪含量少。新鲜鲱鱼味道和罐头不同，有些淡淡的甜味，吃的时候，会蘸一些调料去除腥味。 河豚 美味与危险并存的食材。河豚在食用前需要精心的准备，需要将可食用部分和有毒的内脏分开，只有在料理店中拥有相关资格证书的厨师才能料理河豚。河豚肉为白色，切成薄如蝉翼的片状，菊花状摆盘，是上等的刺身料理。 甜虾 甜虾是日本北海道的名产之一，外壳呈粉红色且柔软，剥去虾壳后，有一种新鲜的滑嫩感。品尝甜虾，可以尝到海水的咸味和虾本身的甜味。 北极贝 北极贝不仅用于刺身中，还可以用于制作寿司。将其制作刺身时，只需简单的解冻切片即可。口感上，北极贝相较于大多数贝类要厚实很多，入口无腥味。对于刚接触刺身的人来说，是可以入口的种类之一。 蚶（hān）子 蚶子也是在刺身中十分常见的贝类。蚶子肉质鲜美，咀嚼感强，是喜欢贝类刺身的人最常吃的品种。我国也有食用蚶子的饮食习惯，一般放入沸水中稍稍烫一下就可以吃了。 扇贝 无论在东方或者西方的食谱中，扇贝都是极其普遍和受欢迎的贝类。日本人将其作为刺身，可以明显感受到这种贝类的鲜甜。而在我国，经常将它用作烧烤和煲汤。 海螺 这里的海螺指的是“つぶ貝”，是海螺的一种，典型的食用贝类之一。作为刺身时，肉质稍硬，口感很脆、有嚼劲，并伴有微苦的味道。有些食客不喜欢海螺，就是因为它有苦味。 海胆 海胆最佳的食用方式就是刺身了。新鲜的海胆搭配山葵（わさび）和酱油，一口下去，鲜美爽滑，没有海产的那种腥呛味，有一种独特的海鲜味在你口中融化。被誉为日本三珍之一。 乌贼 最新鲜的乌贼也是刺身中的优质食材。乌贼肉质柔软又富有弹性，口感爽脆，推荐用较重的调味料同食去腥。乌贼刺身在国内的日料店由于原料不易保存，所以不算常见。 章鱼 有嚼劲是章鱼刺身的一大特点。一般将章鱼煮熟后切片作为刺身，主要靠调味料提味。在日本，章鱼除了被用在刺身中，还可以被制作为章鱼烧。 三文鱼籽 透亮橙红色的三文鱼籽看着就食欲大振。三文鱼籽为日本北海道地区秋季的特产，一般只需盐渍或者酱油腌渍后就可以享用。品尝时，可以直接吃，也可以搭配黄瓜、紫苏叶用以除腥。"},{"title":"【乱七八糟】寿司的种类","date":"2020-01-24T00:47:35.000Z","url":"/2020/01/24/zlss/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"寿司(すし；sushi)是日本料理的代表之一，属於握饭的一种，出现於江户时代。而寿司的种类很多，每一种都让人垂涎欲滴呢！ 细牧当大多数人想到寿司时，首先想到的是寿司卷。 这是一种切卷寿司，传统上是用一片紫菜（海藻）包裹一层醋饭，中间有蔬菜或鱼。 然后用特殊的竹席将寿司卷成卷，然后切成6至8小块。 Hosomaki 是薄卷，通常只有一种成分。 大多数人都知道鲑鱼卷、蟹卷或鳄梨卷，上面放着鱼子。 Sāmon maki（三文鱼卷）三文鱼寿司卷是迄今为止日本最受欢迎的寿司卷。 您经常会在菜单上看到它作为清酒 maki。 清酒是鲑鱼的意思，只能煮熟吃，sāmon 是生鲑鱼的意思。 在大多数情况下，sāmon maki 会比清酒 maki 更准确。 这是一种简单的maki，但生鲑鱼的味道非常美味。 Kani maki（蟹卷，通常带有蟹棒）Kani maki 是用蟹棒制成的简单卷。 在一些高档餐厅，你会得到正宗的蟹肉（kani），但在更便宜的地方，它是用仿蟹（kanikama）制成的。 不管怎样，这是一道美味的日本蛋黄酱、紫菜和醋饭卷。 Tekka maki（金枪鱼卷）日本金枪鱼卷不像西方版本那样装满蛋黄酱、黄瓜和其他配料。 在这里，我们有一个简单的 maki 卷，里面塞满了新鲜的生金枪鱼。 事实上，这种简单的寿司卷是日本历史上最畅销的产品之一。 河童卷（黄瓜卷）黄瓜卷是每个素食主义者的梦想，因为它尝起来像没有任何动物产品的寿司。 它由黄瓜细条制成，卷成紫菜片，并覆盖着美味的醋寿司饭。 有些人可能会说它尝起来有点乏味，但它是一种完美的清淡、健康和低热量的 maki 选择，搭配酱油和芥末味道很好。 它也很受孩子们和那些不喜欢寿司鱼腥味的人的欢迎。 鳗鱼卷（鳗鱼卷）鳗鱼卷是日本最受欢迎的寿司之一，但它也被认为是一种美味佳肴。 在某些情况下，鳗鱼是新鲜供应的，但通常先用咸味和甜味的酱油腌制，然后煮熟并加入寿司卷。 然后， 一些厨师加了一些黄瓜片 同样，该卷也被称为 unakyu 或 anakyu。 但大多数喜欢鳗鱼的人都喜欢这种美味寿司卷的柔软质地和泥土味。 Oshinko maki（腌萝卜卷）Daikon是一种萝卜 在这种情况下，它用盐腌制，然后用咸海苔和醋饭包起来。 这种寿司卷非常适合喜欢腌制食物味道的人。 由于白萝卜，卷具有亮黄色，并且有点松脆。 纳豆卷这个寿司卷里装满了发酵的大豆。 它有一种非常独特的味道，它是喜欢它或讨厌它的寿司类型之一。 发酵的大豆有刺鼻的味道和气味，但非常健康。 质地粘稠，粘糊糊的，呈棕色，但如果你喜欢大豆，你可能会喜欢这个正宗的卷。 莳四郎 （金枪鱼和葱卷）我已经提到了基本的金枪鱼卷，但日本人喜欢将鱼腥金枪鱼的味道与葱花（葱）的强烈味道结合起来。 洋葱发出美妙的嘎吱声，与新鲜的金枪鱼完美搭配。 它还用芝麻装饰，配以腌姜、芥末和酱油。 根浜真纪 （黄尾葱卷）这个 maki 卷是黄尾鱼刺身和香脆葱的组合。 黄尾鱼是一种富含脂肪的鱼，但它的质地柔软、嫩滑、有嚼劲，所以很适合搭配大葱。 Kanpyo maki（干葫芦卷）这个不那么受欢迎，但它仍然是一个有趣的尝试。 它是用干葫芦（葫芦果）制成的。 在加入寿司卷之前，它会再水化，并用一些酱油、甜米酒和糖调味。 然后，它被切成小块，加入紫菜和米饭中。 味道是甜味、咸味和酸味的完美结合。 Umekyu maki（酸梅黄瓜卷）Umeboshi 是日本腌制的李子，搭配黄瓜片，是终极清爽的 maki 卷。 李子有甜味，但结合新鲜的黄瓜和醋饭，即使是纯素食者，它也是素食者和食肉动物的喜悦。 鳄梨卷（素食主义者）和三文鱼寿司卷一样，鳄梨卷也很受欢迎。 除了，这个不含鱼或海鲜，所以它是素食主义者。 新鲜的鳄梨片用紫菜海藻和醋饭卷起来。 对于不喜欢海鲜的人来说，这是终极寿司卷。 哦，更不用说它的健康和低热量。 这卷不是正宗的日本料理，因为日本没有鳄梨，但它是西方的发明。 Futomaki这些是大一点的寿司卷，里面塞满了几种配料。 这种寿司被称为“肥”卷，因为它比其他寿司更厚。 Futomaki 不是传统的日本人，但它确实起源于日本。 它来自庆祝活动 江本卷 这在 1960 年代由连锁便利店推广。 江本卷Ehomaki是一种 希 传统上在日本春天开始前一天在节分吃的面包卷。 ehomaki这个名字来自日语中的“幸运方向”，指的是面朝一年的幸运方向吃的事实。 Ehomaki 通常用紫菜（海藻）包裹寿司米饭和鱼、蔬菜或鸡蛋等馅料制成。 它通常很大，但人们会在节日当天尝试将整个面包卷吃掉。 uramakiuramaki 是“外卷”，因为米饭在外面而不是在中间。 紫菜海藻片用在米饭的里面，把配料放在一起。 Uramaki是一种futomaki，因为它是一种含有多种成分的大卷，但它是西方发明的，而不是日本人的发明。 最受欢迎的 uramaki 类型是加州卷、蜘蛛卷、费城卷和彩虹卷。 都是美国寿司的发明。 TemakiTemaki 是手寿司卷，将紫菜片卷成锥形，然后填充 鱼露、蔬菜和米饭。 这种类型的寿司大多用手吃，因为它们太大了，不能用筷子吃。 军舰寿司 这种类型就像maki寿司，只不过是像船（Gunkan）一样形成的，海藻包裹在侧面，馅料放在米饭的顶部，而不是在里面滚动。 也称为战舰寿司，它是将烤海藻 (nori) 折叠在用米醋调味的米饭团周围，形成一个很好的形状，可以填充不同的成分，如鲑鱼子 (ikura)、牡蛎、飞蝇鱼子 (tobiko) 或海胆子 (uni)。 稻荷族 稻荷寿司是最不寻常的寿司，因为它是油炸的。 同样，这种寿司的大多数品种都不含鱼或其他海鲜，而且面包卷的味道很甜。 这个稻荷是豆腐做的。 它看起来像一个小袋子，里面装有用调味料煨制的油炸豆腐。 大多数品种都用煨豆腐 料酒，大石，酱油和一些糖，使它具有甜味。 这种寿司的其他受欢迎的品种包括醋米袋和充满煎蛋卷的inari。 手鞠 Temari寿司被翻译为“手球”，这是因为这种寿司具有小手滚球的形状。 它是一种不太受欢迎的寿司品种，主要是在家里制作以用于庆祝活动。 因为它很小，所以它是很棒的手指食物。 它是一个小小的圆形醋饭球，上面放着一层鱼。 通常使用生鲑鱼，但也可以使用熏鲑鱼和其他鱼类。 片叶ha 这是在日本奈良地区流行的一种非常独特的寿司。 将寿司饭压榨并包裹在柿子叶（柿子）中。 寿司很简单，就是将一条鱼放在米饭上，然后像小包装一样包裹起来。 鲭鱼，鲑鱼，虾和鳗鱼都是受欢迎的馅料。 贞十 与上面的柿叶寿司类似，这是竹叶寿司。 它有米饭和一些浇头，用竹叶包裹。 最常见的浇头包括鲑鱼和其他鱼类，蔬菜，甚至还有鸡蛋。 有核桃，竹笋甚至艾蒿的萨沙寿司品种。 押寿司 这种压制寿司是 大阪地区常见 它最初创建的地方。 它是通过将寿司原料分层放置在一个矩形盒子中制成的。 单个寿司片看起来像小角米饭三明治。 通常情况下， 大寿司 装在便当盒中，作为特殊场合的礼物赠送。 常见成分包括鲑鱼，鲭鱼，g鱼和竹叶。 Narezushi和Funazushi 这是原始作品“鲋寿司”的文字叠加图像 吉田康夫 在CC许可下在Flickr上 Narezushi是我们列表中最奇怪的寿司类型。 Narezushi是一种传统的日本鱼菜，是将鱼在盐和米中保存数月而制成的。 它经过发酵，具有发酵食品的典型酸辣味。 据信这是现代寿司的原始前身。 如今，有一种叫做Funazushi的品种，将鱼发酵才需要5年才能上菜，因此非常昂贵。 船寿司是一种寿司，将整条鱼用盐腌制并发酵，然后放在煮熟的米饭床上。 这不是真正的经典寿司类型。 最常见的全鱼船寿司是用一种叫做 nigorobuna 鱼（来自金鱼种类）的鲤鱼制成的。 这种nigorobuna鱼也被称为寿司的完美鲤鱼。 江户前寿司 在日本，还有一种有趣的寿司叫做江户前寿司。 这是一种握寿司，将鱼放在醋饭床上。 事实上，它是我们今天所说的握把的前身，它被称为“江户前”，因为它起源于多年前的江户时代。 但是，今天的江户前寿司在一个主要方面不同于握寿司。 它是用称为 akasu 的红醋制成的，而不是普通的醋饭。 这种赤须醋由酒糟制成，呈红色。 您可能不会在所有餐厅都找到这种寿司，因为它是仅在传统餐厅供应的特色寿司。 为什么要用红醋？此外，还有很多准备工作要带出鱼的味道。 红醋仍然是正宗江户前寿司的标志。 不同之处在于 江户前寿司的红色“akasu”或醋，比现代米醋味道更浓。 然而，它仍然是温和的，而不是压倒性的。 它与江户前寿司的鱼的味道完美搭配，因此您无需担心陌生或不熟悉的味道。 带出味道今天的握寿司主要是将新鲜的鱼放在寿司饭上，然后将其提供给顾客。 很多时候，除非你去成熟的日本寿司店，否则鱼不是你能找到的最好的。 江户前寿司需要大量准备，然后才能将鱼涂抹在米饭上。 这种准备工作类似于如何使用红醋来调味米饭。 这样做也是为了增强鱼的天然香气和风味。 例如，经典的金枪鱼在烹饪前先用酱油腌制。 预先煮熟的鳗鱼和比目鱼等白肉鱼可以用海带保存。 烤鱼可用于油性鱼。 如果烤鱼特别油腻，可能是一个不错的选择。 江户前寿司最好是将浓郁的红醋味与“预先准备好的”鱼和海鲜相结合。 千岚 日语中chirashi的基本定义是“分散的”。 那么，chirashi是什么？ 这是 一碗寿司饭，先用米醋调味，然后放上各种生鱼片和不同的装饰物。 这道菜中使用的生鱼通常是厨师的选择。 Chirashi制作简单，容易，并且可以方便地用餐。 在日本，这道菜使用了不同的浇头，这取决于品尝美味佳肴的地区。 通常，chirashi是在23月XNUMX日庆祝日本日的Hinamatsuri的Doll Day或Girls Day食用的。 常见的寿司面和浇头寿司最受欢迎的三个方面是芥末，酱油和腌姜。 芥末是由日本辣根制成的绿色酱。 酱油是咸的，有助于寿司的鲜味。 腌姜可以清洁餐食和不同类型的寿司之间的调色板。 可以品尝到食物的真正风味。 最常见的浇头是鱼卵。 小的橙色或黑色的球放在寿司上。 这被称为“飞鸟”或“正子”，在日本和北美很流行。 "},{"title":"jsdelivr结合github搭建cdn图片仓库t","date":"2020-01-11T06:34:08.000Z","url":"/2020/01/11/cxy/other/jsdelivr/","tags":[["jsdelivr","/tags/jsdelivr/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" jsdelivr简介jsdelivr.net是著名的CDN服务提供商，可以加速前端静态资源访问速度。 jsdelivr 使用首先在github新建仓库，然后提交一张测试图片上传，点击release 在这里新增一个版本号，点击Publish release 然后使用你的用户名/你的仓库名@版本号/就可以访问静态资源了"},{"title":"在github pages中集成Gitalk功能","date":"2019-12-11T10:48:34.000Z","url":"/2019/12/11/cxy/other/gitalk/","tags":[["实用开源代码","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" Gitalk简介Gitalk 是一个基于 Github Issue 和 Preact 开发的评论组件，支持 MarkDown 语法。 官方地址  特性 使用 github 帐户进行身份验证 无服务器，所有评论将存储为github问题 个人和组织github项目均可用于存储评论 本地化，支持多种语言[en，zh-CN，zh-TW，es-ES，fr，ru，de] 类似于Facebook的无干扰模式（可以通过distractionFreeMode选件启用） 热键提交评论（cmd | ctrl + Enter） 安装方法有两种 links npm install 用法 首先创建一个公共的 github 存储库来存储评论。（现有的也ok，反正只是用到issue不会影响仓库代码。） 创建一个GitHub 应用程序，创建方法请单击此处注册一个新应用程序。 注意： 必须在字段中指定网站域 url Authorization callback URL（回调的地址），都写你的个人网站地址就可以了。创建成功后，跳转到此记住clientID和clientSecret，是之后要配置的。 选择如何应用到页面，如下所示： 方法：将容器添加到您的页面： 然后使用下面的Javascript代码生成gitalk插件： 其中clientID和clientSecret是上面生成的，填入你的就可以了。 选项 客户端ID String 必填。GitHub 应用程序客户端 ID。 客户秘密 String 必填。GitHub 应用程序客户端机密。 回购 String 必填。GitHub 存储库。 所有者 String 必填。GitHub 存储库所有者。可以是个人用户或组织。 行政 Array 必填。GitHub 存储库所有者和协作者。（对该存储库具有写入权限的用户） ID String 默认值：location.href. 页面的唯一标识。长度必须小于 50。 数字 Number 默认值：-1. 页面的issue ID，如果number没有定义该属性，则使用.issue定位issue id。 标签 Array 默认值：[&#39;Gitalk&#39;]. GitHub 问题标签。 标题 String 默认值：document.title. GitHub 问题标题。 身体 String 默认值：location.href + header.meta[description]. GitHub 问题正文。 语言 String 默认值：navigator.language || navigator.userLanguage. 本地化语言键，支持[ en, zh-CN, zh-TW, es-ES, fr, ru, de, pl, ko, fa, ja]。 每页 Number 默认值：10. 分页大小，最大 100。 无干扰模式 Boolean 默认值：假。 类似 Facebook 的无干扰模式。 pagerDirection String 默认值：“最后” 评论排序方向，可选值为last和first。 手动创建问题 Boolean 默认值：false. 默认情况下，当登录用户属于用户时，Gitalk 会自动为您的每个页面创建一个相应的 github 问题admin。您可以通过将此选项设置为 来手动创建它true。 代理人 String 默认值：. GitHub oauth 请求 CORS 的反向代理。为什么需要这个？ 翻转移动选项 Object 默认： 评论列表动画。参考 启用热键 Boolean 默认值：true. 启用热键 (cmd|ctrl + enter) 提交评论。 效果演示点击访问"},{"title":"axios的基本使用","date":"2019-11-12T07:20:18.000Z","url":"/2019/11/12/cxy/other/axios/","tags":[["axios","/tags/axios/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、axios的发送类型和restful api一样axios基于promise，它支持promiseapi 1. 基本用法 或 注1：还有增（post）删（delete）改（patch/put）查（get）这些，以及head和option。 注2：OPTIONS方法返回有关API 的信息（方法/内容类型）: 2. 并发axios.all(iterable)###3. axios.create()###4. axios可以拦截请求和响应在请求和响应被then或catch之前做某些操作。比如请求前加入token，响应时如果返回数据错误，可以跳转到登录页 request的config里返回的，最后可以返回data以继续下面的请求 response里面返回的，最后也是return以用于响应 5.客户端支持xsrf防御6.axios常见的配置："},{"title":"【nodejs】基础总结（六）express简单概括","date":"2019-08-11T08:02:32.000Z","url":"/2019/08/11/node-express/","tags":[["node","/tags/node/"],["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"六、使用express来处理http请求1. 什么是expressNode.js的Express是一个流行的Web应用程序框架，它可以帮助你构建具有后端功能的Web应用程序。Express使得创建服务器和路由处理非常简单，并提供了许多有用的功能，如处理HTTP请求、路由管理、模板引擎支持等。 简单代码举例： 访问，浏览器返回 当然，使用前需要安装express。 2. restful api请求路由按照顺序从上往下匹配 一般方法express可以发送restful api符合的所有请求类型。 （post delete put get 再加俩head option） app.all()表示无论发送的请求类型是什么，只要地址匹配，就会进行响应。一般用于在用户访问错误的地址时，给一个提示页面。 当我输入一个错误的地址时，浏览器显示如下 3. 获取请求内容express除了兼容原生的请求报文提取，还封装了一些新的提取方式。 基本方法req.get(header): 获取请求头相关，header是字符串，表示需要获取的请求头名称。 req.path: 获取请求的路径 req.query: 获取请求的query req.ip: 获取请求的ip 当访问时 可以看到通过express方式获取的请求数据会比较方便 4. 设置动态路由当不确定访问地址是什么的时候，可以动态匹配占位符（：），然后使用req动态获取。 req.params: 获取动态路由的参数对象 当访问时，返回如下： 当商品id不是十位时，返回如下： 5. 设置响应的内容express除了支持原生的获取响应体方式之外，还提供了额外的方法。 res.status(n:number) 状态码 res.set(header:string,content:string) 设置 res.send(content:string) 内容屏。 6. 其他的相应类型下载下载文件 或 JSON redirect使访问网站重定向到一个新的url。返回状态码为302 sendFile将文件发送到浏览器。比如json、html等等吖 简单示例： 七、中间件当用户访问时，会首先访问中间件，然后再去执行路由的内容。 中间件的本质是一个回调函数。 在中间件函数中可以像路由毁掉一样访问req和res express可以自定义中间件，使用app.use()进行调用，也可以使用内置的中间件。 如何理解的中间件呢？想象一下你去一家餐厅吃饭，中间件就像服务员在你点菜后将菜单传递给厨房的过程。在这个过程中，服务员可以检查菜单上的信息、将订单记录在点菜单上、通知厨师制作食物、检查食物是否符合你的要求，并最终将食物送回你的桌子上。中间件在你点菜和享受美食之间执行了一系列操作，就像在请求和响应之间执行的代码一样。 1. 自定义全局中间件当用户访问时，会首先执行全局中间件，然后再去执行路由的内容。 比如：需要一个服务器日志，当用户访问时，需要服务端记录访问的路径，访问的是谁，访问的时间，访问的次数等等。 示例存在index和detail两个地址，需要记录用户访问他们的时间、地址、ip，可以用以下方式实现 执行结果： 虽然可以实现功能，你会发现，两个路由中，有很大一部分都是重复的。都是获取url和ip，并像log中追加相同内容。 如果路由有成千上万个的话，每一个都写相同的一部分是冗余的。 这时候我们就可以将其提取出来，作为中间件去执行。 中间件写法先声明中间件函数，然后使用app.use()去执行中间件函数。 结果 2. 自定义路由中间件只在某些路由中起作用的中间件。一般在校验用户是否有权限时可以使用的。 比如，有路由index、detail、list，当满足query中有参数login=true时，允许访问detail，否则返回提示”哎呀！页面找不到了” 步骤 创建路由中间件函数 在需要配置该中间件的路由中，加入该函数 3. express内置的中间件express内置的中间件和自定义的全局中间件一样，使用app.use()调用 常用的内置的中间件类型有： **express.json()**：这个中间件用于解析传入的 JSON 请求体。它会将请求体解析为 JavaScript 对象，以便在后续的路由处理中使用。 **express.urlencoded()**：类似于 express.json()，这个中间件用于解析传入的 URL 编码形式的请求体，通常用于处理表单提交。 **express.static()**：这个中间件用于提供静态文件（如 CSS、JavaScript 和图像）的服务。你可以指定一个目录，Express 会从该目录中提供文件，以便客户端可以访问它们。 **express.Router()**：express.Router() 是用于创建可重用路由器的中间件。你可以将路由器与不同的路径挂载到应用程序中，以便将请求分发给不同的路由处理函数。 **express.jsonp()**：这个中间件用于支持 JSONP（JSON with Padding）响应，允许跨域请求并接收 JSONP 格式的响应。 **express.raw()**：类似于 express.json()，这个中间件用于解析传入的原始二进制数据请求体。 **express.text()**：类似于 express.json()，这个中间件用于解析传入的文本数据请求体。 静态资源中间件这里以静态文件中间件进行举例，比如说在网站目录下有一个public文件夹用于存放静态资源类型。 需要实现：当用户访问网址/资源名时，可以读取到public内的静态文件。 示例： 此时访问可以返回public文件夹下的这张图片。 注意点： 静态资源中间件也遵循自上而下匹配的顺序 路由一般用于响应动态资源，静态资源一般用静态资源中间件响应。 八、body-parser的使用简介：这个中间件用于解析 HTTP 请求体，特别是解析 POST 请求中的表单数据或 JSON 数据。它可以将请求体数据解析为 JavaScript 对象，便于在应用程序中处理。 九、使用express实现防盗链防盗链的功能防盗链是一种阻止其他网站直接使用你的资源（如图片或视频）的方法，通常通过检查请求来源或生成临时链接来实现。这有助于保护你的资源不被未经授权的网站盗用。 防盗链的视线原理： 通过中间件，判断请求头的refer是否为当前域名。 核心代码： 当域名不为localhost时，无法获取资源（用127.0.0.1也获取不到）。 十、 模块化当路由增多时，可以使用模块化进行导入。 封装后可以将文件体积减小，冲突的几率也变小了。 方便管理 易于开发了 模块化： 导出：module.exports 导入：require"},{"title":"【nodejs】基础总结（五）http概念","date":"2019-08-11T08:02:32.000Z","url":"/2019/08/11/node-http/","tags":[["node","/tags/node/"],["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"五、http 相关1. 创建服务器 createServer 结果 2. 提取 http 报文在createServer中，用req和res获取报文。 3. 路径解析在nodejs中，有url模块，可以用来解析路径。 之前在createServer时，已经在req中返回了url路径，然后可以使用nodejs内置的url模块进行路径的解析。 示例代码如下： 结果： 当访问时，返回结果如下： Url.query数组中第一个元素返回Object: null prototype的意思是，该数组是Object，prototype指向null 4. 路径解析的另一种方法可以new URL实例。 如 这两个方法的区别是，nodejs内置的url模块可以解析一个没有域名的地址，而new URL创建的实例对象必须要是一个完整的地址（有域名） 但由于这里解析不关心域名是什么，只是为了获取当前路径的search，所以随便写一个假域名都得。 可以看到searchParams这个属性，用searchParams的get方法去获取参数 如： 5. 响应报文（response相关） 设置response状态码 如 设置响应状态码的描述 如 设置响应头 当需要设置多个同名响应头时，可以使用 使用setHeader和writeHead setHeader 和 writeHead 都是用于设置HTTP响应头的方法，它们有一些区别。 setHeader 方法： response.setHeader(name, value) 方法用于设置指定名称的响应头字段的值。如果已经存在具有相同名称的头字段，则将其值替换为提供的值。 这个方法可以多次调用，每次调用都会设置或覆盖指定头字段的值。 通常用于设置单个响应头字段的值。 示例： writeHead 方法： response.writeHead(statusCode, [reasonPhrase], [headers]) 方法用于同时设置响应的状态码、状态描述和一组响应头字段。 这个方法通常在响应的开始部分被调用，用于一次性设置多个响应头字段和响应的状态信息。 如果你使用了 writeHead，那么后续的 setHeader 调用将覆盖之前设置的同名头字段的值。 示例： 区别： setHeader 主要用于设置单个响应头字段的值 writeHead 用于同时设置响应的状态码、状态描述和多个响应头字段的值，通常在响应的开始部分使用。 选择使用哪个方法取决于你的需求和代码的结构。如果只需要设置一个或两个响应头字段，setHeader 可能更方便。如果需要设置多个响应头字段和状态信息，writeHead 可能更合适。 设置响应体 response.write： response.write 用于向响应流中写入数据，但不会结束响应。这意味着你可以多次使用 response.write 来逐步构建响应内容。 当你使用 response.write 向响应流中写入数据后，响应还没有完成，客户端浏览器仍然等待进一步的数据。 使用 response.write 可以用于分块传输数据，比如在处理大文件下载或流式响应时。 response.end： response.end 用于结束响应并将其发送到客户端。一旦调用了 response.end，响应就会被完成，客户端将收到完整的响应内容。 一般情况下，当你已经写入了所有需要发送的数据时，应该使用 response.end 来完成响应。 调用 response.end 后，你不能再向响应流中写入更多数据，否则会引发错误。 代码示例 6. 请求报文request 对象在请求处理函数中作为回调函数的第一个参数传递。它包含了有关客户端请求的信息，例如请求头、请求方法、请求 URL 等。 常见的属性及方法： request.url: 包含客户端请求的 URL 信息。 request.method: 包含客户端请求的 HTTP 方法，如 GET、POST 等。 request.headers: 包含客户端请求的所有 HTTP 头字段。 代码就不写了，其实上面处理url的部分已经写过了。"},{"title":"【nodejs】基础总结（四）路由的概念","date":"2019-08-11T08:02:32.000Z","url":"/2019/08/11/node-router/","tags":[["node","/tags/node/"],["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"简介 路由可以被看作是一种地址解析和分发机制，它告诉服务器如何对不同的地址或URL进行响应。就像城市交通规则和地图帮助你找到目的地一样。 它是构建Web应用程序的关键部分，用于确保请求被正确处理和响应。 在 Node.js 中，HTTP 模块本身并没有内置路由功能，路由是开发者根据需求自己实现的一部分。 路由的作用 确定如何响应不同的URL路径或地址。 将客户端请求导向正确的处理逻辑。 帮助服务器区分和处理不同类型的请求。 使用路由的步骤 创建Node.js应用程序。 引入所需的模块，包括HTTP模块和路由模块。 设置路由规则，定义URL路径与处理函数之间的映射。 创建处理函数，用于执行与路由关联的操作。 启动HTTP服务器，监听特定端口，并在请求到达时根据路由规则调用相应的处理函数。 使用Express.js框架实现路由 Express.js是一个流行的Node.js Web应用程序框架。 它提供了灵活且易于使用的路由功能，以及许多其他有用的功能，如中间件、视图引擎、静态文件服务、REST API开发等。 Express.js可用于构建具有动态内容的Web应用程序和API。 不使用Express.js框架实现路由"},{"title":"【nodejs】path.join和path.resolve的区别","date":"2019-08-10T08:10:37.000Z","url":"/2019/08/10/node-path2/","tags":[["node","/tags/node/"],["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、 参数拼接 path.join([path1][, path2][, …])path.join()方法可以连接任意多个路径字符串。要连接的多个路径可做为参数传入。 path.join()方法的参数为string，可以加多个参数，最后会拼在一起形成一个地址，若不是string则报错 二、 路径解析：path.resolve([from …], to)path.resolve()方法可以将多个路径解析为一个规范化的绝对路径。其处理方式类似于对这些路径逐一进行cd操作，但resolve在未执行时不会校验其合法性（就是可以不存在这个地址） 相当于 举例： 注意：resolve的第一个参数如果是__dirname，之后出现了/xxx的路径，则会被解析为相对于根目录的绝对路径。拼接时需要注意这一点。 如： and "},{"title":"【nodejs】基础总结（三）path模块","date":"2019-08-09T09:20:37.000Z","url":"/2019/08/09/node-path/","tags":[["node","/tags/node/"],["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"四、 path模块1. 简介path 模块可以对接路径做一些安全的操作，常用方法为resolve和join 2. 常用方法path.resolve 将多个字符串拼接为一个完整的绝对路径path.join 将多个字符串拼接为一个完整路径path.basename 路径基础名称path.dirname 路径目录名path.extname 路径的扩展名"},{"title":"【nodejs】基础总结（二）fs模块","date":"2019-08-08T09:20:37.000Z","url":"/2019/08/08/node-fs/","tags":[["node","/tags/node/"],["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"三、 fs模块1. 简介fs模块可以实现创建文件、删除文件、修改/写入文件、读取文件、移动文件等，还可以操作文件夹。可以实现与硬盘有关的操作。 2. fs.writeFile() 写入文件（异步）语法：fs.writeFile(file,data,options?,callback(err)?) 参数： File 文件名，文件若不存在，会被自动创建 data 写入的数据 options 可选的选项 callback 回调，参数为err，若成功则err返回为null 使用： 注意点： fs.writeFile()是一个异步方法。 3. fs.writeFileSync() 写入文件（同步）语法：fs.writeFileSync(file,data,options?) 参数： File 文件名，文件若不存在，会被自动创建 data 写入的数据 options 可选的选项 使用： 注意点： fs.writeFileSync()是一个同步方法，会逐行向下执行。 它和fs.writeFile()不同的地方在于没有回调函数。 4. fs.appendFile() 追加文件内容语法：fs.writeFile(file,data,options?,callback(err)? 参数： File 文件名，文件若不存在，不会被自动创建 data 写入的数据 options 可选的选项 使用： 注意点： 参数与fs.writeFile() 一致 fs.writeFile()也可以实现追加内容。只需要将第三个参数的option追加 5. fs.appendFileSync() 追加文件内容（同步）略，参数与fs.writeFileSync() 一致， 注意点： 文件若不存在，不会被自动创建。 6. fs.createWriteStream()语法： fs.createWriteStream(file) 创建流 fs.write(content: string) 写入流 fs.close() 关闭流（可选） 参数： File 文件名，文件若不存在，会被自动创建 使用： 注意点： fs.close()可以不调用 应用场景是，比如安装软件，安装软件的过程就是一个文件写入硬盘的过程。再比如写logs等等。 7. fs.readFile() 读取文件（异步）语法：fs.readFile(file,options?,callback(err,data)?) 参数： File 文件名，文件若不存在，会被自动创建 options 可选的选项 callback 回调，参数为err，若成功则err返回为null 使用： 注意点： 8. fs.readFileSync() 读取文件（同步）略，基本一致，就是没有回调函数 9. fs.createReadStream() 流式读取语法：fs.createReadStream(file) 参数： File 文件名，文件若不存在，会被自动创建 options 可选的选项 callback 回调，参数为err，若成功则err返回为null 使用： 注意点： 流式读取，读取的是文件的一部分内容，普通的读取是一次性读取全部内容。一次读取长度默认为65536字节。 chunk.length可以查看读取的长度 该方法一般用于读取大文件，它占用内存空间比直接用readFile要小。 通过以下代码，可以看两种读取方式所占用内存的不同大小 10. fs.rename(oldPath, newPath, callback) 重命名文件（异步）语法：fs.rename(oldPath: string,newPath: string,callback?) 参数： oldPath 源文件路径，如./test.txt newPath 源文件路径的新名称，如./testRename.txt callback 回调，参数为err，若成功则err返回为null 使用： 11. fs.renameSync(oldPath, newPath) 重命名文件（同步）略 12. 文件删除在nodejs中，文件删除有两种方式 fs.unlink(filename) 与 fs.unlinkSync(filename) ``fs.rm(filename)与fs.rmSync(filename)` 注： fs.rm方法在14.4版本以上支持 13. mkdir(dir, option?,callback) 和mkdirSync(dir, option?,callback) 创建文件夹语法: fs.mkdir(path,option,callback) 使用： 14. 读取文件夹 readdir与readdirSync语法: fs.mkdir(path,option,callback) 使用： 15. 删除文件夹 rmdir() 与rmdirSync()语法: fs.mkdir(path,option,callback) 使用： 注意点： 支持递归删除 可能被废除，不建议使用 rm方法不仅可以用来删除文件。 &#123; recursive: true &#125;的意思是级联删除 16. 查看文件状态 fs.stat(file,callback)语法: fs.stat(file,callback) 使用： 结果： 注意点： 返回的data参数中，isFile 方法表示判断是否为文件。isDirectory 方法表示判断是否为文件夹。 一般在用于制作资源管理器时，文件名可以使用readdir和readfile的方式读取，而具体信息则使用stat方式读取 17. __dirname 来表示绝对路径表示__dirname 所在文件夹的绝对路径"},{"title":"【nodejs】基础总结（一）","date":"2019-08-07T09:20:37.000Z","url":"/2019/08/07/node/","tags":[["node","/tags/node/"],["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、提前要了解的内容Node API：fs url http util console 定时器 path 等等 模块 核心语法：javascript 二、Buffer 缓冲区1. 什么是BufferBuffer是一个类似于Array的对象，它用于表示一段固定长度的字节序列。它用来处理二进制的数据。 2. Buffer的特点​ 2.1. Buffer大小固定，且无法调整 ​ 2.2. Buffer性能较好，可以直接对计算机内存进行操作。 ​ 2.3. 每个元素的大小为1字节（byte），八个bit组成一个byte，一个bit就是一个0或1 即：1字节能存储的最大空间为十进制0-255，二进制00000000-11111111，十六进制00-ff 3. 使用方法Buffer是nodejs的内置模块，使用时无需额外导入。 3.1 Buffer.allocalloc方法用来创建一段Buffer，它会将Buffer清零 结果： 注意：上面的 每个 00 都使用16进制表示。即，能存储的最大数为 00-ff ，也就是最大能存储0-255（十进制），00000000-11111111（二进制） 3.2 Buffer.allocUnsafeallocUnsafe方法用来创建一段Buffer，它创建的Buffer可能包含旧的内存数据。所以不太安全。但创建速度比alloc快。 结果： &lt;Buffer 00 00 00 00 00 00 00 00 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 ff ff ff 0a 00 00 00 ff ff ff ff 31 00 00 00 ff ff ff ff 37 00 00 00 00 00 … 9950 more bytes&gt; 3.3 Buffer.from用于将一个字符串、数组、或字符串数组、或Buffer，转换为一段Buffer 结果： &lt;Buffer 61 62 63 64 65 66&gt; 即：abcdef六个字母的的16进制unicode码 3.4 将buffer转换为字符串上面说过，Buffer.from接收数组，将其转换为一段Buffer 3.5 修改和获取Buffer的值获取： 修改： 注：如果数字超过255，则超出位数会被舍弃掉。 如 256的16进制为100，那么存储为buffer会变成00 "},{"title":"【nodejs】Nodejs基础总结之事件（二）事件类型","date":"2019-08-03T07:13:45.000Z","url":"/2019/08/03/node-event2/","tags":[["node","/tags/node/"],["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、种类Node.js 的事件系统主要包括以下几种事件类型和相关的事件： EventEmitter（自定义事件）：这是 Node.js 事件系统的核心，你可以使用它来创建自定义事件和事件监听器。你可以注册自定义事件并为其添加监听器，然后在适当的时候触发这些事件。这个事件类型是最常用的。 HTTP 事件：Node.js 中的 HTTP 模块也支持事件，例如 request 和 response 事件。你可以监听这些事件以处理 HTTP 请求和响应。 文件系统事件：Node.js 的文件系统模块（fs 模块）支持一系列事件，如 open、close、data、end 等，用于处理文件操作和读取。 流事件：Node.js 中的流（stream）是一种用于处理数据的抽象接口，它们支持多种事件，如 data、end、error 等。流事件用于处理数据的输入和输出。 定时器事件：Node.js 中的 setTimeout 和 setInterval 方法用于创建定时器，它们会触发定时器事件，让你可以执行定时任务。 网络事件：Node.js 中的网络模块（例如 net、dgram 等）支持事件，用于处理网络连接、数据传输和套接字事件。 这些是 Node.js 中常见的事件类型，但你也可以创建自定义事件类型，以满足应用程序的需求。Node.js 的事件系统是构建异步和事件驱动应用程序的核心部分，它允许你有效地管理和处理各种异步操作和事件。 二、EventEmitter介绍EventEmitter 是 Node.js 事件系统的核心，它提供了用于创建、注册和触发事件的方法。以下是 EventEmitter 的一些重要属性和方法： EventEmitter 类：EventEmitter 是一个构造函数，用于创建事件对象的实例。通常，你需要先引入 events 模块，然后创建一个自定义事件类继承自 EventEmitter。 **on(event, listener)：或addListener(event, listener)**。用于注册事件监听器。当特定事件（由 event 参数指定）触发时，与之关联的回调函数（listener）将被执行。 **once(event, listener)**：与 on 类似，用于注册事件监听器，但它只会在事件第一次触发时执行回调函数，之后就会被移除。 **emit(event[, arg1][, arg2][, …])**：用于触发特定事件，可选择传递参数给事件监听器。它会执行与事件关联的所有回调函数，并将参数传递给这些回调函数。 **removeListener(event, listener)**：从事件的监听器数组中移除指定的事件监听器。 **removeAllListeners([event])**：从事件的监听器数组中移除所有监听器。如果提供了 event 参数，只会移除指定事件的监听器。 **listenerCount(event)**：返回指定事件的监听器数量。 **setMaxListeners(n)**：设置单个事件可以添加的最大监听器数量，默认情况下为 10。如果需要更多监听器，可以使用这个方法来调整最大限制。 三、自定义事件以下是一个简单的示例，演示如何创建和触发自定义事件： 在这个示例中： 我们首先引入了 events 模块并创建了一个自定义事件类 MyEmitter，该类继承自 EventEmitter。 然后，我们创建了一个 MyEmitter 的实例 myEmitter。 使用 .on 方法，我们注册了一个事件监听器，它监听名为 “customEvent” 的自定义事件。当 “customEvent” 事件被触发时，监听器会执行回调函数，并打印传递给回调函数的参数。 最后，我们使用 .emit 方法来触发自定义事件 “customEvent”，并传递两个参数（’Hello’ 和 ‘World’）给事件监听器。 当运行这段代码时，会输出如下内容： "},{"title":"微信小程序相关","date":"2019-07-21T11:39:12.000Z","url":"/2019/07/21/cxy/review/wechat/","tags":[["微信小程序","/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 初始化项目文件 根目录：app.json：项目配置文件，可以配置页面包括：page、tabbar、window、plugin等等app.js：每个页面都会去处理的方法。比如判断当前版本是否最新，还有是否有登录信息等等。app.wxss：全局的样式文件project.config.json：项目配置文件。可以设置一些编辑器的样式，设置一些js编译为es5是否禁用严格模式、上传时是否压缩、分包分不分等，是开发时的设置，在小程序侧边可以直接打钩设置。project.private.config.json：很多时候我们需要进行开发调试，利用微信开发者工具的预览功能在真机上查看实现效果。为了方便调试，我们会设置编译模式。但是编译模式的改动会写入 project.config.json 文件的 condition 字段中，而项目只有一份 project.config.json 文件。所以在团队协作的时候，每个人都在往里加入自己的编译模式，这给团队造成了一点麻烦。解决方案如下： 在 .gitignore 文件中添加 project.config.json、project.private.config.json 为项目引入 project.config.json.example 文件作为项目配置文件统一模板 团队成员使用 project.private.config.json 作为个人配置（此配置文件会优先使用） sitemap.json：是否允许微信索引（爬虫相关）pages文件夹：存储页面。 wxss wxml jsskyline WXSS和webview：skyline的性能更好些，不支持css animation wxss的常用组件视图容器swiperswiper-item moveable-areamoveable-view scroll-viewmatch-mediaroot-portal（position: fixed）viewblock 基础内容grid-viewlist-viewiconprogressrich-texttext 表单组件buttoncheckboxcheckbox-groupforminputslidepickerpicker-viewradioradio-groupswitchtextareaimagemap 小程序框架小程序生命周期点击查看文档onLaunch：全局app.js中的，他的触发比page中的onLoad要高onLoad：页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。onShow：页面显示/切入前台时触发。onReady：页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。onHide：页面隐藏/切入后台时触发。如 [wx.navigateTo]( api/route/wx.navigateTo.html) 或底部 tab 切换到其他页面，小程序切入后台等。onUnload：页面卸载时触发。如wx.redirectTo或wx.navigateBack到其他页面时。 其他page内的事件onPullDownRefreshonReachBottomonShareAppMessageonPageScroll##事件用bind或catch绑定（catch阻止向上冒泡）capture-bind（捕获）bindtapbind:touchstartbind: longpress还有一些单独组件的事件可以看看文档，比如swiper的bindtransitionbindanimationfinish等等等吖吖吖##常用api整理this.setDatawx.request wx.navigateTo：保留当前页面，跳转到应用内的某个页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。 wx.redirectTo：重定向。使用 wx.navigateBack 不可以返回到原页面 wx.createVideoContext(‘xxx’);xxx是video标签的id wx.showToast wx.getStoragewx.setStoragewx.clearStorage() wx.showShareMenu wx.canIUse wx.hideNavigationBarLoading() //在当前页面隐藏导航条加载动画wx.stopPullDownRefresh() //停止下拉刷新 面试题1、简单描述下微信小程序的相关文件类型?2、小程序的双向绑定和vue哪里不一样?3、小程序页面间有哪些传递数据的方法?使用全局变量实现数据传递app.js中定义globalData，然后在单独的文件中使用 使用navigateTonavigateTo的url后面跟?参数也可以实现数据传递，在新页面onLoad方法中使用 在新页面中 wxs定义公共工具类，比如叫utils，可以使用import引入 wxs也可以导出模块 使用getStorage本地缓存的清理时机跟代码包一样，只有在代码包被清理的时候本地缓存才会被清理。 4、小程序的生命周期5、如何下拉刷新在app.json中，或者在对应的json中设置 在钩子函数onPullDownRefresh中，监听下拉刷新，调用setData去更新数据，设置flag，让更新不会多次给重复触发中。请求成功后，调用wx.stopPullDownRefresh去停止下拉刷新。 6、bindtap和catchtap停止冒泡 7、wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别?wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面wx.redirectTo()：关闭当前页面，跳转到新的页面（类似重定向）。但是不允许跳转到 tabbar 页面wx.switchTab()：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面wx.navigateBack():关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层wx.reLaunch()：关闭所有页面，打开到应用内的某个页面###8、登录的流程点击查看：登录流程描述 9、app.json 全局配置文件描述pages : 用于存放当前小程序的所有页面路径window : 小程序所有页面的顶部背景颜色，文字颜色配置。tabBar : 小程序底部的Tab ,最多5个，最少2个。 10、小程序运行机制热启动 ：假如用户已经打开了某个小程序，在一定时间内再次打开小程序的话，这个时候我们就不再需要重新启动了，这需要把我们的后台打开的小程序切换到前台来使用。冷启动：用户首次打开小程序或被微信主动销毁再次打开的情况，此时小程序需要重新加载启动。 11、小程序什么时候会主动销毁？小程序在进入后台之后，客户端会帮我们在一定时间内维持我们的一个状态，超过五分钟后，会被微信主动销毁. 官方也没有明确说明 什么时候销毁， 在不同机型表现也不一样， 2019年开发时：时间官方文档没有说明，但是经过询问一般指5分钟内 2020年开发时：时间官方文档没有说明，实测安卓没有固定时间，内存足够情况下，有时候一天了还在，有时候几分钟就没了。 12、小程序怎么跟随事件传值在 页面标签上通过 绑定 dataset-key = value ， 然后绑定点击通过e.currentTarget.dataset.key 来获取标签上绑定的值。 13、小程序支付小程序有一个统一下单的api接口。点击查看：微信支付点击查看：云支付 小程序或公众号调用微信云托管，在微信云托管中调用统一下单接口，参数中带上接收异步支付结果的服务名称和其所在云环境ID 统一下单接口返回的成功结果对象中有 payment 字段，该字段即是小程序端发起支付的接口（wx.requestPayment）所需的所有信息 小程序端拿到后端结果，调用 wx. requestPayment 发起支付 支付完成后，在统一下单接口中配置的云托管服务将收到支付结果通知，具体详见结果回调开发中遇到的问题热启动和冷启动的问题。 "},{"title":"restfulAPI设计规范","date":"2019-07-10T07:20:18.000Z","url":"/2019/07/10/cxy/other/restfulApi/","tags":[["api","/tags/api/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 1.协议遵守https协议2.api应该有单独域名3.加上版本号4.由于restfulapi中url表示一种资源的集合，而不再是一个功能一个url，所以网址中不能有动词，应该全是名词，且与数据库的表名一一对应，也由于是一种集合，所以api的名词尽量为复数5.用http动词去表示资源的具体操作类型，如put/patch/post/get/delete/增删改查等6.如果涉及分页这种返回结果相当多的情况，api也可以提供一些参数，如?limit=10&amp;page=27.有单独的状态码"},{"title":"【基础】foreachforofforin","date":"2019-07-07T09:51:16.000Z","url":"/2019/07/07/cxy/cxddeziwoxiuyang1/foreachforofforin/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"for in、for of 、forEach 区别 for of 常用于异步遍历，for in、forEach、 for 多用于 同步遍历。 一、 基本用法1. 遍历数组：for of 遍历数组 for in 遍历数组 forEach 遍历数组 2. 遍历对象： for in 遍历对象，不能遍历map、set，不报错，但由于没有key会返回undefined for of、forEach 不能遍历对象 for of 只能遍历有iterable（遍历器）接口的变量，object没有遍历器接口。 原生具备 Iterator 接口的数据结构如下。Array、Map、Set、String、TypedArray 函数的 arguments 对象、NodeList 对象 forEach也不能遍历对象，但可以用Object.keys() Object.values() Object.entries(obj)去遍历对象 插一句：set和map也有对应的values keys entries方法，返回的是各自类型的键组合、值组合、键值对类型组合，可以用for of 沙发垫 二、 forEach 和 for of 区别1. 遍历对象方面for of 可以遍历的：实现了迭代器接口，即具有[Symbol.iterator]方法，它们可以被for...of用于遍历。 forEach可以遍历的：数组和类数组对象，即：拥有length属性（这是我自己认为的，不一定对，反正暂时没出错）。 forEach不能遍历而for of可以遍历的forEach可以做的for of基本都可以做，但有些有iterator接口的变量，只能用for of来做。 如生成器函数（generator）、字符串的Symbol迭代器、自定义的迭代器对象等 (1). 生成器函数（Generator Functions）： (2). 字符h 串的Symbol迭代器： (3). 自定义迭代器对象 2. for of 的异步遍历如果使用foreach遍历处理异步代码不会等待异步代码的执行，一次输出所有异步结果使用forEach打印一次性打印出了1、4、9 如果使用for of可以使异步按先后顺序执行使用for of打印就可以实现每隔一秒进行打印1、4、9 3. for of 异步遍历的例子关于异步处理方面的区别，在使用for...of遍历可迭代对象时，可以使用await关键字来等待异步操作的完成。 而forEach方法本身是同步的，无法直接使用await等待异步操作。 以下是一个使用for...of进行异步处理的例子，其中包含了await关键字： 在上述例子中，processArray函数使用for...of遍历数组，并通过await等待异步操作的完成。每个元素的处理会等待一秒钟，然后才会处理下一个元素。 相比之下，forEach方法无法直接实现类似的异步处理，因为它本身是同步的，无法等待异步操作的完成。"},{"title":"npm相关","date":"2019-06-03T03:11:11.000Z","url":"/2019/06/03/cxy/other/node-n/","tags":[["node","/tags/node/"],["npm","/tags/npm/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" -S和-D的区别npm i –save-dev xxx同npm i -D xxx安装到开发环境在package.json中： npm i –save xxx同npm i -S xxx安装到正式环境在package.json中： package-lock.json的作用比如你的packgae.json的依赖是”react”: “^17.0.2”，因为有标识符^，所以如果react模块有在17大版本下更新的小版本17.0.3，npm install时候会自动安装17下的最新版本17.0.3现象：在前景情况下，你本地是”react”: “^17.0.2”，如果这时候react更新”react”: “^17.0.3”，别人npm install的时候，安装就是”react”: “^17.0.3”。这样导致你们版本不一致，可能引起一些相关错误。解决：package-lock.json：简单来说就是锁定安装模块的版本号。就是在npm install的时候，记录各个模块的版本信息和下载路径，这样别人拉项目npm install时候， 就会依据packgae-lock.json去安装”react”: “^17.0.2”，保证大家依赖一致并且安装模块速度也能提高。"},{"title":"【nodejs】Nodejsejs基础总结之事件（一）事件循环","date":"2019-06-01T03:02:45.000Z","url":"/2019/06/01/node-event/","tags":[["node","/tags/node/"],["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、nodejs 事件循环1. 基本概念Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数。 1.1 宏任务与微任务及其优先级宏任务中：1. timers：定时器，setTimeout setInterval 2. I/O callback：文件读写、网络读写、流的读写、控制台读写等出现的错误或后续操作。 3. Idle,prepare：闲置状态。 “Idle” 阶段通常用于执行一些与性能无关的、非紧急的任务，以充分利用系统的空闲时间比如：垃圾回收、日志记录等。 “Prepare” 用于在系统进入空闲状态时进行一些准备操作，以便在下一次事件循环迭代中更快地响应事件，比如资源准备、数据预取、状态检查、数据库连接等。 大多数情况下，开发者不太需要直接操作这两个阶段。 4. Poll 阶段：执行poll中的I/O队列。 具体来说，”poll” 阶段的工作流程如下： 进入 “poll” 阶段：当事件循环进入 “poll” 阶段时，它会检查事件队列中是否有待处理的事件。 等待 I/O 事件：在 poll 阶段，Node.js 会等待并监听来自操作系统的事件，这些事件包括文件可读、可写、网络套接字的可读、可写等等。这些事件可能已经被触发，但需要在 poll 阶段中等待。 处理 I/O 事件：poll 阶段的主要任务是处理这些 I/O 事件。当某个事件发生时，Node.js 将会执行相应的回调函数。这些回调函数通常是由之前注册的事件监听器定义的。 等待其他任务：如果在 poll 阶段没有 I/O 事件需要处理，事件循环会进入非阻塞的等待状态，等待其他事件的发生或者其他任务的执行。这样可以充分利用系统的资源，不会空闲浪费。 检查定时器：在等待事件的同时，事件循环还会检查是否有已到期的定时器任务，如果有，会进入 timers 阶段执行相应的回调函数。 5. check 阶段： 存储setImmediate回调。 需要注意的点如下： “check” 阶段的执行顺序：当 “poll” 阶段完成后，事件循环会检查 “check” 阶段是否有待处理的回调函数。如果有，它会依次执行这些回调函数。 setImmediate 和 process.nextTick：通常，通过 setImmediate 注册的回调函数会在 “check” 阶段执行。而使用process.nextTick 的回调函数优先级比 setImmediate 高。 事件处理：某些事件（如网络套接字的数据可用事件）也可以在 “check” 阶段处理，但通常是在其他阶段触发的，然后在 “check” 阶段执行与之相关的回调函数（如socket.on(&#39;data&#39;)）。 6. close callback 阶段：关闭回调 工作流程如下： 资源清理：”close callbacks” 阶段用于执行与资源清理相关的回调函数。例如，在关闭一个网络连接时，可以在 “close callbacks” 阶段执行回调函数，用于释放相关的资源和资源的最后清理。 异步关闭操作：某些资源的关闭可能是异步的，例如在关闭网络套接字时可能需要等待未完成的数据传输完成。因此，相关的关闭回调函数会在异步操作完成后执行。 socket.on(&#39;close&#39;) 事件：网络套接字的 close 事件通常与 “close callbacks” 阶段相关联。当网络套接字关闭时，可以注册一个回调函数，以便在 “close callbacks” 阶段执行清理操作。 文件描述符的关闭：类似地，文件操作中，文件描述符的关闭也可能与 “close callbacks” 阶段相关。当文件被关闭时，可以执行清理回调函数。 微任务中： 包括promise、async/await、process.nextTick process.nextTick的优先级最高，如果没必要的话，可以使用setImmediate取代process.nextTick 微任务的执行时机比宏任务高 总结 nodejs 的 eventloop 执行同步代码 执行微任务 按顺序执行宏任务 在每个宏任务结束时，都会执行当前所有的微任务。 网上看到一个有意思的练习题还是那句话噢new promise本身是同步的，只是then之后的才是异步。 执行结果： 要记住： 宏任务按顺序排队列，每次执行宏任务之前，都会查找一次当前是否有微任务等待执行。 微任务最优先的永远是process.nextTick，在当前事件循环中，如果有其他微任务在排队，遇到process.nextTick都要向后排。 "},{"title":"【nodejs】Nodemon的使用","date":"2019-06-01T03:02:45.000Z","url":"/2019/06/01/node-mon/","tags":[["node","/tags/node/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"什么是 Nodemon？Nodemon 是一个用于监视 Node.js 应用程序文件的工具，并在文件发生更改时自动重新启动应用程序，以加速开发过程。它是一个非常方便的开发工具，可以帮助你在代码编辑过程中快速查看修改的效果，无需手动停止和重新启动应用程序。 安装 Nodemon你可以使用 npm 或 yarn 来全局安装 Nodemon： 使用 Nodemon一旦安装了 Nodemon，你可以通过在终端中运行以下命令来启动你的 Node.js 应用程序： 在这个命令中，your-app.js 是你的 Node.js 应用程序的入口文件。Nodemon 将会监视这个文件以及其所依赖的文件。 高级用法自定义配置你可以创建一个 nodemon.json 文件来配置 Nodemon 的行为。在这个文件中，你可以指定需要监视的文件、忽略的文件、以及其他配置选项。以下是一个示例 nodemon.json 文件： 在这个示例中，Nodemon 将监视 src 和 config 目录中的文件，只有当 .js 和 .json 文件发生更改时才会重新启动应用程序，同时忽略 src/static 目录。 使用命令除了直接在命令行中运行 Nodemon，你还可以将 Nodemon 集成到 package.json 中的 scripts 中，以便使用自定义的启动命令。例如： 然后，你可以通过运行 npm start 来启动应用程序，这将使用 Nodemon 自动监视文件。 更多选项Nodemon 支持许多其他选项，可以根据需要进行配置，例如设置端口、调试选项等。你可以在官方文档中查找完整的选项列表和示例：Nodemon 官方文档"},{"title":"【第9-3章】HTTP请求头和响应头中的no-cache和no-store的区别","date":"2019-05-17T02:30:35.000Z","url":"/2019/05/17/cxy/cxddeziwoxiuyang1/js/js-http-cache-control/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" HTTP（Hypertext Transfer Protocol）是一种用于在客户端和服务器之间传输数据的协议。 在HTTP请求头和响应头中，有两个重要的指令：no-cache和no-store。 这两个指令用于控制强制缓存的行为，但它们有不同的作用和效果。 no-cacheno-cache是一个HTTP头部指令，通常出现在请求头中，但有时也可以在响应头中找到。它告诉缓存服务器不要直接使用缓存的副本来响应客户端的请求，而是需要先将请求发送到源服务器，然后根据源服务器的响应来确定是否需要更新缓存。 no-cache的主要目的是确保客户端始终获取最新的数据，但它仍然允许缓存服务器在源服务器确认数据未更改时提供响应，从而减轻源服务器的负担。 重点： 根据HTTP规范，no-cache 指令的确切含义是 “在使用之前必须重新验证“，而不是 “不要缓存“。 这意味着浏览器可以在本地缓存响应数据，但在使用之前必须先发送条件性请求到服务器，以验证数据是否仍然有效。 no-cache也不是禁止浏览器不能缓存，而是使用浏览器缓存之前，必须要先到服务器进行验证。当响应头也使用no-cache时，服务器缓存的数据和客户端一样，需要遵循验证规则。 详细请看：RFC 7234，我反正是这么理解的。 示例请求头： 比如说当我像上面这么写cache-control的话，就会产生本地有缓存，且为3600秒的情况。当我在这3600秒中再次需要数据，我虽然本地有缓存，却需要去源服务器进行校验。 如果我仅仅写了max-age，那么这3600秒之内是不会去校验的，直接使用本地缓存做显示了。 no-store与no-cache不同，no-store是一个更为严格的指令，通常只出现在响应头中。它告诉缓存服务器不要在任何情况下存储请求的响应数据。这意味着缓存服务器不会将响应存储在缓存中，也不会返回存储在缓存中的响应数据。 no-store的目的是确保响应数据不会被存储在任何地方，包括客户端的本地缓存、中间代理服务器或其他地方。这对于敏感数据（如银行信息或个人身份信息）非常重要，以防止数据泄露。 示例响应头： 总结 no-cache要求缓存服务器验证缓存中的数据的有效性，并在需要时从源服务器获取新数据，以确保客户端获取最新数据。 no-store则要求缓存服务器不存储任何响应数据，以确保数据不会被意外泄露。 在选择使用这两个指令时，应根据应用程序的需求和数据的敏感性来确定哪一个更合适。通常情况下，no-cache是一个较为常见的选项，因为它可以在减轻服务器负担的同时仍然提供较新的数据。但对于非常敏感的数据，使用no-store可能更为安全。 补充no-cache的一些其他参数"},{"title":"【面试相关】this的补充","date":"2019-05-10T22:55:39.000Z","url":"/2019/05/11/js-this2/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、作用域与thisES5只有全局作用域和函数作用域，没有块级作用域作用域分为静态/词法作用域和动态作用域 0.声明提升和暂时性死区(1).声明提升(var)console.log(a); // undefinedvar a = 1;(2).暂时性死区(let)console.log(a) // Uncaught ReferenceError: a is not definedlet a = 1;注意：在es5 strict mode，赋值给未声明的变量将报错。 1.静态作用域静态作用域指的是一段代码，在它执行之前就已经确定了它的作用域，简单来说就是在执行之前就确定了它可以应用哪些地方的作用域(变量)首先let和const声明的全局变量不再属于window变量的作用域，除了this以外，全部遵循词法作用域的原则即JS引擎总会从最近的一个域，向外层域查找； 2.动态作用域动态作用域–函数的作用域是在函数调用的时候才决定的在 JavaScript 中的仅存的应用动态作用域的地方：this 引用动态作用域，作用域是基于调用栈的，而不是代码中的作用域嵌套；作用域嵌套，有词法作用域一样的特性，查找变量时，总是寻找最近的作用域； 3.声明函数的方法1.函数声明 2.函数表达式 3.Function构造函数语法： new Function(参数1, 参数2, 参数3, 方法体) 4.变量进入作用域的方法 Language-defined：所有的作用域默认都会给出 this 和 arguments 两个变量名（global没有arguments Function declarations（函数声明）：如 function foo() {} Formal parameters（函数形参）：函数有形参，形参会添加到函数的作用域中; Variable declarations（变量声明）：如 var foo，包括_函数表达式_其实1324是文章写的，但我验证发现实际上是1234。除了上下文顺序声明之外，若声明提升符合函数声明和变量声明总是会被移动（即host）到它们所在的作用域的顶部。而变量的解析顺序（优先级），与变量进入作用域的4种方式的顺序一致。关于上下文：￼5.this 每个作用域都会有this在全局上下文（任何函数以外），this指向全局对象。 对象中的this指向该对象 在函数内部时，this由函数怎么调用来确定。 简单调用，即独立函数调用。由于this没有通过call来指定，且this必须指向对象，那么默认就指向全局对象。 严格模式下，this保持进入execution context时被设置的值。如果没有设置，那么默认是undefined。它可以被设置为任意值（包括null/undefined/1等等基础值，不会被转换成对象）。 在箭头函数中，this由词法/静态作用域设置（set lexically）。它被设置为包含它的execution context的this，并且不再被调用方式影响（call/apply/bind）。 当函数作为对象方法调用时，this指向该对象。 原型链上的方法根对象方法一样，作为对象方法调用时this指向该对象。在构造函数（函数用new调用）中，this指向要被constructed的新对象。Function.prototype上的call和apply可以指定函数运行时的this。注意，当用call和apply而传进去作为this的不是对象时，将会调用内置的ToObject操作转换成对象。所以4将会装换成new Number(4)，而null/undefined由于无法转换成对象，全局对象将作为this。 ES5引进了Function.prototype.bind。f.bind(someObject)会创建新的函数（函数体和作用域与原函数一致），但this被永久绑定到someObject，不论你怎么调用。它说创建新函数，可不是覆盖原函数，！！！！ this自动设置为触发事件的dom元素 6.JavaScript采用Lexical Scope。（静态范围作用于）于是，我们仅仅通过查看代码（因为JavaScript采用Lexical Scope），就可以确定各个变量到底指代哪个值。 另外，变量的查找是从里往外的，直到最顶层（全局作用域），并且一旦找到，即停止向上查找。所以内层的变量可以shadow外层的同名变量。 7. Function vs. Block Scope上面的内容有意无意似乎应该表明了，JS没有Block Scope。除了Global Scope，只有function可以创建新作用域（Function Scope）。 不过这已经是老黄历了，ES6引入了Block Scope。 另外，with和try catch都可以创建Block Scope。 TODO:作用域和this这就差不多了，晚上找些面试题试试水下补：上下文和作用域"},{"title":"【第10章】运行环境","date":"2019-04-16T06:06:12.000Z","url":"/2019/04/16/cxy/cxddeziwoxiuyang1/js/js-enviro/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、从输入url到渲染出页面的整个过程 dns解析： 域名—&gt;IP 浏览器根据IP地址向服务器发起http请求 服务器处理http请求，并返回给浏览器 根据HTML生成Domtree，根据Css生成cssom，再整合dom树和cssom整合的rendertree 根据render tree渲染页面 遇到script标签则暂停渲染，优先加载并执行js代码，完成再继续，直至渲染完成。二、window.onload 和DOMContentLoaded的区别 三、性能优化的方案比如防抖、节流、懒加载，可以把面试官往这个方向引入1. 原则（1）.多使用内存、缓存或其他方法（2）减少CPU计算量，减少网络耗时（空间换时间）2. 方法（1）让加载更快：压缩代码（webpack mode production）服务端可以做打包（2）减少访问次数：合并代码（利用webpack、雪碧图）、ssr服务器端渲染，缓存（3）使用更快的网络： cdn ，cdn 内容分发网络，根据区域去访问不同地点的服务器。。。这样就会更快些（4）让渲染更快： css放在head js放在最下面 尽早开始执行js，用DOMContentLoaded触发事件 懒加载，图片上滑加载更多，如下7 对dom查询进行缓存，如下8 避免频繁DOM操作，合并到一起插入DOM结构 节流、防抖（体验性优化） 下面几条是对上面四条的补充（5）缓存：5.1静态资源加hash后缀，根据文件内容计算hash 5.2文件内容不变，则hash不变，则url不变 5.3 url和文件不变，则会自动触发http缓存机制，返回304（6）ssr：服务器端渲染：将网页和数据一起加载，一起渲染 | 非ssr（前后端分离）：先加载网页，在加载数据，再渲染数据（7）懒加载 （8）缓存dom查询 4.防抖debouce在频繁输入时，监听输入事件会频繁触发，像google搜索时，如果每一次输入都触发请求，请求量会很大，影响性能了。所以设置一个在输入停止一小段时长后，再触发请求。会大量的减少请求量。 5.节流 封装这里用到了闭包，之前在作用域和闭包中说过：闭包是由函数以及声明该函数的词法环境组合而成的闭包的变量不会得到释放闭包会随着函数的创建而被同时创建所以下面的timer向外层查找到的是形成的闭包的词法环境中的timer 6.xss（1）. 问题：常见的web前端攻击方式有哪些？比如我写了一篇博客，博客里面有script标签，该代码执行获取用户cookie的操作，任何用户访问该博客后，就会执行该代码。被获取到cookie之后，将cookie发送到我的服务器，这样就会拿到用户的敏感信息（2）. xss预防：// 替换特殊字符（&lt; –&gt; &lt; &gt; –&gt; &gt;）前端后端都要替换。 7.xsrf（1）概念：用?带参数去访问服务器，得到服务器数据（2）预防方法： 使用post接口、增加验证：例如密码、短信验证码、指纹"},{"title":"【第9-2章】http协议","date":"2019-04-14T04:23:21.000Z","url":"/2019/04/14/cxy/cxddeziwoxiuyang1/js/js-http22/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 懒得重写了，直接从笔记截图过来。"},{"title":"【第9-1章】http缓存策略","date":"2019-04-14T04:23:21.000Z","url":"/2019/04/14/cxy/cxddeziwoxiuyang1/js/js-http11/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 懒得重写了，直接从笔记截图过来。"},{"title":"【第9章】http与restfulAPI","date":"2019-04-12T07:33:35.000Z","url":"/2019/04/12/cxy/cxddeziwoxiuyang1/js/js-http/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" const { get } = require(“http”); 状态码类型 1xx 服务器收到了请求 2xx请求成功 如200 3xx重定向 如302 4xx客户端错误 5xx服务端错误，如500 常见状态码：200 请求成功301 永久重定向（配合location，浏览器记住了该网址返回了301，然后浏览器之后会永久自动处理到新的网站，如域名到期换新域名的情况）302 临时重定向（配合location，浏览器记住了该网址返回了302，但下次访问浏览器还是会访问到旧地址，如百度首页搜索的二级跳转、短网址等）点击链接：为什么百度需要二级跳转重定向？简单说，是为了打点。点击链接：短网址的作用 简单说，微博字数那么长，再来个那么长的网址真心hold不住。304 资源未被修改（缓存了）请求过来的数据没有改变404 资源未找到401 用户未授权 比如密码错误、用户名错误403 用户得到授权，但访问时禁止的500 服务器错误504 网关超时 (服务器端的操作有超时) 新method可以写的状态码/* 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - []：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - []：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - []：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。*/// “幂等性”指的是 1 次或 N 次的副作用(对系统造成的影响)相同，而不是返回结果相同，因此 GET 请求总是幂等的。// 无论一个操作被执行一次还是多次，执行后的效果都相同。比如对某资源发送GET请求，如果访问一次和访问十次获得的数据一样，那么就说这个请求具有幂等性。 http methods1. 传统methodsget获取服务器数据post向服务器提交数据 2. 现在的methods点击链接：restful api 的设计方法（1）get获取服务器数据 ()（2）head 和get类似，但服务器在响应中只返回头部，不返回实体的主体部分，这就允许客户端在没获取资源时对资源首部进行检查（3）post新建数据 (新建blog)（4）patch/put更新数据 （更新blog）patch:局部更新资源，比如只更新某一字段 put：完整更新资源，对带宽会有影响 （5） delete删除数据 （删除blog）（6）options 获取信息，关于资源的哪些属性是客户端可以修改的的。 restfulApirestfulApi 是一种新的api设计方法。 1. 概念：RESTful API 就是REST风格的API。现在终端平台多样，移动、平板、PC等许多媒介向服务端发送请求后，如果不适用RESTful API，需要为每个平台的数据请求定义相应的返回格式，以适应前端显示。但是RESTful API 要求前端以一种预定义的语法格式发送请求，那么服务端就只需要定义一个统一的响应接口，不必像之前那样解析各色各式的请求。 2. restfulapi的设计（1）传统API 把每个url当做一个功能（2）restful api 把每个url当做一个唯一的资源(^o^)/~就比如获取博客和更新博客 /api/blog/create 创建博客 /api/blog/update?blog=100 更新博客 这是一种功能// 而新的restfulapi，获取博客、更新博客、创建博客，都可以用/api/blog去表示，唯一不同的是method，这是一种资源集合（3）在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 附：URI：Uniform Resource Identifier，统一资源标识符URL：Uniform Resource Location统一资源定位符 URL是URI的子集。点击链接：URI 和 URL 3. 如何把每个url设计成一个资源？（1）不使用url参数 ，即问号后面的部分，然后做一个url的唯一标识传统： /api/list?pageIndex=2restful api: /api/list/2 （2）使用method表示操作类型传统： restful api： 下面以动物园为例子： http headers1. 常见的request headers（客户端像服务端发送的）Accept: image/avif,image/webp,image/apng,text/html浏览器可接受的数据格式 Accept-Encoding: gzip, deflate, br浏览器可接受的压缩算法 Accept-Language: zh-CN,zh;q=0.9浏览器可接受的语言 Connection: keep-alive连接方式keep-alive：一次tcp连接可以重复使用 Cookie: BIDUPSID=8B5F551B8E92D363D2BF09A17F1787F0; BAIDUID=5ccc19b28fd87ed0af236b203e83021a什么是cookie：Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 [1] 。 Host: m.baidu.com域名 Content-type: application/json text-plain客户端像服务端请求时，告诉服务端我发送数据的格式，一般只有post请求有，get是获取数据一般没有 User-Agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.193 Mobile Safari/537.36浏览器信息 Cache-Control 2. 常见的response headers（服务端像客户端返回的）连接方式 Connection: keep-alive返回数据的大小 Content-Length: 0返回的数据的格式 Content-Type: text/plain; charset=utf-8返回的数据的压缩算法 Content-Encoding服务端改cookie的时候，需要发送 Set-Cookie: __bsi=10004501327375333328_00_32_N_R_10_0303_c02f_Y; max-age=3600; domain=m.baidu.com; path=/ 3. 缓存相关的headerscache-control （响应头，缓存时间）expires (响应头中，已被cache-control代替，有这个属性和cache-control一起兼容写法的情况)last-modified（响应头，资源的最后修改时间） if-modified-since （请求头，协商缓存时浏览器再次请求会带着这个值，这个值和响应头的laast-modified相同）etag （资源的唯一标识）if-none-match (请求头，值和响应头的etag相同，协商缓存中的唯一标识) header也可以自定义,axios插件就可以自定义header除了以上之外，可以自定义header，如果在客户端自定义在request中加，如果在服务端中自定义要后端在response中加常用场景：如服务端需要前端加上一个验证header做非法请求的验证 总结一下restful api的设计模式1.协议遵守https协议2.api应该有单独域名3.加上版本号4.由于restfulapi中url表示一种资源的集合，而不再是一个功能一个url，所以网址中不能有动词，应该全是名词，且与数据库的表名一一对应，也由于是一种集合，所以api的名词尽量为复数5.用http动词去表示资源的具体操作类型，如putpatchpostgetdelete增删改查等6.如果涉及分页这种返回结果相当多的情况，api也可以提供一些参数，如?limit=10&amp;page=27.有单独的状态码8.4xx错误时要返回出错信息，用统一的error作为键值9.返回结果应符合规范 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档10.Hypermedia API 返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 http缓存(见有道云)1. 什么是缓存？网页第二次访问时，有相同资源可以不用重新请求一遍。 2. 为什么需要缓存为了让页面加载更快，网络请求加载相比cpu计算等等会比较慢，所以要尽量减少网络请求的数量和体积，可以让加载更快一些 3. 哪些资源可以被缓存 —— 静态资源（js css img）html一般是不被缓存的，网页的业务数据（比如留言板列表、博客列表）一般也不能被缓存，因为有可能随时会更新。 2. http缓存策略(见有道云)（1）强制缓存 cache-control比如请求一个js资源浏览器初次请求服务器，服务器返回资源和cache-control，若服务端感觉这个资源可以被缓存，则加入cache-control（在response-headers中，因为在响应头中，所以客户端无法控制，服务端控制）如：cache-control：max-age=5184000 单位为秒浏览器再次请求时，之前服务端的cache-control本地缓存会缓存下js的内容，如果cache-control没过期，浏览器就请求本地缓存，不通过网络，由本地缓存返回资源。 （2）协商缓存服务端去判断客户端资源是否和服务端一致，一致则返回304（服务端判断客户端资源未改动），否则返回200和最新的资源。浏览器初次请求，服务端返回资源和资源标识给浏览器。浏览器再次请求会带上资源标识，服务端判断该资源标识的资源是否和服务端最新资源一致，则返回304，否则返回新资源和新资源标识。资源标识：在response-header中（因为是服务端返回的呗）last-Modified 资源的最后修改时间Etag资源的唯一标识（一个字符串，类似人类指纹） （3）刷新方式对缓存的影响https协议(见有道云)一、 http面试题 http常见状态码 http常见header 什么是restful 描述一下http缓存机制 "},{"title":"【第8章】localStorage、sessionStorage、cookie","date":"2019-04-12T07:33:35.000Z","url":"/2019/04/12/cxy/cxddeziwoxiuyang1/js/js-storage/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 内容：localStorage sessionStorage cookie 一、cookie1. 什么是cookie？cookie用来server端和浏览器端通信，并不是用来做本地存储，只是因为原先html5不普及所以借用来本地存储 2. 前端修改cookie的方式：document.cookie后端也可以修改cookie。 3. cookie的缺点：（1）存储大小最大只有4k（2）每次发送http请求，cookie都会被发送到服务端，会增加请求的数据量（3）只能用document.cookie来修改，很麻烦。 二、.localStorage和sessionStorage1. 优点：（1）localStorage和sessionStorage是html5专门为存储设计，最大存储5m（2）api简单易用（3）不会随着http请求被发送。 localStorage和sessionStorage可以在控制台application查看 2. api:getItem(key)setItem(key,value) 3. localStorage和sessionStorage、cookie区别(1) localStorage会永久存储，sessionStorage只存在于当前会话，如果浏览器关闭，该网站的sessionStorage会立即清除。 (2) cookie每次都会随着浏览器请求发送到服务端，localStorage和sessionStorage只存在于本地 (3) localStorage和sessionStorage的api简单，cookie只能通过document.cookie设置。"},{"title":"【第7章】ajax","date":"2019-04-11T04:13:35.000Z","url":"/2019/04/11/cxy/cxddeziwoxiuyang1/js/js-ajax/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、手写一个ajax promise ajax的写法 二、跨域1. 同源协议、域名、端口必须一致，叫做同源同源策略：ajax请求时，浏览器要求当前网页和服务器端必须同源 2. img、link、script 可以无视同源策略，即可以跨域由于img可以无视同源策略，所以可以用于使用第三方统计服务，如打点link script 可使用cdn，cdn一般是外域服script可以实现jsonp 3. 如何用jsonp实现跨域？上面说了script可以实现jsonp。现在假设我需要在下访问的文件，由于端口不一致所以跨域了。（1）首先，需要服务器进行配合。因为服务器可以拼接任意字段返回给服务器，所以让服务器将数据包装为js函数返回。 假设服务器给前端的数据为，该文件的内容让后端包装为callback方法，参数为真实要传递的数据，如： （2）然后，前端使用script标签引入该index文件 这样，在页面中就引入了一个名为callback的函数，因为是script全局引入，所以该方法位于window下。（3）再使用另一个script标签，处理数据： 4. cors实现跨域CORS 是纯服务器端操作，服务器端可以设置header根据下面方法设置响应头字段服务器端可以直接设置header，去允许某个地址的跨域访问。 5. 常用的ajax插件fetch() axios "},{"title":"【第6章】事件捕获与冒泡相关","date":"2019-04-10T04:13:35.000Z","url":"/2019/04/10/cxy/cxddeziwoxiuyang1/js/js-event/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 描述事件冒泡的流程事件冒泡基于树形dom结构，事件可以一级一级的向上冒泡，若有多个事件，先响应内层，再响应外层。若一个事件在最外层绑定的，在最内层上依旧能监听到。 事件冒泡和事件捕获事件冒泡：事件可以一级一级的向上冒泡，若有多个事件，先响应内层，再响应外层。 事件捕获：从外向内触发事件，很少用于开发。xxx.addEventListener(‘xxx’,function(){},true) 第三个参数为true时，则触发事件捕获。 事件代理像瀑布流，无限加载图片，由于元素太多不好每一个元素都绑定事件，所以就将事件绑定在这些图片的父元素上，通过事件冒泡去相应事件好处是代码简洁，减少浏览器占用，但不要滥用。 面试题编写一个通用的事件监听函数为了解决事件代理（如瀑布流需要每个图片都有一个点击事件）将瀑布流事件绑定在父元素上，当点击父元素时，可以激发子元素的事件 "},{"title":"【第4-3章】async await","date":"2019-04-06T09:01:05.000Z","url":"/2019/04/06/cxy/cxddeziwoxiuyang1/js/js-await/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、generator的基本用法 1. for…of循环可以自动遍历generator函数运行时生成的iterator对象，且此时不需要调用next()方法。 3. g.throw(err) 在generator函数内部排除一个错误4. g.return() 可以返回特定的值，并且终结generator函数。5. yield* gen() 若是在generator函数内部需要调用其他generator函数，需要手动遍历，或直接使用yield*表达式。6. 如果一个对象的属性是generator函数，则可以简写，generator的返回值是iterator遍历器 二、async、await· async 可以用同步的方式写异步的代码，async返回的是promise对象，如果返回了普通变量则会被包装成promise· await后面一般追加异步操作，相当于promise.then()，如promise对象、其他async函数 1. async/await和Promise的关系，为什么要使用async async/await是消灭异步回调的方法，有了async/await，就可以使用同步的写法去写异步的程序，不需要再用回调函数，写起来也比promise简便。相当于promise.then promise.catch，但二者并不冲突promise捕获错误只能用promise.catch的方法，没办法用try…catch，但async/await可以，写法上会规范许多 2. async返回一个promise，可以用.then方法，await相当于promise.then(重点！)，但用法又有所不同async函数内部return语句返回的值，会成为then方法回调函数的参数。async自动执行、async函数返回一个 Promise 对象，可以使用then方法添加回调函数。await 后面跟promise对象或一个一个async 函数，相当于promise.then()async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 3. 正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。async函数return的则是一个promise对象 4. await后面可以跟promise或async函数，如果跟的是一个普通函数，那加不加await都是一样的 ###5. async内的catch相当于promise.catch() 若await后面的promise状态为reject，则之后代码均不执行 5.异步的本质：遵循event-loopasync/await只是语法糖，从语法层面将代码变为同步的写法，但实质是异步的，依旧基于event-loop去执行await 后面的内容全部都理解为放在回调函数中，所以他们都是异步操作，所以要放在同步操作的后面去执行（event-loop原理） 6.await后面加不加promise，很很很重要不加promise相当于一个同步函数，后面的代码也是同步代码了。 ```javascriptfunction timeout(ms) { return setTimeout(()=&gt;{}, ms); } async function asyncPrint(value, ms) { await timeout(ms); console.log(value); } asyncPrint(‘hello world’, 5000); console.log(1)// 立刻打1 hello world"},{"title":"【第4章】同步和异步","date":"2019-04-06T05:20:03.000Z","url":"/2019/04/06/cxy/cxddeziwoxiuyang1/js/js-progre/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 单线程和异步js是单线程语言，只能同时做一件事情，两段js不能同时执行，.原因就是避免DOM渲染的冲突（都修改DOM就冲突了）浏览器和nodejs已经支持js启动进程 如 web serverjs和dom渲染共用一个县城，所以可以操作dom##异步为了解决什么问题？因为js是单线程，异步为了解决遇到等待时，等待过程中不可能像alert一样阻塞程序进行，因此所有的“等待情况”都需要异步。 异步应用场景：定时任务：setTimeout、setInterval、网络请求：Ajax请求、动态加载、事件绑定：图片加载如onload，不用等待onload完毕再去执行onload后面的代码 回调地狱callback hell回调函数： 将一个函数作为参数传递给另个函数回调地狱用promise来解决 再如请求太多的时候，回调函数套回调函数 如果用promise去写，就会简洁很多。 常见的面试题：图片加载 单线程是什么前端使用异步的场景有哪些"},{"title":"【第4-2章】promise","date":"2019-04-05T08:22:15.000Z","url":"/2019/04/05/cxy/cxddeziwoxiuyang1/js/js-promise/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、promise的三种状态fuifilling reject pending，在没有获取到reject或者fulfilling时一直都是pending，直到有reject或resolve返回promise变为fufilling或reject之后，状态不可逆。pending状态，不会触发then和catch，resolved会触发then，reject会触发catch 二、then(res,rej)方法then(res,rej)方法的两个参数，第一个是resolve方法，第二个是reject方法，reject方法可以在后面用catch的方法调用then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 直接获取resolve状态或reject状态的方法： 三、then和catch的状态改变 then正常返回resolve，内部有报错（或throw err）则返回rejected。 catch正常返回resolved，内部有报错则返回rejected。 resolve触发then回调，rejected后续触发catch回调，注意resolve是不会触发catch回调的。 promise.resolve()和promise.reject()只要内部没报错，后续还是触发then回调。 最后的状态靠最后返回的结果为定 第五点我要单独说一下：最后的状态靠最后返回的结果为定在下面的代码中，promiseA本身是反悔了resolve，但由于它引入了另一个promiseB，而promiseB返回reject，所以最终执行结果会到catch方法中。 四. resolve和fufilledpromiseA如果resolved到了另一个promiseB中，那它不一定是pendding fulfilled reject,它的状态由promiseB执行完毕才决定。上面有代码示例。 (1) nothing happened yet(2) “locked in”to another promise(3) fulfilled(4) rejeted(1)(2) pedding (3)(4)settled (2)(3)(4)resolved (1)unresolved ##五. Promise.resolve() 和 Promise.reject() 如果Promise.resolve()有参数:（1）. 参数为promise，原封不动的返回该promise （2）参数为有then方法的对象，会立即执行then方法，并将执行结果封装为promise对象 （3）参数没有then方法，或根本就不是对象，则将值包装为promise对象并返回到then中，状态为resolved 六、promise定义时立即执行，而then相当于异步，所以执行完promise内的内容跳出去执行同步代码，再执行then 面试题：以下代码的执行结果？ "},{"title":"【第3-2章】作用域和闭包","date":"2019-04-05T04:00:00.000Z","url":"/2019/04/05/cxy/cxddeziwoxiuyang1/js/js-context/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、作用域和自由变量作用域:作用域就是一个变量的合法使用范围。作用域分为全局作用域、函数作用域及块级作用域（es6新增）。 函数作用域 块级作用域（es6新增） 自由变量：一个变量在当前作用域没有定义，（注意是当前作用域，哪怕上级作用域定义了只要当前作用域没定义就不行）但被使用了，沿上级作用域一级一级找，若到全局作用域还没有找到，就报错。 二、闭包·闭包就是作用域应用的一个特殊情况，闭包让开发者可以从内部函数访问外部函数的作用域，有两种情况：（1）函数作为参数被传递（2）函数作为返回值·自由变量的查找是在函数定义的地方！（重点，函数定义的地方是指函数体在哪里），向上级作用域查找注意：闭包中的变量会常驻在内存，得不到释放，因为判断不了闭包内的变量未来是否会用到闭包是由函数以及声明该函数的词法环境组合而成的。 （1）函数作为参数被传递 （2）函数作为返回值 （3）自执行函数 function 里可没传参数，看好了是data后面有参数，其实就算传了也没什么影响，因为i的值已经在调用时决定是3了，虽然函数定义时决定了变量所在的作用域，但调用时才能决定变量在该作用域实际的值。 重要！！！变量在定义时就确定了上级作用域，但需要在调用时才能确定变量定义时所在的上级作用域或当前作用域该变量的值，比如这里i在调用时的值为3，即使外部定义了i = 10，最终查找还是在定义时的当前作用域查找i，当前作用域的i为3，所以输出全为3 改进方法：形成自己的封闭的块级作用域。改进方法1：for内的var变为let，因为let具有块级作用域，它形成了三个私有作用域相互不会干扰。 改进方法2：自执行函数和闭包匿名函数定义也是在匿名函数声明的地方，这里即return后，有名字的函数定义就在有名字的函数那里，然后一层一层向上查找 自由变量的查找是在函数定义的地方，向上级作用域查找 ，而不是在执行的地方。 三、this详见3-1this取值是在函数执行的时候决定的，而不是函数定义的时候决定的。 箭头函数的this取值是取他的上级作用域的值（静态作用域），普通function的this取值是在函数执行时确认的。 分为以下几种情况：（1）作为对象方法被执行，this指向该对象。（2）class的this表示它当前的实例，在构造函数（函数用new调用）中，this指向要被constructed的新对象。（3）普通函数的this，在调用时才知道this的作用域。（4）箭头函数的this固定指向上级作用域（5）call apply函数内的this和函数在什么环境中定义没有关系，而只和自己的主体有关。 call、apply、bind的区别和使用：作用是在一个对象中调用另一个对象的方法和属性。 call、apply、bind的第一个参数均为需要调用属性或方法的对象，区别是apply的第二个参数为数组，而bind、apply参数不放入数组而是直接列出。 bing会返回一个函数，执行函数后才改变this，而call、apply会立即执行。 bind的执行： call的执行： apply的执行： 面试题：手写bind、call、apply闭包的实际使用场景"},{"title":"【第3-1章】this","date":"2019-04-05T04:00:00.000Z","url":"/2019/04/05/cxy/cxddeziwoxiuyang1/js/js-this/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、作用域与thisES5只有全局作用域和函数作用域，没有块级作用域作用域分为静态/词法作用域和动态作用域 0. 声明提升和暂时性死区(1).声明提升(var) (2).暂时性死区(let) 注意：在es5 strict mode，赋值给未声明的变量将报错。 1.静态作用域静态作用域指的是一段代码，在它执行之前就已经确定了它的作用域，简单来说就是在执行之前就确定了它可以应用哪些地方的作用域(变量)首先let和const声明的全局变量不再属于window变量的作用域，除了this以外，全部遵循词法作用域的原则。即JS引擎总会从最近的一个域，向外层域查找； 二、动态作用域动态作用域–函数的作用域是在函数调用的时候才决定的。在 JavaScript 中的仅存的应用动态作用域的地方：this 引用。动态作用域，作用域是基于调用栈的，而不是代码中的作用域嵌套；作用域嵌套：有词法作用域一样的特性，查找变量时，总是寻找最近的作用域； 三、声明函数的方法（1）.函数声明function a (a,b,c) { return a+b+c;}（2）.函数表达式var a = function (a,b,c) { return a+b+c;}（3）.Function构造函数语法： new Function(参数1, 参数2, 参数3, 方法体)var a = new Function(‘a’,’b’,’c’,’return a+b+c’) 四、变量进入作用域的方法1.Language-defined：所有的作用域默认都会给出 this 和 arguments 两个变量名（global没有arguments2.Formal parameters（函数形参）：函数有形参，形参会添加到函数的作用域中;3.Function declarations（函数声明）：如 function foo() {}4.Variable declarations（变量声明）：如 var foo，包括_函数表达式_ 除了上下文顺序声明之外，若声明提升符合。函数声明和变量声明总是会被移动到它们所在的作用域的顶部。而变量的解析顺序（优先级），与变量进入作用域的4种方式的顺序一致。 关于上下文： 五、this每个作用域都会有this。在全局上下文（任何函数以外），this指向全局对象。 this在具体位置的具体指向： 在函数内部时，this由函数怎么调用来确定。简单调用，即独立函数调用。由于this没有通过call来指定，且this必须指向对象，那么默认就指向全局对象。 严格模式下，this保持进入execution context时被设置的值。如果没有设置，那么默认是undefined。它可以被设置为任意值（包括null/undefined/1等等基础值，不会被转换成对象）。 在箭头函数中，this由词法/静态作用域设置（set lexically）。它被设置为包含它的execution context的this，并且不再被调用方式影响（call/apply/bind）。 当函数作为对象方法调用时，this指向该对象。 原型链上的方法根对象方法一样，作为对象方法调用时this指向该对象。 在构造函数（函数用new调用）中，this指向要被constructed的新对象。 Function.prototype上的call和apply可以指定函数运行时的this。 ES5引进了Function.prototype.bind。f.bind(someObject)会创建新的函数（函数体和作用域与原函数一致），但this被永久绑定到someObject，不论你怎么调用。它说创建新函数，可不是覆盖原函数，！！！！ 闭包中的this（挺绕的，但无论下次看到理不理解，都要记住闭包套的闭包有可能返回window，需要分析有没有自执行函数）为什么下面这段代码的结果是”The Window”？ object.getNameFunc是对象调用的方法，里面的this是指向object，但object里面return的闭包，有自己的this和arguments。在《Javascript高级程序设计》中有写 为什么匿名函数没有取得其包含作用域（外部作用域）的this对象呢？每个函数被调用时，其活动对象都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。 在作用域和闭包说过，闭包的情况有函数作为返回值及函数作为参数被传递。同样的，还有像操作dom函数的闭包。 再深层一些，比如clickEvent这个函数返回的也是闭包，那么无论多少层，只要执行了，都是window。 注意：当用call和apply而传进去作为this的不是对象时，将会调用内置的ToObject操作转换成对象。所以4将会装换成new Number(4)，而null/undefined由于无法转换成对象，全局对象将作为this。 六、JavaScript采用Lexical Scope。（静态范围作用域）于是，我们仅仅通过查看代码（因为JavaScript采用静态范围作用域），就可以确定各个变量到底指代哪个值。另外，变量的查找是从里往外的，直到最顶层（全局作用域），并且一旦找到，即停止向上查找。所以内层的变量可以覆盖外层的同名变量。 七、Function vs. Block Scope上面的内容有意无意似乎应该表明了，JS没有Block Scope。除了Global Scope，只有function可以创建新作用域（Function Scope）。 不过这已经是老黄历了，ES6引入了Block Scope。另外，with和try catch都可以创建Block Scope。"},{"title":"【第2章】原型和原型链","date":"2019-04-04T06:13:15.000Z","url":"/2019/04/04/cxy/cxddeziwoxiuyang1/js/js-prototype/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、原型的简单描述在一个类中：实例的隐式原型，指向类的显式原型类的方法定义于prototype中。son.__proto__ = Son.prototype 在继承关系中：子类的显式原型的隐式原型指向父类的显式原型，查找时就顺着这个链去查找，类的最顶端为object子类也有隐式原型，指向的是父类。Son.prototype.__proto__ = Parent.prototypeSon.__proto__ = Parent call、apply、bind的区别和使用：作用是在一个对象中调用另一个对象的方法和属性。 call、apply、bind的第一个参数均为需要调用属性或方法的对象，区别是apply的第二个参数为数组，而bind、apply参数不放入数组而是直接列出。 bing会返回一个函数，执行函数后才改变this，而call、apply会立即执行。 bind的执行： call的执行： apply的执行： class说白了还是语法糖，如果不用class，用原型链当然也可以定义继承关系。比如我现在有一个类A，有一个子类B 补充：in和hasOwnproperty的区别两个方法都是判断对象中是否存在某个key，但hasOwnproperty不判断原型链上的属性和方法。所以，依据上面的例子：‘aa’ in b // truejavascriptb.hasOwnProperty(‘aa’) // false"},{"title":"【第5章】dom、bom","date":"2019-04-03T05:03:15.000Z","url":"/2019/04/03/cxy/cxddeziwoxiuyang1/js/js-explore/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、dom前言：dom的本质html是一种特定的xml，html规定了语法，而xml可以自己规定标签dom的本质是一个树形的数据结构 1. document对象（1）document对象集合 all[]所有元素的集合anchors[]对所有href链接的引用，非常简单地返回文档中具有name属性值的所有锚点的集合。已被web标准删除。applets对所有applets（小应用程序）对象的引用forms[]对所有forms的引用images[]对所有img的引用links[]对所有area的href的引用，href （2）document对象属性 （3）document对象方法 2. document.element（1）节点操作 （2）节点属性操作 （3）节点属性 3.attribute 在属性节点上的可用的属性或方法 4.event（1）基本写法 （2）事件类型 二、bom（1）window下 history location以举例 Navigator：Navigator下的属性基本是浏览器的各种信息，如userAgent返回由客户机发送服务器的 user-agent 头部的值。 其他常用的： 面试题：如何提高dom性能？(1) 避免频繁的dom操作(2) 对dom查询做缓存(3) 将dom频繁操作改为一次性操作"},{"title":"【第1章】变量类型和计算","date":"2019-04-03T05:03:15.000Z","url":"/2019/04/03/cxy/cxddeziwoxiuyang1/js/js-let/","tags":[["js","/tags/js/"],["lv1","/tags/lv1/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、值类型和引用类型1.js的类型一共六种数字（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（Object）。 其中对象类型包括：数组（Array）、函数（Function） 还有两个特殊的对象：正则（RegExp）和日期（Date） 值类型: number、string、boolean、undefined 引用类型: null、object(array function regexp date) 新类型：BigInt 是一种内置对象，它提供了一种方法来表示大于 253 - 1 的整数。 BigInt和Number的区别：不能用于 Math 对象中的方法；不能和任何 Number 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 BigInt 变量在转换成 Number 变量时可能会丢失精度。 2. 深入分析值类型和引用类型在内存中的存储方式值类型和引用类型有什么区别值类型在栈中存储，引用类型在堆中存储，值类型赋值多少就是多少，引用类型会被指针影响。 3. typeof能判断那些类型？typeof返回结果为字符串 4. 何时使用===何时使用==？除了 == null之外，全部用 === 先说 “===”，这个比较简单。下面的规则用来判断两个值是否===相等： 1、如果类型不同，就不相等 2、如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断） 3、如果两个都是字符串，每个位置的字符都一样，那么相等；否则不相等 。 4、如果两个值都是true，或者都是false，那么相等。 5、如果两个值都引用同一个对象或函数，那么相等；否则不相等。 6、如果两个值都是null，或者都是undefined，那么相等。 再说 “==” 如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： a、如果一个是null、一个是undefined，那么相等。 b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。像-1既不等于false也不等于true，2既不等于false也不等于true2 &gt; true, -1 &lt; false 都是成立的 d、如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。 js核心内置类，会尝试valueOf先于toString; e、任何其他组合，都不相等。 5. 手写深拷贝:递归,什么是深拷贝:浅拷贝如果遇到的是一个引用类型，那么拷贝的实际上是变量的地址，更改的时候会更改拷贝的原变量，深拷贝则会生成一个新地址方法1： 方法2： 改良 手写isEquals()函数 6. truly变量和falsely变量两步非运算为true，则为truly变量，两步非运算为false，则为falsely变量，即 以下为falsely变量，其他都为truly变量 if判断时的truly变量和falsely变量，若为falsely变量直接无法走入if循环 强制类型转换和隐式类型转换(1) 强制类型转换parseInt()和parseFloat() (2) 隐式类型转换 if 逻辑运算 == +、*拼接字符串//字符串和数字相加会转为字符串，字符串和数字相乘/除/减会转为数字 补：hasOwnProperty:对象方法，返回一个boolean，判断是否拥有此对象，且不是继承来的对象，也就是沿着原型链上查找到的。 map weakmap set weakset 区别:1.weakset值只能是对象2.weakset是弱引用，即如果其他对象都不引用该对象，那么垃圾回收机制会立即回收。weakmap键只能是对象，值可以任意。WeakMap的键名所指向的对象，不计入垃圾回收机制。WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。set方法：has() add() delete() clear() entries() keys() values() sizemap方法：add() delete() set(key,value) get()（增删改查） entries() keys() values() size settimeout(fun,ms,arg1,arg2…argN) 第三个-最后一个参数会作为传递参数传给fun"},{"title":"【闭包的典型运用】防抖与节流","date":"2019-03-17T04:13:35.000Z","url":"/2019/03/17/cxy/cxddeziwoxiuyang1/js/js-bibao-debounce&throttle/","tags":[["js","/tags/js/"],["lv2","/tags/lv2/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 闭包的典型应用就是函数防抖和节流，本文详细介绍函数防抖和节流的应用场景和实现。 函数防抖（debounce） 函数防抖，就是指触发事件后，在 n 秒后只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数的执行时间。 简单的说，当一个动作连续触发，只执行最后一次。 打个比方，坐公交，司机需要等最后一个人进入才能关门。每次进入一个人，司机就会多等待几秒再关门。 函数节流（throttle） 限制一个函数在一定时间内只能执行一次 举个例子，乘坐地铁，过闸机时，每个人进入后3秒后门关闭，等待下一个人进入。 常见的应用场景 函数防抖（debounce）的应用场景 连续的事件，只需触发一次的回调场景有： 搜索框搜索输入。只需要用户最后一次输入完再发送请求 手机号、邮箱格式的输入验证检测 窗口大小的 resize 。只需窗口调整完成后，计算窗口的大小，防止重复渲染。 函数节流（throttle）的应用场景 间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚动到底部监听 谷歌搜索框，搜索联想功能 高频点击提交，表单重复提交 省市信息对应字母快速选择 实现原理 函数防抖（debounce） 简单实现： 函数防抖在执行目标方法时，会等待一段时间。当又执行相同方法时，若前一个定时任务未执行完，则 清除掉定时任务，重新定时。 封装： 绑定事件解释：addEventListener 第一个参数是监听的事件，第二个参数是对应事件的回调函数。将 debounce 函数作为回调函数，这个 debounce 回调函数返回一个防抖之后的函数，因此实现了防抖的功能。 防抖解释：当 按下某个键的时候触发 keydown 事件，并执行回调。timer 默认为 null，在 return 的函数中定时器 timer 被赋值，如果在 delay 延迟之内再次触发了 keydown 事件，那么 timer 就会被重置为null...，当用户输入完成之后（delay 时间已过），那么就会触发 debounce 中的回调函数，也就是 keydown 最终要执行的事件。 函数节流（throttle） 简单实现 函数节流的目的，是为了限制函数一段时间内只能执行一次。因此，通过使用定时任务，延时方法执行。在延时的时间内，方法若被触发，则直接退出方法。从而实现一段时间内只执行一次。 封装： 解释：如果 timer 存在，那就直接返回，不再往下执行了。这样就实现了一段时间内执行一次的目的。 异同比较 相同点： 都可以通过使用 setTimeout 实现 目的都是，降低回调函数的执行频率，节省计算资源 不同点： 函数防抖，是在一段连续操作结束之后，处理回调，利用 clearTimout 和 setTimeout 实现。函数节流，是在一段连续操作中，每一段时间只执行一次，在频率较高的事件中使用来提高性能。 函数防抖关注一段时间内连续触发，只在最后一次执行；而函数节流侧重于在一段时间内只执行一次。 节流其实还有另一种不用定时器的方法。新的时间戳 - 旧的时间戳 &gt; delay时间的话，执行方法。否则将此时的时间戳赋值为旧的时间戳 "},{"title":"【prettier】vscode项目配置prettier","date":"2018-04-26T03:29:40.000Z","url":"/2018/04/26/prettier/","tags":[["prettier","/tags/prettier/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"1. 项目中安装prettiernpm i prettier –save-dev 2. 在vsocde中安装prettier插件 注：虽然在项目中安装了 Prettier 以后，可以通过命令行或其他工具来进行代码格式化，但在 VS Code 中使用 Prettier 插件可以使代码格式化更加便捷，而且可以在保存文件时自动格式化代码。因此，建议还是在 VS Code 中安装 Prettier 插件。 3. 设置配置规则在项目根目录新建.prettierrc文件，配置规则 4. 设置.prettierrc的读取 5. 设置保存时自动格式化 6. 配置格式化程式 然后选择prettier即可。 7. 完成此时保存，就可以自动格式化了。"},{"title":"删了改，改了删","date":"2018-03-28T03:36:08.000Z","url":"/2018/03/28/ssjsf/","tags":[["生活","/tags/%E7%94%9F%E6%B4%BB/"]],"categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"放一些突然的灵感，或者想法，或者未整理的东西，或者todo，或者计划，总之什么都可以放在这里。记得实现一条删一条。 接下来的计划 准备一下简历，准备一下面试，看看有什么需要准备的。 部署系统的搭建及构建。 npm包的开发与发布 小程序，uni-app Websocket相关 组件系统的搭建 简单了解一下echart/highchart/bootstrap，总之就是用bootstrap+vue搭建一个可视化的系统。 jsbridge Nodejs，写了自动打包的逻辑 两个月，一个项目一个月，一共七周 算法 在公司上班时就做上班时该做的事情，然后还有就是准备面试相关。 下班时就准备画画的事情。 可是我根本没想好自己要画什么，最近对画画也兴趣缺缺，因为ai越来越厉害了。 然后还有建模 动漫人体那个书还不错，想慢慢的过。练练人体，练练色彩。 我觉得人体结构这个东西我得靠建模来练习更有作用。"},{"title":"typescript总结笔记（8）常见面试题","date":"2018-03-01T11:20:13.000Z","url":"/2018/03/01/vue2/","tags":[["vue","/tags/vue/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" ## v-html computed 和 watchcomputed 和 watch 的区别 computed有缓存，若data不改变是不会重新计算。watch watch的深度监听 style 和 classv-if 和 v-show 的区别v-for可以遍历数组和对象 为什么要使用key？v-for和v-if为什么不能一起使用？v-for的优先级比v-if高，所以列表item很多的时候，会先将所有列表item渲染出来，然后再一个个的v-if判断。对性能影响会较差。 event的使用，$event在vue中，的$event是原生的，事件被挂载到当前元素上面了。事件修饰符：在vue中的事件是有修饰符的，我最常用的是@click.stop，可以阻止事件冒泡。事件修饰符也可以串联写。按键修饰符： v-model包括 表单的v-model 和 自定义v-model 1. 表单的v-model 是下面写法的语法糖，相当于： 2. 自定义组件v-modelvue2和vue3写法略微不同 父子组件通信 props $emit父传子父组件 js部分 子组件 js部分 子传父 组件间的通信 自定义事件1. eventBus2. 自定义事件event.\\$on(&#39;自定义事件名&#39;,触发的事件) 定义自定义事件event.\\$off(&#39;自定义事件名&#39;) 卸载自定义事件event.\\$emit(&#39;自定义事件名&#39;,参数) 触发自定义事件 3. 依赖注入 provider/inject（1）写法根组件中： 任意子孙组件中： 依赖注入默认不是相应式的。 vue2.0如何实现响应式的依赖注入？两种方法，一种可以将根组件的this当做依赖传入，然后用this调用响应式变量。另一种可以将依赖当做函数传入父组件 任一子孙组件 子孙组件vue模板 也可以看官网提供的实例：点击查看响应式依赖注入：点击查看 组件生命周期created mounted有什么区别？created是创建了变量，js中存在了template，但还没有开始渲染mounted是网页已经绘制完成了，已经渲染了父子组件的生命周期钩子调用顺序？ 自定义v-model首先，要知道input 和 change两个事件的区别，input是在文本框的值改变时立即触发，而change是在文本框失去焦点时触发。 vue2.2+版本后，新增加了一个model选项，model选项允许自定义prop和event。官方原文是这样的：允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。 vue2和vue3写法不同。 $nextTick因为vue是异步框 架，在data改变后，dom不一定会立即渲染。如果此时想去获取dom中的数据，可能会获取不到。但如何知道开始渲染了？就在nextTick中获取 动态/异步组件动态组件：有时候不知道要加载什么组件，可以动态加载 异步组件：很常用。内网开发的对内部人员用的网站，像echarts这种很大的组件，会严重影响性能。因为是vue是单文件实现多页切换，首页可能用不到图表也去加载的话，就会影响性能，此时就可以去异步加载。 slot作用域插槽具名插槽 keep-alive mixin多个组件有相同的逻辑，可以放入mixin中。组件中： 在mixin.js中 缺点： 变量来源不明确，引的多了不知道从哪儿来的 多个mixin引入，如果是不同人开发的话，很有可能里面有变量名冲突。 mixin有可能出现多对多的关系，就是多个组件引入了一个mixin，一个组件还可以引入多个mixin，代码一旦复杂度提升，就会开始头疼了。。。vue3和vue2的区别v-model "}]