[{"title":"【网页】六位颜色和八位颜色的区别","date":"2023-04-23T03:34:11.000Z","url":"/2023/04/23/%E5%85%AD%E4%BD%8D%E9%A2%9C%E8%89%B2%E5%92%8C%E5%85%AB%E4%BD%8D%E9%A2%9C%E8%89%B2%E7%9A%84%E5%8C%BA%E5%88%AB/","categories":[["undefined",""]],"content":"在定义颜色的时候，#ffffff 和 #ffffffff 都是十六进制的表示方式，表示的是 RGB 或 RGBA 颜色模式下的颜色值。 #ffffff 表示的是 RGB 颜色模式下的白色，其中每两个相同的字符表示一个颜色通道的数值，即 #RRGGBB，其中 RR 表示红色通道的数值，GG 表示绿色通道的数值，BB 表示蓝色通道的数值。每个通道的数值都是一个 0-255 之间的十进制数。 #ffffffff 则表示的是 RGBA 颜色模式下的白色，其中除了 RGB 部分的颜色通道数值以外，还有一个表示透明度的通道数值，即 #RRGGBBAA，其中 AA 表示透明度的数值，数值范围也是 0-255 的十进制数。 八位的颜色表示方式则是指用一个 32 位的无符号整数来表示颜色，其中最高的 8 位表示透明度通道的数值，接下来每 8 位表示一个颜色通道的数值，即 AA RR GG BB，每个通道的数值也是一个 0-255 之间的十进制数。 因此，六位和八位颜色表示方式的区别在于八位方式多了一个表示透明度的通道，而且将四个颜色通道和透明度通道的数值压缩到一个 32 位的整数中，可以更加节省存储空间。 六位颜色和八位颜色的区别当我们在网页设计和开发中定义颜色时，一般使用十六进制表示法。这种表示法使用一个带有 # 符号的字符串，后面跟着六个或八个十六进制数字，来表示颜色。 六位颜色表示法使用 # 符号后面跟着六个十六进制数字，用来表示红、绿、蓝（RGB）三个颜色通道的值。每个颜色通道的值都是介于 00 到 FF 之间的十六进制数字，其中 00 表示最小值，FF 表示最大值。例如，#FF0000 表示红色，#00FF00 表示绿色，#0000FF 表示蓝色。 而八位颜色表示法则将 RGB 值和一个透明度通道值（Alpha）结合起来，使用一个带有 # 符号的字符串后面跟着八个十六进制数字，用来表示红、绿、蓝（RGB）三个颜色通道以及透明度通道的值。每个颜色通道的值仍然是介于 00 到 FF 之间的十六进制数字，而透明度通道的值则表示颜色的不透明度，也是介于 00 到 FF 之间的十六进制数字。例如，#FF0000FF 表示红色，透明度为不透明（即不透明度为 FF）。 六位颜色表示法适用于大多数情况，比如定义文本颜色、背景颜色等。而八位颜色表示法则更适用于需要定义半透明颜色的情况，比如定义阴影颜色、边框颜色等。在实际开发中，使用六位和八位颜色表示法时需要根据具体的需求来选择，遵循“合适即好”的原则。 总之，六位和八位颜色表示法是网页设计和开发中常用的颜色表示方式，通过了解这两种表示法的区别和应用场景，我们可以更好地运用它们来实现我们的网页设计需求。"},{"title":"【ai绘画】Midjourney 之 Commands（实用命令）","date":"2023-04-19T06:16:35.000Z","url":"/2023/04/19/midjourney3-1/","tags":[["Midjourney","/tags/Midjourney/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"太常用的就不列举了，比如 /imagine 感觉比较常用的实用的如下：/info/blend/describe/remix/show/settings"},{"title":"【ai绘画】midjourney试水合集","date":"2023-04-10T11:12:51.000Z","url":"/2023/04/10/midjourney5/","tags":[["Midjourney","/tags/Midjourney/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"准备之后用关键词和命令还有参数一一试水都丢在这里。 觉得midjourney很适合生成连续的故事什么的 关键词A handsome and strong soldier wearing green military uniform, with half of his face visible, in a Japanese anime style. The illustration is semi-thickly painted with bright and colorful tones, resulting in an attractive and glossy finish. adg The scene is set during daytime, under the shining sun. A sweet-looking Japanese-style girl is depicted from the waist up, sporting double buns with her hair mostly blue but also featuring some colorful strands. Her blue eyes are accentuated by a semi-thick paint style and the lighting is coming from the side, highlighting her slightly tilted head and resulting in an attractive glossy finish. 3d风格3d art c4d ultra detoiled "},{"title":"【ai绘画】Midjourney 之 Commands（命令概述）","date":"2023-04-10T11:06:10.000Z","url":"/2023/04/10/midjourney3/","tags":[["Midjourney","/tags/Midjourney/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、命令简介 /ask：提问并获得答案。 /blend：轻松混合两个图像。 /daily_theme：切换是否接收 #daily-theme 频道更新的通知提醒。 /docs：在官方 Midjourney Discord 服务器中使用，快速生成本用户指南中涉及的主题链接！ /faq：在官方 Midjourney Discord 服务器中使用，快速生成常见提示工艺频道的常见问题解答链接。 /fast：切换到快速生成模式。无需排队，需要订阅Standard Plan或Pro Plan（可以使用快速生成模式的时间不同）。 /help：显示有关 Midjourney Bot 的有用基本信息和提示。 /imagine：使用提示生成图像。 /info：查看有关您的帐户以及任何排队或运行的作业的信息。 /stealth：对于 Pro 计划订阅者：切换到隐形模式。 /public：对于 Pro 计划订阅者：切换到公共模式m。 /subscribe：生成用户帐户页面的个人链接。 /settings：查看并调整 Midjourney Bot 的设置。 /prefer option：创建或管理自定义选项。 /prefer option list：查看您当前的自定义选项。 /prefer suffix：指定要添加到每个提示结尾的后缀。 /show：使用图像作业 ID 在 Discord 中重新生成作业。 /relax：切换到放松模式，对应/fast快速生成模式。 /remix：切换混合模式。使用方法：/prefer remix /settings：设置midjourny默认工作方式。比如版本、快速模式、质量等 二、常用命令的详解以上命令部分需要在官方 Midjourney Discord 服务器中使用，所以如果没有用，首先看看自己在不在midjourney的官方服务器。 /blend 作用：融合2-5个图像的风格，生成新的图像。 详见Midjourney 之 Prompts 使用/blend命令混合图像 /docs：查看文档 Settings and Presets（设置与预设） 1️⃣ MJ Version 1 2️⃣ MJ Version 2 3️⃣ MJ Version 3 4️⃣ MJ Version 4 5️⃣ MJ Version 5 模型版本 5仅适用于订阅了 Midjourney 的用户。 🔥 Half Quality 🔥 Base Quality 🔥 High Quality (2x cost) 设置用于作业的质量参数。 半质量 = --q .5，基本质量 = --q 1，高质量 = --q 2。 🖌️ Style Low 🖌️ Style Med 🖌️ Style High 🖌️ Style Very High mk 设置用于作业的风格化参数。 风格低 = --s 50，风格中 = --s 100，风格高 = --s 250，风格非常高 = --s 750， 🧍&zwj;♂️Public 🕵️ Stealth 在公共模式和隐身模式之间切换。对应于/public和/stealth命令。 🎛️ Remix 切换到混音模式 🐇 Fast 🐢 Relax 在Fast 和 Relaxed 模式之间切换。对应于/fast和/relax命令。 设置说明 添加到提示末尾的参数将覆盖使用 所做的选择/settings。 自定义首选项 使用 prefer 命令创建自定义选项，以自动将常用参数添加到提示末尾。 /prefer auto_dm完成的工作会自动发送到直接消息 /prefer option创建或管理自定义选项。 /prefer option list查看您当前的自定义选项。 /prefer suffix指定要添加到每个提示末尾的后缀。 偏好选项 /prefer option set &lt;name&gt; &lt;value&gt;创建可用于将多个参数快速添加到提示末尾的自定义参数。 /prefer option set mine --hd --ar 7:4创建一个名为“我的”的选项，转换为--hd --ar 7:4. 使用/imagine prompt vibrant California poppies --mine, 被解释为/imagine prompt vibrant California poppies --hd --ar 7:4。 将“值”字段留空以删除选项。 /prefer option list列出使用创建的所有选项prefer option set. 用户最多可以有 20 个自定义选项。 要删除自定义选项，请使用/prefer option set &lt;name to delete&gt;值字段并将其留空。 首选后缀 /prefer suffix在所有提示后自动附加指定的后缀。使用不带值的命令进行复位。 命令示例：/prefer suffix --uplight --video Only Parameters可以与 一起使用/prefer suffix， prefer suffix --no orangeis accepted prefer suffix orange::-1不接受 订阅者可以在 Discord 的直接消息中与 Midjourney Bot 进行一对一的工作，而不是通过公共频道。在您的直接消息中制作的图像仍受内容和审核规则的约束，并且将在您的 Midjourney 网站画廊中可见。 设置用于作业的质量参数。 半质量 = --q .5，基本质量 = --q 1，高质量 = --q 2。 🖌️ Style Low 🖌️ Style Med 🖌️ Style High 🖌️ Style Very High 设置用于作业的风格化参数。 风格低 = --s 50，风格中 = --s 100，风格高 = --s 250，风格非常高 = --s 750， 🧍&zwj;♂️Public 🕵️ Stealth 在公共模式和隐身模式之间切换。对应于/public和/stealth命令。 🎛️ Remix 切换到混音模式 🐇 Fast 🐢 Relax 在Fast 和 Relaxed 模式之间切换。对应于/fast和/relax命令。 设置说明 添加到提示末尾的参数将覆盖使用 所做的选择/settings。 自定义首选项 使用 prefer 命令创建自定义选项，以自动将常用参数添加到提示末尾。 /prefer auto_dm完成的工作会自动发送到option set &lt;name&gt; &lt;value&gt;创建可用于将多个参数快速添加到提示末尾的自定义参数。 /prefer option set mine --hd --ar 7:4创建一个名为“我的”的选项，转换为--hd --ar 7:4. 使用/imagine prompt vibrant California poppies --mine, 被解释为/imagine prompt vibrant California poppies --hd --ar 7:4。 将“值”字段留空以删除选项。 /prefer option list列出使用创建的所有选项prefer option set. 用户最多可以有 20 个自定义选项。 要删除自定义选项，请使用/prefer option set &lt;name to delete&gt;值字段并将其留空。 首选后缀 /prefer suffix在所有提示后自动附加指定的后缀。使用不带值的命令进行复位。 命令示例：/prefer suffix --uplight --video Only Parameters可以与 一起使用/prefer suffix， prefer suffix --no orangeis accepted prefer suffix orange::-1不接受 订阅者可以在 Discord 的直接消息中与 Midjourney Bot 进行一对一的工作，而不是通过公共频道。在您的直接消息中制作的图像仍受内容和审核规则的约束，并且将在您的 Midjourney 网站画廊中可见。"},{"title":"【ai绘画】Midjourney 之 Param（参数）","date":"2023-04-10T11:06:10.000Z","url":"/2023/04/10/midjourney4/","tags":[["Midjourney","/tags/Midjourney/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、命令列表--aspect或 --ar纵横比。如--ar 16:9就是纵横比16:9 –chaos &lt;number 0–100&gt;--chaos &lt;number 0–100&gt; 改变结果的多样性。较高的值会产生更多不寻常的结果。 --chaos接受值 0–100。默认--chaos值为 0。 --no--no plants 会尝试从图像中移除植物。 **--quality &lt;.25&gt;或 --q &lt;.25&gt; **--quality &lt;.25, .5, 1, or 2&gt;, 或 --q &lt;.25, .5, 1, or 2&gt; 您要花费多少时间进行渲染。默认值为 1。值越高渲染结果越质量越高，值越低渲染结果越质量越低。 --repeat或--r--repeat &lt;1–40&gt;, or --r &lt;1–40&gt; 从单个提示创建多个作业。--repeat对于多次快速重新运行作业很有用。 --repeat适用于 Standard 和 Pro订阅者，--repeat Standard 订阅者接受 2–10 的值。--repeatPro 订阅者接受值 2–40。该参数只能在Fast GPU 模式--repeat下使用。 使用作业结果上的重做（重新滚动）🔄 按钮只会重新运行提示一次。 --seed或--sameseedMidjourney 机器人使用种子编号创建视觉噪声场，如电视静态，作为生成初始图像网格的起点。种子编号是为每个图像随机生成的，但可以使用 –seed 或 –sameseed 参数指定。使用相同的种子编号和提示将产生相似的结束图像。 --stop使用--stop参数在流程中途完成作业。以较早的百分比停止作业会产生更模糊、更不详细的结果。 --style--style &lt;4a, 4b, or 4c&gt;在 Midjourney模型版本4的版本之间--style &lt;expressive, or cute&gt;切换 在 Niji模型版本5的版本之间切换 **--stylize &lt;number&gt;**或--s &lt;number&gt;--stylize &lt;number&gt;，或--s &lt;number&gt; 参数会影响 Midjourney 的默认美学风格应用于 Jobs 的强度。 --tile--video使用该--video参数创建正在生成的初始图像网格的短片。使用信封 ☉️ 表情符号对完成的工作做出反应，让 Midjourney Bot 将视频链接发送到您的直接消息。 --video仅适用于图像网格，不适用于高档。--video适用于模型版本 1、2、3、test和testp。 效果： --uplight--uplight Use an alternative “light” upscaler when selecting the U buttons. The results are closer to the original grid image. The upscaled image is less detailed and smoother. --upbeta--upbeta Use an alternative beta upscaler when selecting the U buttons. The results are closer to the original grid image. The upscaled image has significantly fewer added details. 默认参数(Model Version 4) –ar –c –q –seed –stop –style –stylize 默认值 1:1 0 1 随机 100 4c 100 范围 1:2–2:1 0–100 .25 .5 or 1 0–4294967295 10–100 4a, 4b, or 4c 0–1000 默认参数 (Model Version 5) –ar –c –q –c –stop –stylize 默认值 1:1 0 1 随机 100 100 范围 any 0–100 .25 .5, or 1 0–4294967295 10–100 0–1000 大于 2:1 的宽高比是实验性的，可能会产生不可预测的结果。（实测有时会有黑边。） 二、--seed详细说明1. --seed说明用过 Midjourney 的小伙伴会发现在发送提示词后，MJ 最开始的图像里会有一个非常模糊的噪点团 ，然后逐渐变得具体清晰，而这个噪点团的起点就是“Seed”，MJ 依靠它来创建一个视觉噪音场，作为生成初始图像的起点。每个图像的种子值是为随机生成的，但可以用 –seed 参数指定。在 v4 模型中使用相同的种子值和提示词将产生相同的图像结果，利用这点我们可以生成连贯一致的人物形象或者场景。Seed是Midjourney图像生成的初始点，每个图像的种子值是随机生成的，但可以用Seed参数保持统一。使用相同的种子值和提示词将产生完全相同的图像结果，利用这但可以生成连贯的人物形象或场景。 a rabbit –seed 4100004954，只要seed值一致，那么无论生成几次，只要关键词相同结果都是相同的。 2. 获取 --seed使用时要确保服务器开启了隐私设置。 如果是自己创建的服务器，那么需要在个人服务器上右键 - 隐私设置 也可以全局设置，Discord - Preferences - 隐私与安全 - 允许服务器成员直接向您发起私聊。 但要注意，这个设置不适用于已经加入的服务器。 三、--chaos（--c）详细说明四、 --remix详细说明五、--upscaler详细说明Midjourney 首先为每个作业生成一个低分辨率图像选项网格。您可以在任何网格图像上使用 Midjourney upscaler 来增加尺寸并添加更多细节。有多种可用于放大图像的放大模型。每个图像网格下方的按钮用于放大所选图像。U1 U2 U3 U4 六、--tile详细说明七、复合提示八、排列提升"},{"title":"【ai绘画】Midjourney 之 Prompts","date":"2023-04-09T03:55:04.000Z","url":"/2023/04/09/midjourney2/","tags":[["Midjourney","/tags/Midjourney/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"一、Promptsprompts（提示）是 Midjourney Bot 解释以生成图像的短文本短语。Midjourney Bot 将提示中的单词和短语分解为更小的部分，称为标记，可以将其与其训练数据进行比较，然后用于生成图像。精心制作的提示可以帮助制作独特而令人兴奋的图像。 1. 结构提示可以像一个单词、短语、emoji一样简单，也可以使用更高级的提示。 更高级的提示可以包括一个或多个图像 URL、多个文本短语以及一个或多个参数 image Prompts 可以将图像 URL 添加到提示中以影响最终结果的样式和内容。 图片 URL 始终位于提示的前面。 Text Prompt 要生成的图像的文本描述。 Parameters Parameters位于提示的末尾，它可以改变图像的生成方式。 用–表示。 可以更改宽高比、模型、放大器等等。 2. 需要注意的提示点长度非常短的提示将在很大程度上依赖于 Midjourney 的默认样式。 更具描述性的提示更适合独特的外观。 语法不是越长越好，要提取重点词，专注于要创建的主要概念。因为midjourney不是像人类那样理解语法。 要用更精准的词汇，比如：大，是怎么样的大？ big, try gigantic, enormous, immense 去掉不需要的内容--no参数加上的东西可以告诉midjourney，你不想在图像上出现什么 比如不想要蛋糕，可以加上--no cake （唔、挺惊悚的。。生日没有蛋糕的怒气值叠满了！） 考虑哪些细节很重要尽量把很重要的任何背景或细节搞清楚： 主题：人、动物、人物、地点、物体等。 媒介：照片、绘画、插图、雕塑、涂鸦、挂毯等。 环境：室内、室外、月球上、纳尼亚、水下、翡翠城等。 照明：柔和、环境、阴天、霓虹灯、工作室灯等 颜色：充满活力、柔和、明亮、单色、彩色、黑白、柔和等。 情绪：稳重、平静、喧闹、精力充沛等。 构图：肖像、头像、特写、鸟瞰图等。 把官网的英文摘下来作参考： Subject: person, animal, character, location, object, etc. Medium: photo, painting, illustration, sculpture, doodle, tapestry, etc. Environment: indoors, outdoors, on the moon, in Narnia, underwater, the Emerald City, etc. Lighting: soft, ambient, overcast, neon, studio lights, etc Color: vibrant, muted, bright, monochromatic, colorful, black and white, pastel, etc. Mood: Sedate, calm, raucous, energetic, etc. Composition: Portrait, headshot, closeup, birds-eye view, etc. 使用具体数字比如”three birds”就比”birds”更加精确 3. Exprore Prompting（探索提示）选择媒介提示示例：/imagine prompt &lt;any art style&gt; style cat 常用的媒介类型： Block Print版画 Folk Art民间艺术 Cyanotype蓝版 Graffiti涂鸦 Paint-by-Numbers数字绘画 Risograph数字印刷 Ukiyo-e浮世绘 Pencil Sketch铅笔素描 Watercolor水彩 Pixel Art像素画 Blacklight Painting紫外线画 Cross Stitch十字绣 细化更精确的单词和短语将有助于创建具有完全正确外观和感觉的图像。 提示示例：/imagine prompt &lt;style&gt; sketch of a cat Life Drawing写生 Continuous Line连续线 Loose Gestural随性手势画 Blind Contour草图速写 Value Study明暗对比研究 Charcoal Sketch炭笔素描 时间旅行不同的时代有不同的视觉风格。 提示示例：/imagine prompt &lt;decade&gt; cat illustration 1700s 1800s 1900s 1910s 1920s 1930s 1940s 1950s 1960s 1970s 1980s 1990s 表情提示示例：/imagine prompt &lt;emotion&gt; cat Determined坚定 Happy快乐 Sleepy困 Angry生气 Shy害羞 Embarassed尴尬 使颜色更加丰富提示示例：/imagine prompt &lt;color word&gt; colored cat Millennial Pink千禧粉 Acid Green酸性绿 Desaturated无饱和度 Canary Yellow金丝雀黄 Peach桃色 Two Toned双色调 Pastel粉彩 Mauve淡紫色 Ebony乌木色 Neutral中性色 Day Glo荧光色 Green Tinted绿色调 环境提示示例：/imagine prompt &lt;location&gt; cat Tundra苔原 Salt Flat盐滩 Jungle密林 Desert沙漠 Mountain山脉 Cloud Forest云雾森林 使用/blend命令混合图像该/blend命令允许您快速上传 2-5 张图像，然后读取每张图像的风格和元素，并将它们合并成一个新颖的新图像。 /blend与使用多个图像提示相同/imagine，但界面经过优化以方便在移动设备上使用。 /blend最多可处理 5 张图像。要在提示中使用 5 个以上的图像，请使用/imagine prompts /blend，不适用于文本提示。要同时使用文本和图像提示，请使用/imagine prompts /blend选项输入/blend命令后，系统会提示您上传两张照片。 要添加更多图像，可点击 增加4 并选择image3、image4或image5。 该/blend命令可能需要比其他命令更长的时间才能启动，因为您的图像必须在 Midjourney Bot 可以处理您的请求之前上传。 dimensions：可设置生成图片比例。混合图像的默认纵横比为 1:1，但您可以使用可选dimensions字段在方形纵横比square (1:1)、纵向纵横比portrait (2:3) 或横向纵横比landscape (3:2) 之间进行选择。 自定义后缀被添加到提示的末尾/blend，就像任何其他/imagine提示一样。作为/blend命令的一部分指定的宽高比会覆盖自定义后缀中的宽高比。 混合技巧为获得最佳效果，请上传与您想要的结果具有相同宽高比的图像。"},{"title":"uni-app基础(总结中)","date":"2023-04-06T08:09:55.000Z","url":"/2023/04/06/uni-app%E5%9F%BA%E7%A1%80/","tags":[["uni-app","/tags/uni-app/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、uni-app重点总结1. uniapp 规范 页面遵循vue语法，模板块、脚本块和样式块。 页面遵循vue单文件组件规范（SFC） 页面标签遵循小程序语法规范 接口接近小程序规范 数据绑定及事件处理遵循vue规范 为兼容多端运行，遵循flex布局。 2. uniapp 特色 条件编译 App端的Nvue开发 Nvue是native-vue的简写。是在uniapp中以.nvue结尾的文件，它为app提供了原生的渲染能力。 Nvue内置了weex的渲染引擎，所以在.nvue文件中，既可以使用weex内置的方法，也可以使用uni-app的内置方法。 只能在NATIVE端使用。 HTML5+ HTML5+引擎为应用提供了原生的安卓端和ios端的方法。有一些复杂功能在html5无法做到时，可以使用html5+引擎。 只能在NATIVE端使用 二、创建uniapp项目1. 通过hbuilder创建安装好hbuilder后， 运行： 2. 通过vue命令行创建环境安装全局安装vue-cli 创建uni-app使用正式版（对应HBuilderX最新正式版） 使用alpha版（对应HBuilderX最新alpha版） 三、语法1. 模板语法和vue一样 2. 数据绑定在小程序中使用 在uni-app中 其实就和vue是一样的。 3. 条件判断 注：v-show在uni-app非h5页面中会有坑。尽量不要把v-show放在组件上，在组件外层套一层view。 4. 列表渲染 5. 内置组件view相当于div text相当于span scroll-view swiper和swiper-item match-media movable-area和movable-view：即手指/鼠标按住movable-view拖动或双指缩放，但拖不出movable-area规定的范围。 movable-view必须在movable-area组件中，并且必须是直接子节点，否则不能移动。 cover-view和 cover-image : cover-view相当于 position: fixed; 但在其中可以写自己的布局。 cover-image和cover-view用法相同，区别在于cover-image只可以放图片，它可以嵌套在cover-view中 button input 6. 自定义组件的使用7. 基础 api 用法8. 条件编译9. 页面布局"},{"title":"【ai绘画】Midjourney 之 入门","date":"2023-04-03T03:37:57.000Z","url":"/2023/04/03/midjourney1/","tags":[["Midjourney","/tags/Midjourney/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":"想了想还是整理一下文档吧。ai出来一个我就搁colab部署一个，midjourney掏点儿小钱就能省去我部署的步骤真是太好了。而且也不像stable diffusion那样需要自己搜集训练模型我体验过的ai绘画中算是效果最好，上手难度最低的一个。 一、安装及入门1. 注册discord midjourney的使用是通过discord访问，所以需要注册discord。 点击进入：discord官网 科学上网简单介绍discordDiscord是一款免费的语音、视频和文字聊天应用程序，它允许用户在私人或公共服务器上创建和加入聊天室或频道。Discord的功能包括语音和视频通话、实时文本聊天、文件共享、屏幕共享、在线状态、自定义表情符号和徽章、服务器和频道管理工具等。它还提供了丰富的API，允许开发者创建自定义的机器人和集成其他服务。通过Discord，用户可以方便地与其他人交流和合作，无论是在游戏、工作还是社交方面。它已经成为了一个非常流行的工具，有着庞大的用户群体和活跃的社区。 2. 访问midjourney.com访问Midjourney.com，点击join the Beta，或直接前往Midjourney Discord。 3. 寻找newbies频道在discord左侧，有房间可选 随便选择一个进入即可。 4、 使用 /imagine 命令 从斜杠命令弹出窗口中键入/imagine prompt:或选择命令。/imagine 该/imagine命令从简短的文本描述（称为Prompt）生成一个独特的图像。 初次使用时，Midjourney Bot 将生成一个弹出窗口，要求您接受服务条款。在生成任何图像之前，您必须同意服务条款。 5、处理图像Midjourney Bot 需要大约一分钟的时间来生成四个选项。生成图像会激活免费的 Midjourney 试用版。试用用户有部分的免费时间，在需要订阅付费之前可以完成大约 25 个工作。 使用/info命令检查你的快速剩余时间查看您的剩余试用时间。 6、图像生成的基础上，进一步的变化初始图像网格生成完成后，会出现两行按钮： U 按钮放大图像，生成所选图像的更大版本并添加更多细节。 V 按钮创建所选网格图像的细微变化。创建变体会生成与所选图像的整体风格和构图相似的新图像网格。 🔄（重新滚动）重新运行作业。在这种情况下，它将重新运行原始提示，生成新的图像网格。 7. 评价图像使用放大图像后，将出现一组新选项： Make Variations：创建放大图像的变体并生成包含四个选项的新网格。 Beta/Light Upscale Redo：使用不同的升级器模型重做升级。 ↗️Web：在Midjourney.com 上打开图库中的图像 8. 保存图像单击图像以全尺寸打开它，然后右键单击并选择Save image。 在手机上，长按图片，然后点击右上角的下载图标。 所有图片均可立即在midjourney.com/appSign In with Discord上查看。 9. 订阅服务试用用户有试用时长，若不生成图片不会消耗，但也不会更新。要制作更多图像，请使用/subscribe在任何newbies频道中的命令生成指向中途帐户页面的个人链接。 不要与他人分享此个人链接。 请访问订阅服务，获取有关价格和更多信息。 二、创建自己的个人服务器在公共频道很多人都在生成图片，要翻找自己生成的图片很麻烦。 可以在discord创建自己的服务器并部署midjourney机器人，在自己的频道下使用midjourney。 注：虽然在自己的个人服务器可以只展示自己的图片，但实际上生成的图片还是在midjourney公共区可以访问到。 只有付费计划pro plan可以避免这点。 1. 创建服务器点击+号 —&gt; 亲自创建 —&gt; 仅供我和我的朋友使用 —&gt; 创建 2. 进入频道，输入命令即可使用 入门部分就到这里，之后我会用新文章整理关键字及命令部分。"},{"title":"【BFC】BFC","date":"2023-04-03T03:12:24.000Z","url":"/2023/04/03/BFC/","tags":[["css","/tags/css/"],["iv","/tags/iv/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"BFC概念BFC是“块级格式化上下文”的缩写，用于控制文档中块级元素的布局和定位。在一个BFC中，元素按照一定的规则进行排列，不会影响到BFC外部的元素。BFC的常见特征包括： 内部的盒子会在垂直方向上一个接一个地放置，因此不会重叠。 在BFC中，每个盒子的左边和右边外边距（margin）不会和其他元素的外边距折叠（collapse）。 BFC可以包含浮动元素，因此可以避免浮动元素对其他元素的影响。 BFC的高度可以自适应其内部元素的高度，不会塌陷（collapse）。 通过理解和应用BFC，可以更好地掌控页面的布局和样式，解决一些常见的排版问题，比如清除浮动、避免外边距折叠等。 BFC的实际运用场景清除浮动：当一个父元素包含了一个浮动元素时，父元素可能会因为子元素浮动而导致高度塌陷。这时可以在父元素上创建一个新的BFC来解决这个问题，例如： 避免外边距折叠当两个相邻的元素的外边距发生重叠时，可以在其中一个元素上创建一个新的BFC来避免这个问题，例如： 自适应布局在一个父元素中，如果有一些子元素的高度不固定，可以在父元素上创建一个新的BFC，从而实现自适应布局，例如： 解决文本环绕问题当需要在一个元素周围放置文本时，可以在该元素上创建一个新的BFC，从而实现文本环绕的效果，例如： 其他可以创建bfc的例子上面列举的多数还是使用overflow: hidden时，这种BFC的创建方式是很常用来解决布局问题的。实际上还有很多别的方法会创建BFC。 + 使用float属性创建新的BFC： + 使用position属性创建新的BFC： 使用display创建BFC使用一些display属性值也可以创建新的BFC，例如display: table-celldisplay: table-caption等。"},{"title":"【性能优化】Webpack-Bundle-Analyzer","date":"2023-04-03T02:46:52.000Z","url":"/2023/04/03/Webpack-Bundle-Analyzer/","tags":[["性能优化","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"简单写一下，就是在开发时使用了它做性能分析，还是挺好用的。 官网 简介 Webpack Bundle Analyzer是一个Webpack插件，用于分析和可视化Webpack打包后的bundle文件。它可以帮助开发者找出打包文件中的性能瓶颈和优化机会，从而提高应用程序的性能和用户体验。 Webpack Bundle Analyzer可以生成一个可交互的可视化图表，展示打包后的bundle文件中各个模块的大小、依赖关系、文件类型等信息，还可以通过颜色区分出不同的模块类型，如应用代码、第三方库、webpack运行时等。开发者可以通过这个图表找出文件中占用空间最大的模块和文件，进一步分析和优化代码和依赖关系，减少文件大小和提高打包速度。 除了可视化图表外，Webpack Bundle Analyzer还可以生成详细的报告文件，包含了模块和文件的详细信息，开发者可以根据报告文件找出打包文件中的性能问题和优化机会。 在前端开发中，Webpack Bundle Analyzer可以帮助开发者分析和优化Webpack打包文件，从而提高应用程序的性能和用户体验。 在umi+react中的使用umi是一个基于webpack和babel的可扩展企业级前端应用框架，可以帮助开发者快速构建React单页面应用或多页面应用。umi集成了Webpack，所以我们可以直接在umi项目中使用Webpack Bundle Analyzer插件来分析和优化打包文件。 首先，在项目中安装Webpack Bundle Analyzer插件： 然后，在.umirc.js文件中配置Webpack Bundle Analyzer插件： 配置完成后，运行umi dev命令，Webpack Bundle Analyzer插件将自动启动并在浏览器中显示打包文件的分析报告。 通过Webpack Bundle Analyzer插件，开发者可以快速找出应用程序中占用空间最大的模块和文件，进一步分析和优化代码和依赖关系，提高应用程序的性能和用户体验。"},{"title":"组件库相关","date":"2023-03-30T11:01:18.000Z","url":"/2023/03/30/%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9B%B8%E5%85%B3/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、思维整理移动端的前端组件库可以包括许多组件，这里列出一些常见的组件：按钮组件：用于触发操作或提交表单。图标组件：用于显示图标。输入框组件：包括文本输入框、数字输入框等。列表组件：用于展示列表信息。滚动组件：用于滚动显示大量内容。轮播组件：用于轮播广告或图片。弹窗组件：用于弹出提示或确认框。标签组件：用于分类或标记信息。搜索组件：用于搜索信息。日期时间组件：用于选择日期时间。下拉选择组件：用于选择下拉菜单中的选项。滑块组件：用于选择范围或值。表单组件：包括表单验证、提交等。树形组件：用于显示层级结构。下拉刷新：下拉时可以重新加载数据。上拉加载更多：当data很多时分页适用。头像+头像框组件：有些活动中会有不规则头像框，或者vip的特效等。搜索文本框：带搜索按钮的文本款组件等。再比如性能优化方面，防抖、节流等 jsbridge相关：调用相机、调用相册、分享等 组件库搭建：展示方面：用react/vue + bootstrap4 做框架，codesandbox做代码演示，还有复制链接及效果，类似antd组件的网站。然后使用npm包安装，引入使用。 比如说，我现在想搭一个npm包，里面包括按钮组件、搜索框组件等。这里我就只写两个按钮组件、搜索框组件 二、npm包的开发示例1. 安装依赖 2. 在项目根目录下创建一个 webpack.config.js 文件，配置如下：在项目根目录下创建一个 webpack.config.js 文件，配置如下： 其中，entry 字段指定了入口文件，output 字段指定了输出配置，这里生成了一个名为 my-button.js 的文件，library 指定了模块名称，libraryTarget 指定了模块的导出方式。 3. 在 src 目录下创建 index.js 文件和 Button.vue 文件，分别编写代码如下： Button.vue： 4. 在命令行中运行以下命令打包： 5. 引用将打包后的文件（即 my-button.js）上传到 npm 上，然后在需要使用该组件库的项目中，通过以下命令安装该组件库： 在项目中使用该组件库，可以像下面这样引入： 之后就可以在Vue 组件中使用 MyButton 组件了，像这样： 三、在原有组件基础上加入新的搜索文本框组件思路：先将新的搜索文本框组件写好并打包成一个单独的模块。然后，可以在 my-button 组件中引入新的搜索文本框组件并进行相应的配置和使用。最后，将 my-button 和搜索文本框组件打包成一个组件库并发布到 npm 上。 具体的步骤如下： 1. 编写搜索文本框组件具体的编写就不说了，假设已经编辑好，命名为 my-input。创建一个webpack.config.js文件，配置打包规则： 这里使用了 vue-loader 处理 .vue 单文件组件，使用 css-loader、vue-style-loader 和 style-loader 处理样式文件，使用 file-loader 处理静态资源文件。设置了输出目录路径、输出文件名称、打包生成的库的名称、打包生成的库的目标环境等。 2. 在 src 目录下创建一个 index.js 入口文件，用于导出组件： 3. 引入 在项目中引用组件库中的组件，首先需要在代码中引入组件，比如： 然后在代码中直接使用引入的组件即可： 三、搭建boostrap+vue的网页端待补充"},{"title":"【npm】npm发布步骤","date":"2023-03-28T03:36:08.000Z","url":"/2023/03/28/npm%E5%8F%91%E5%B8%83/","tags":[["npm","/tags/npm/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"npm包发布发布一个npm包通常需要以下步骤： 确保你已经安装了Node.js和npm，以及在npm上注册了一个账户。如果没有，请先在上注册一个账户。 在终端中创建一个新的项目文件夹，并进入该文件夹。执行以下命令来初始化npm包： 在你的项目文件夹中编写代码，并确保在package.json文件中指定了正确的入口文件路径和依赖项。 编写README文件和许可证文件，并确保它们在项目文件夹中。 在终端中运行以下命令来登录npm账户: 输入你的用户名、密码和电子邮件地址。如果一切顺利，你将登录成功（若无法登录，请看看“可能遇到的问题”部分）。 在终端中运行以下命令，将包发布到npm上: 这将把你的npm包上传到npm仓库。你的包将被分配一个唯一的版本号，并且其他人可以通过npm来安装你的包。如果你需要更新你的包，只需更新代码，修改版本号并再次运行npm publish命令即可。 请注意，当你发布npm包时，你的代码将被公开发布到npm上。因此，你应该小心保护敏感信息，并确保遵循最佳实践，以确保代码的安全性和稳定性。 npm包删除如果你想删除自己发布的npm包，可以在终端中使用以下命令： 请注意，删除一个包是不可逆转的，因此请确保你真正需要删除它，以避免造成不必要的损失。 其他注意事项： 删除已发布的npm包会破坏其他人对你的代码的依赖，因此在删除之前，请确保没有人正在使用你的代码，或者提供足够的警告时间，以便其他人可以切换到其他代码。 如果你已经发布了多个版本的npm包，则只能删除最新的版本，不能删除旧版本。 删除npm包需要管理员权限，因此你需要确保你的账户拥有管理员权限，才能删除你发布的包。 可能遇到的问题如果你执行 npm login 命令时出现错误，可能是以下几种情况之一： 检查你的npm账户是否已注册。如果你还没有npm账户，你需要先在npm的官方网站上注册一个账户。 检查你的网络连接是否正常。如果你的网络连接不稳定或者有问题，可能导致登录失败。 检查你的npm注册表是否正确。如果你要登录的是npm的私有注册表，确保你已经订阅了npm付费计划，以便可以创建一个私有注册表，并通过该私有注册表来发布私有包。 检查你的npm配置是否正确。你可以在命令行中运行以下命令，查看npm的配置信息： 确保你的 registry 配置是正确的。如果你要登录的是npm的私有注册表，确保你的 registry 配置是指向该私有注册表的。 如果你已经确认了以上的问题，并且你的 npm login 命令仍然失败，你可以尝试以下几种方法： 清除npm的缓存。你可以使用以下命令来清除npm的缓存： 清除缓存后，尝试再次登录。 检查npm的版本。确保你正在使用的是最新版本的npm。 如果你使用的是代理服务器，你可以尝试在命令行中设置代理服务器。例如： 将 yourproxy 替换为你的代理服务器地址，将 yourport 替换为你的代理服务器端口号。 如果你仍然无法成功登录，你可以查看npm的官方文档或者向npm的技术支持团队寻求帮助。 关于第四点，确认是否使用私有注册表的补充因为很多人使用的是国内淘宝镜像以至于npm login不成功，此时只需要改为官方镜像即可。 具体方法如下：要确认是否使用私有注册表，你可以检查你的npm配置文件。默认情况下，npm会将你的包发布到npm官方的公共注册表，而不是私有注册表。如果你要使用私有注册表，你需要订阅npm的付费计划，并创建一个私有注册表。在登录时，你需要使用该私有注册表的URL。 要检查你的npm配置是否指向私有注册表，可以运行以下命令： 如果输出的结果是私有注册表的URL，那么你正在使用私有注册表。如果输出的结果是默认的公共注册表URL（），那么你不是在使用私有注册表。 如果你确定你要使用私有注册表，但无法成功登录，那么可能是因为你的npm配置不正确。确保你已经在npm上订阅了付费计划，并创建了一个私有注册表。在登录时，你需要使用该私有注册表的URL，并提供正确的访问凭据。如果你仍然无法成功登录，你可以联系npm的技术支持团队，寻求帮助。 如何更改？你可以通过 npm config set 命令来更改npm的配置。例如，要将npm配置的注册表更改为私有注册表的URL，可以使用以下命令： 其中 &lt;your-private-registry-url&gt; 是你的私有注册表的URL。你需要将其替换为你的实际URL。 如果你想将npm配置恢复为默认设置，可以使用以下命令： 这将删除当前配置的 registry 选项，使npm使用默认的公共注册表。 发布一个私有的npm包 使用npm收费工具 如果你希望仅向付费用户提供访问权限，你可以使用npm的付费工具。你可以在npm网站上注册一个付费账户，创建一个收费组织，然后将你的包添加到该组织中。然后，你可以设置访问权限，仅允许那些已经付费的用户使用你的包。 使用npm访问令牌 另一种方法是使用npm访问令牌。你可以创建一个令牌，并将其授予仅限于你允许的用户。然后，你可以将该令牌用于安装你的包。只有持有该令牌的用户才能使用你的包。你可以在npm网站上创建一个访问令牌，并将其添加到你的项目中的.npmrc文件中。请确保令牌不被泄露，以避免未经授权的用户使用你的代码。 使用私有npm仓库（类似淘宝镜像源的服务器，但其实淘宝镜像源是公开的） 最后，你可以使用私有npm仓库。你可以在你自己的服务器上搭建一个npm仓库，并将你的包上传到该仓库中。然后，你可以设置访问权限，只有你允许的用户才能访问该仓库并安装你的包。你可以使用像Sinopia、Verdaccio等这样的开源工具来搭建私有npm仓库。 1、3都属于人民币玩家的方式，这俩方式就不说了 使用npm访问令牌第二种方法是使用npm访问令牌。你可以创建一个令牌，授予仅限于你允许的用户，并将该令牌用于安装你的npm包。以下是实现此目的的详细步骤： 首先，你需要在npm上注册一个账户。如果你还没有注册，请在上注册一个账户。 接下来，你需要创建一个npm访问令牌。你可以使用以下命令在终端中创建一个访问令牌： &lt;registry-url&gt;是指你要发布npm包的npm仓库的地址。例如，如果你要发布到npm官方仓库，那么这个值应该是。如果你要发布到私有仓库，那么这个值应该是你的私有仓库地址。 执行以上命令后，npm将提示你输入你的npm账户的用户名和密码。输入正确的用户名和密码后，npm将生成一个新的访问令牌，并将其输出到终端中。 将新生成的访问令牌添加到你的.npmrc文件中。.npmrc文件通常位于你的用户目录下。在.npmrc文件中添加以下内容： &lt;registry-url&gt;是你要发布npm包的npm仓库地址，&lt;access-token&gt;是你新生成的访问令牌。 将你的npm包发布到npm仓库。你可以使用以下命令将你的包发布到npm仓库中： &lt;registry-url&gt;是你要发布的npm仓库地址，可以是npm官方仓库或者私有仓库。 现在，只有持有你的访问令牌的用户才能访问和安装你的npm包。你可以将访问令牌授予你允许的用户，或者在需要时撤销该令牌的访问权限。 请注意，访问令牌是一个非常重要的凭证，因此你需要妥善保管它，不要将它泄露给未经授权的用户。如果你怀疑你的令牌已经被泄露，那么你应该立即撤销该令牌，并生成一个新的访问令牌。"},{"title":"【实用工具】Mitmproxy 抓包","date":"2023-03-24T03:49:42.000Z","url":"/2023/03/24/mitmproxy/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"什么是MitmproxyMitmproxy是一款基于Python开发的抓包工具，可以用于拦截、修改和重放HTTP和HTTPS流量。以下是使用Mitmproxy进行抓包的简单步骤： 安装和启动安装和启动Mitmproxy：你可以从Mitmproxy的官方网站（）上下载安装程序，并根据操作系统的不同进行安装。安装完成后，你可以通过在终端窗口输入“mitmproxy”命令来启动Mitmproxy。 配置设备代理配置设备代理：将设备的代理设置为Mitmproxy的IP地址和端口号（默认端口号为8080）。具体方法取决于你使用的设备和操作系统。例如，在iOS设备上，你可以通过“设置”&gt;“Wi-Fi”&gt;“当前连接的Wi-Fi网络”&gt;“代理”&gt;“手动”来进行配置。 开始抓包开始抓包：一旦你的设备代理已经配置好，Mitmproxy就会自动开始捕获HTTP和HTTPS流量。你可以在Mitmproxy的控制台中查看所有的请求和响应。你还可以使用一些Mitmproxy提供的快捷键，如使用“tab”键切换到请求/响应窗格，使用“e”键编辑请求，使用“w”键保存请求和响应等等。 导出数据导出数据：在完成抓包后，你可以将数据导出为不同的格式，例如HAR文件、PCAP文件或CSV文件，以便在其他工具中进行分析。 需要注意的是，抓包可能会涉及到隐私问题，请确保在合适的环境下使用该工具，并尊重他人的隐私。"},{"title":"【css】重排与重绘","date":"2023-03-22T03:21:30.000Z","url":"/2023/03/22/%E9%87%8D%E6%8E%92%E4%B8%8E%E9%87%8D%E7%BB%98/","tags":[["css","/tags/css/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"一、从输入url到渲染出页面的整个过程 dns解析： 域名—&gt;IP 浏览器根据IP地址向服务器发起http请求 服务器处理http请求，并返回给浏览器 根据HTML生成Domtree，根据Css生成cssom，再整合dom树和cssom整合的rendertree 根据render tree渲染页面 遇到script标签则暂停渲染，优先加载并执行js代码，完成再继续，直至渲染完成。 渲染：在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。 重排会导致重绘 重绘：某些元素的外观被改变，例如：元素的填充颜色 重排：重新生成布局，重新排列元素。 改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。 所以： 重绘不一定导致重排，但重排一定会导致重绘。 重排(reflow)：概念：当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 重排也叫回流，简单的说就是重新生成布局，重新排列元素。 下面情况会发生重排： 页面初始渲染，这是开销最大的一次重排 添加/删除可见的DOM元素 改变元素位置 改变元素尺寸，比如边距、填充、边框、宽度和高度等 改变元素内容，比如文字数量，图片大小等 改变元素字体大小 改变浏览器窗口尺寸，比如resize事件发生时 激活CSS伪类（例如：:hover） 设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。 常见引起重排属性和方法 – – – width height margin padding display border-width border position overflow font-size vertical-align min-height clientWidth clientHeight clientTop clientLeft offsetWidth offsetHeight offsetTop offsetLeft scrollWidth scrollHeight scrollTop scrollLeft scrollIntoView() scrollTo() getComputedStyle() getBoundingClientRect() scrollIntoViewIfNeeded() 重排影响的范围：由于浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种： 全局范围：从根节点html开始对整个渲染树进行重新布局。 局部范围：对渲染树的某部分或某一个渲染对象进行重新布局 全局范围重排： 当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。 局部范围重排： 用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。 重绘(Repaints):概念：当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 常见的引起重绘的属性： 属性： – – – color border-style visibility background text-decoration background-image background-position background-repeat outline-color outline outline-style border-radius outline-width box-shadow background-size 重排优化建议：重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。 减少重排范围我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。 尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。 减少重排次数1.样式集中改变不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 cssText 变量中编辑。虽然现在大部分现代浏览器都会有 Flush 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。 2.分离读写操作DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。 原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制： 当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。 3.将 DOM 离线“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做： 使用 display:none 一旦我们给元素设置 display:none 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 display属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，visibility : hidden 的元素只对重绘有影响，不影响重排。 通过 documentFragment 创建一个 dom 碎片,在它上面批量操作 dom，操作完成之后，再添加到文档中，这样只会触发一次重排。 复制节点，在副本上工作，然后替换它！ 4.使用 absolute 或 fixed 脱离文档流使用绝对定位会使的该元素单独成为渲染树中 body 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。 5.优化动画 可以把动画效果应用到 position属性为 absolute 或 fixed 的元素上，这样对其他元素影响较小。 动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多 启用GPU加速 GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。 GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。 在浏览器中查看页面渲染时间1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。如下图 蓝色: 网络通信和HTML解析 黄色: JavaScript执行 紫色: 样式计算和布局，即重排 绿色: 重绘 哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。 2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。如下图： 3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。 4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。"},{"title":"【杂七杂八】mac连接远程服务器","date":"2023-03-21T03:15:20.000Z","url":"/2023/03/21/mac%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"方法一：用终端登录终端输入命令： ssh -p 端口号 服务器用户名@ip 如：ssh -p 22 &#x72;&#x6f;&#x6f;&#x74;&#x40;&#49;&#49;&#x35;&#46;&#x31;&#48;&#x38;&#46;&#49;&#49;&#53;&#x2e;&#49; 回车，初次登录时输入yes确认是否连接 回车，输入密码 回车，登陆成功 方法二：用shell连接在终端中选择如下： 点击加号，添加自己的服务器ip，然后输入用户名，点击连接 输入密码就连接上了。 方法三：其他可视化工具如FileZilla等，输入主机IP、用户名、密码、端口号、点击连接。很快就连接上了。不具体说了。"},{"title":"docker的使用和简介","date":"2023-03-21T02:56:21.000Z","url":"/2023/03/21/docker%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%AE%80%E4%BB%8B/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"docker简介1：docker定义docker是一个用来装应用的容器，就像杯子可以装水，笔筒可以装笔，书包可以放书一样。你可以把“Hello World！”放到docker中，也可以把网站放到docker中，你可以把任何你想到的程序放到docker中。 2. docker目的docker的主要目标是”Build,Ship and Run any App,Angwhere”,构建，运输，处处运行构建：制作docker镜像，打包容器的所有系统目录文件运输：下载docker镜像运行：基于docker镜像提供的rootfs，启动容器总结：只要能运行docker容器，那么docker镜像中已经安装好的软件也可以运行，所以说docker是一种件的打包技术。 最重要的优点在与docke环境的高度一致性。 Docker与虚拟机的区别：容器时在linux上本机运行，并与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，非常轻量虚拟机运行的是一个完整的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。 3. docker的架构docker三个基本概念： 镜像（Image）：Build – 构建镜像 – [镜像 类比 集装箱]Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：Run – 运行镜像（运行的镜像就是一个容器）- [容器 就是 运行程序的地方]镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：Ship – 运输镜像（从仓库和我们的主机上运输）- [仓库 类比 超级码头]仓库可看着一个代码控制中心，用来保存镜像。 4. docker的运行流程 （1）docker pull:首先客户端client向Docker daemon发送命令docker pull，告诉Docker daemon要拉取哪个镜像，Docker daemon会先在本机检查这个镜像是否存在，如果存在并且版本一致，它不会做任何操作；如果不存在，它会到Docker的镜像仓库中寻找，如果找到了，就会把仓库中的镜像拉取到本地。 （2）docker run:客户端将docker run命令发送到Docker deamon中，Docker deamon会先检查这个镜像是否在本地已经存在，如果不存在，它会到仓库中寻找，把镜像下载到本地，下载之后它会通过一定的方式把镜像运行起来，变成docker容器 二、docker的安装采用yum安装方式，但由自己选择安装版本，需要自己安装docker-ce仓库。 1. 检查系统的内核版本，内核需大于3.10即可uname -r 2. 安装yum仓库管理工具yum-utilsyum -y install yum-utils 3. 安装docker-ce仓库1： 国内docker-ce仓库： 2：国外可直接用官方的docker-ce仓库： 安装后，在/etc/yum.repos.d/可以看到有了docker-ce.repo 文件，docker-ce仓库完成。 4. 查看docker版本并安装可直接安装，也可选择版本安装， 直接yum -y install docker-ce 安装，官方软件源默认启用了最新的软件。 查看版本，选择自己的想要版本安装。查看版本： 安装自己的版本号：docker-ce-[VERSION]，如上图中的docker-ce-3:20.10.7-3.el8安装如下： 安装完成，docker version可查看版本 三. docker的常用命令启动docker： 进入容器 docker run: 创建并启动一个新的容器。 例如： docker run nginx 将在一个新的容器中运行Nginx。 docker start: 启动已经存在的容器，让其重新运行。 docker stop: 停止正在运行的容器。 例如： docker stop container_name 将停止名为“container_name”的容器。 docker rm: 删除一个或多个容器。 例如： docker rm container_name 将删除名为“container_name”的容器。 docker images: 列出本地的Docker镜像。 例如： docker images 将列出本地存储的所有Docker镜像。 docker rmi: 删除本地的Docker镜像。 例如： docker rmi image_name 将删除名为“image_name”的本地Docker镜像。 docker pull: 下载一个Docker镜像，不包含容器。 例如： docker pull nginx 将下载最新版本的Nginx镜像。关于docker pull的更详尽的解释，请看下方其它补充 docker push: 将一个Docker镜像上传到Docker Hub。 例如： docker push username/image_name 将上传名为“image_name”的本地Docker镜像到Docker Hub上的用户名为“username”的仓库中。 docker inspect: 查看Docker容器的详细信息。 例如： docker inspect container_name 将显示名为“container_name”的容器的详细信息。 docker exec: 在正在运行的容器中执行命令。 例如： docker exec -it container_name bash 将在名为“container_name”的容器中打开一个Bash shell。 docker ps: 列出所有正在运行的容器。 例如： docker ps 将列出所有正在运行的容器的详细信息。docker ps -a列出所有正在运行的没在运行的容器。 docker search xxx: 选择安装的镜像，如docker search jenkins,会列出所有的jenkins镜像，然后使用docker pull [name] 安装。 删除镜像后还能在容器中安装镜像，具体的命令就跟容器命令一样，比如说我拉了docker run jenkins，它的容器是linux（这个自动生成的），然后rmi了镜像之后，可以使用shell命令在其中重新安装，就像在linux电脑里一样的。比如想安装apache的话，命令： 删除容器就要重新pull了。 其他补充：1. docker run的细节在一些情况下，Docker会自动完成拉取镜像、创建容器和启动容器的过程，具体取决于您使用的命令和Docker的配置。例如，如果您使用的是 docker run 命令，则Docker将自动完成以下操作： 如果本地不存在指定的镜像，则从默认的镜像仓库（例如Docker Hub）拉取该镜像。 使用指定的镜像创建一个新的容器，并启动该容器。 但是，如果您使用的是 docker create 和 docker start 命令，则需要手动完成这些步骤。 在任何情况下，Docker都会自动完成一些基本的设置和配置，例如创建容器网络、分配IP地址和端口等。但是，一些高级设置和配置可能需要手动完成，例如挂载主机文件、配置容器卷等。 因此，对于每个具体的使用场景，您需要仔细检查Docker命令和配置，并根据需要手动完成必要的步骤。 2. docker run和docker start当容器不存在时，docker run会拉取一个镜像（img）并创建一个容器（container）并运行，也就是说，docker run可以隐式包含docker pull 如果容器已经存在，docker run 和 docker start 也会有不同的作用。docker start 会启动一个已经停止的容器，它的运行时状态与停止之前一样，包括任何已经添加到容器中的文件或数据。docker run 则会创建一个新的容器，并在其中运行指定的命令或应用程序。如果使用的是同一个容器名称，docker run 将会重新创建一个新的容器，而不是启动原来的容器。因此，如果你想启动一个已经存在的容器，应该使用 docker start。如果你想要创建一个新的容器并运行一个新的命令，应该使用 docker run。 3. docker pull 的详尽解释在Docker中，一般的使用流程是先拉取镜像，然后使用镜像创建容器并启动。就是先pull再run。但实际上如果使用的是公共的 Docker Hub 镜像，dockder pull就不是必须的。但是在一些情况下，需要在本地预先拉取镜像，例如： 你需要从一个私有的 Docker Registry 拉取镜像，而该 Registry 可能需要身份验证或者在防火墙之后； 你需要将拉取的镜像进行修改或者自定义操作，然后再创建容器，而不是从 Docker Hub 直接拉取。 因此，在这些情况下，我们需要使用 docker pull 命令来拉取镜像到本地，然后再使用 docker run 命令来创建容器。 4. 如何使用 docker 拉取并运行私人镜像首先，你需要确保你能够访问这个私人镜像。如果这个私人镜像是托管在 Docker Hub 上的，则需要相应的权限。如果是自己搭建的私有镜像库，则需要配置相应的访问权限。 接下来，你可以在命令行中使用以下命令来拉取这个私人镜像： 其中 &lt;私人镜像地址&gt; 是私人镜像的地址，&lt;私人镜像名称&gt; 是私人镜像的名称，&lt;标签&gt; 是镜像的标签。 例如，如果你要拉取一个私人镜像地址为 myregistry.com，镜像名称为 abc，标签为 latest 的镜像，可以使用以下命令： "},{"title":"【移动端】自适应方案","date":"2023-03-20T09:53:43.000Z","url":"/2023/03/20/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%A1%88/","tags":[["css","/tags/css/"],["iv","/tags/iv/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"基本概念：设备独立像素（DIP）：逻辑像素，同樣嘅屏幕大小DIP都喺一樣嘅。物理像素（pt）：分辨率，屏幕一行同埋一列分别有幾多像素点leigaa。**设备像素比DPR(Device Pixel Ratio)**：DPR = 物理像素 / 设备独立像素，它通常与视网膜屏(Retina 屏)有关。 适配方案1. px + 自适应缩放（viewport）适用于设计给的设计稿只需要在各种屏幕等比缩放的情况。设置meta viewport的width为设计稿给出的width，使设计稿在不同屏幕上只需要自适应缩放。 如上，就是设计给的设计稿为750px，CSS单位使用px即可。 这个方法写法简便，设计稿是多少就写多少，开发速度很快。可能会有部分特别特别低版本的手机不兼容。这个方法有一个很大的缺点，就是缩放全局等比缩放，有些不想缩放的（比如部分1px边框、文字等）也会因为它的影响而等比缩放。 2. rem适配方案其实属于viewport的过渡方案，所以其实它和第一种viewport方案是一致的。只不过是早年对viewport的兼容性不好，所以早年是使用rem+js去实现自适应缩放。rem：‘The font size of the root element’，就是以根元素 的字体大小为基本单位，是一种相对单位。rem 适配的原理就是以 html 的 font-size 大小为基本单位来布局。em：另一种相对单位，它相对于该元素的本身的 font-size 值来计算。em是可以嵌套计算的，所以容易导致一些奇怪的问题。 假设屏幕750px，设置根元素为100px，即1rem=100px。那么24px的字体，就是0.24rem。在不同屏幕上的缩放就是实际屏幕大小/750px = 实际根元素字体大小/100px所以实际根元素字体大小 = 实际屏幕大小*100px/750px设置根元素100px是为了好计算，直接除以一百就算出来了。设置个奇奇怪怪的值当然也可以按这个比例算。就是可以但没必要~ 这个方法的兼容性很好，在遇到不想缩放的元素时，也可以用px进行设置。就是需要同时用js进行各个屏幕适配，比较麻烦。 3. vw、vh适配vh、vw方案：将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。vw(Viewport’s width)：1vw等于视觉视口的1%vh(Viewport’s height) :1vh 为视觉视口高度的1%vmin : vw 和 vh 中的较小值vmax : 选取 vw 和 vh 中的较大值 如果设计稿是750px宽度。如果视觉视口为750px，那么1vw = 1% = 7.5px，这时UI给定一个元素的宽为75px（设备独立像素），我们只需要将它设置为 75px / 750px = 10% = 10vw。就是酱紫拉~它和屏幕大小没啥关系的。就是百分比 4. 自动计算的插件实际开发过程当中，计算每一个dom元素的vw或者rem是很麻烦的，所以可以使用postcss-px-to-viewport去自动转换。 配置参数默认参数: unitToConvert (String) 需要转换的单位，默认为”px”viewportWidth (Number) 设计稿的视口宽度unitPrecision (Number) 单位转换后保留的精度propList (Array) 能转化为vw的属性列表viewportUnit (String) 希望使用的视口单位fontViewportUnit (String) 字体使用的视口单位selectorBlackList (Array) 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。minPixelValue (Number) 设置最小的转换数值，如果为1的话，只有大于1的值会被转换mediaQuery (Boolean) 媒体查询里的单位是否需要转换单位replace (Boolean) 是否直接更换属性值，而不添加备用属性exclude (Array or Regexp) 忽略某些文件夹下的文件或特定文件，例如 ‘node_modules’ 下的文件landscape (Boolean) 是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape)landscapeUnit (String) 横屏时使用的单位landscapeWidth (Number) 横屏时使用的视口宽度 当然，less、sass也有对此自定义解决的方案，可以自行查看文档。 5. Viewport 方案（推荐） 由于 viewport 单位得到众多浏览器的兼容，lib-flexible 这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用 viewport 来替代此方案。 vw 适配方案的流程： meta 标签设置 viewport 宽度为屏幕宽度； 开发环境配置 postcss-px-to-viewport 或者类似插件； 根据设计稿写样式，元素宽高直接取设计稿宽高即可，单位为 px，插件会将其转换为 vw； 段落文本也按照设计稿写，单位为px，不需要转换为 vw；6. media媒体查询有时候用户需要的更大的屏幕上更多的内容，而不是更大的字，所以在pc、平板一侧主要用到的兼容方式是media媒体查询。 使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。 你也可以针对不同的媒体使用不同样式文件 : 因为这里主要讨论的是移动端，所以media媒体查询的用法不详述了。"},{"title":"【grid】简单总结","date":"2023-03-15T10:04:24.000Z","url":"/2023/03/15/cxy/css/grid/","categories":[["css","/categories/css/"]],"content":"一、易记点整理父： 子： 属性关键字： auto-fill 和 auto-fit 的区别auto-fill和auto-fit都是CSS的repeat()函数的扩展值，用于自动填充和调整网格项目的数量。 auto-fill会自动填充网格容器，尽可能多地填充项目，而不考虑项目的大小。它会在一个网格轨道上放置尽可能多的项目，然后通过增加网格行或列来添加更多项目。这意味着它会在网格轨道上尽可能多地放置项目，直到没有更多项目可以放置为止。因此，它可以在轨道中留下一些空间，因为不会强制填充整个轨道。 例如，如果我们有一个网格容器和一个项目，这个项目的大小是200像素，我们使用auto-fill并设置每个轨道的大小为250像素，那么这个项目将占用整个轨道，因为它可以在轨道上放置一个完整的项目。 auto-fit会调整网格项目，以使网格填满容器，而不考虑项目的数量。它会在网格轨道上放置尽可能多的项目，但如果剩下的空间不能容纳一个完整的项目，它将缩小项目的大小，以使它们适合空间。这意味着它会填充整个轨道，因此不会在轨道中留下空间。 例如，如果我们有一个网格容器和一个项目，这个项目的大小是200像素，我们使用auto-fit并设置每个轨道的大小为250像素，那么这个项目将被缩小，以适合轨道，并留下50像素的空间。 因此，auto-fill和auto-fit的区别在于它们处理空间的方式不同。auto-fill会填充整个轨道，但是可能留下一些空间，而auto-fit则会完全填充整个轨道，但可能会缩小项目的大小来适合空间。 二、 grid布局(1) 基本使用 上面代码意思是三行三列的布局，行宽100px，高100px，也可以使用百分比 也可以这么简写： repeat() 函数有两个参数，第一个是重复的次数，第二个是具体数值 三、容器属性：(2) auto-fill有时候，单元格大小固定，而容器大小不一定，可以用auto-fill指定一行/列尽可能放入更多的元素 (3) frgrid布局为了方便表示比例，引入fr，如果一个设置1fr，一个设置2fr，那后者就是前者的两倍 上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。 (4) autoauto参数表示由浏览器自动决定宽高 (5) 行和列的线可以自己命名，用[名字] 网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 (6) 设置行与行、列与列的间距grid-row-gap 与 grid-column-gap，行与列的间距。grid-gap: grid-row-gap 与 grid-column-gap的简写，两个值。格式：grid-gap: 行 列根据最新标准，grid-row-gap、grid-column-gap的新写法是去掉grid-前缀。 (7) grid-template-areas可以给各个网格取名，如果不需要利用该网格，则用.代替 可以给各个网格取名，如果不需要利用该网格，则用.代替 (8) grid-auto-flow子元素按照顺序自动放置在网格内，默认先行后列，设为列的话 (9) justify-items align-items值为start center end strech(拉伸占满整个容器，如果有设置width或height则对应拉伸失效) (10) justify-content align-content设置整个内容区域在容器里面的水平位置(左中右) 四、容器内部的元素属性(1) grid-column-start grid-column-end grid-row-start grid-row-end设置某个子元素在第几个网格线内 子元素在横向第二根网格线，竖向倒数第一根网格线内。 (2) grid-area，设置某元素在某个单元格中 (3) justify-self align-self place-self和父元素的justify-items align-items 一致。只不过一个设置在父元素上，作用于所有子元素。一个是设置在子元素上，只对单个子元素有效。 place-self用来同时设置justify-self align-self，简写justify-self align-self"},{"title":"【flex】简单总结","date":"2023-03-15T10:02:02.000Z","url":"/2023/03/15/cxy/css/flex/","categories":[["css","/categories/css/"]],"content":"一、容器属性1. justify-contentflex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 2. align-itemsflex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3. flex-flowflex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 4. flex-wrap 换行nowrap（默认）：不换行。wrap：换行，第一行在上方。wrap-reverse：换行，第一行在下方。 5. align-content多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 6. flex-directionrow（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 二、子元素属性1. order 排列顺序数字 2. flex-grow 剩余空间的项目放大比例数字越大拉伸越严重 2. flex-shrink 剩余空间的项目缩小比例数字越大压缩越严重 3. flex-basis 分配剩余空间前，该子元素的占据比例。优先级高于flex-grow和flex-shrink 4. flex2/3/4的简写 5. align-self子元素的默认对齐方式"},{"title":"react-hooks","date":"2023-03-14T09:11:14.000Z","url":"/2023/03/14/cxy/framework/react/react-hooks/","categories":[["undefined",""]],"content":"一、基本介绍react是基于数据是不可变的（每次setState都会返回一个新数据），这也是为什么需要setState()来更新数据而不能使用像vue的this.state = newState的形式更新数据的原因，其实你用this.state=newState确实可以改数据，但是react不知道数据变了。 二、useMemo、useCallback的执行时机对比useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。 三、useEffect 和 useMemo 区别useEffect是在DOM改变之后触发，useMemo在DOM渲染之前就触发useMemo是在DOM更新前触发的，就像官方所说的，类比生命周期就是[shouldComponentUpdate]useEffect可以帮助我们在DOM更新完成后执行某些副作用操作，如数据获取，设置订阅以及手动更改 React 组件中的 DOM 等不要在这个useMemo函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo在useMemo中使用setState你会发现会产生死循环，并且会有警告，因为useMemo是在渲染中进行的，你在其中操作DOM后，又会导致触发memo 三、useMemo可以把它理解成vue里面的computed，是一种数据的缓存，而这个缓存依赖后面的第二个参数数组。 如果页面上展示的数据是通过某些state计算得来的一个数据，那么你每次这个组件里面无关的state变化引起的重新渲染，都会导致这个数据重新计算。 这时候就需要用useMemo(()=&gt;&#123;&#125;, [])去包裹你的计算的方法体，这样那些无关的state改变引起的渲染不会重新计算这个方法体，而是返回之前计算的结果，达到一种缓存的效果。 四、useCallbackuseCallback跟useMemo比较类似，但它返回的是缓存的函数。 使用场景：有一个父组件，其中包含子组件，子组件接收一个函数作为props；通常而言，如果父组件更新了，子组件也会执行更新；但是大多数场景下，更新是没有必要的，我们可以借助useCallback来返回函数，然后把这个函数作为props传递给子组件；由于useCallback返回的函数实例在第二个参数，也就是依赖项未发生变化时不会被重新创建，因此，每次父组件的更新不会导致子组件内部的函数实例发生变化。这样，子组件就能避免不必要的更新。 useCallback一般要配合React.memo来使用：react的Hooks组件对props的浅比较是在memo里面比较的（类组件是在shouldComponentUpdate里面），如果没有memo，那么你使用useCallback就没啥意义，反而浪费性能（因为useCallback来包裹函数也是需要开销的）。因为子组件还是会重新渲染。 React.memo与useMemo的区别和联系在React的组件中，如果子组件没有被React.memo包裹，或者没有使用useMemo来处理props传递参数，那么当父组件的任何值更新时，整个组件都将会进行重新渲染，包括父组件下面的所有子组件。多数情况下对于子组件来说没有必要。毕竟不是父组件的每一次更新都需要修改子组件的值，而频繁的更新却会导致不需要更新的子组件被迫更新，造成资源的浪费。针对上述问题，React提供了React.memo和useMemo。 React.memo：React.memo()本质是一个高阶组件（HOC），高阶组件和高阶函数类似，高阶函数是接收一个函数，然后经过一些判断和处理后再返回这个函数。对应到高阶组件，就是接收一个组件，然后经过一些判断和处理后再返回这个组件。再回归到React.memo(), 这个高阶组件接收一个组件A作为参数并返回一个组件B，如果组件B的props没有改变，则组件B会阻止组件A重新渲染。A和B本质上是同一个组件，但A是否进行重新渲染，需要由Props是否发生改变来决定。 useMemo：React提供的一个hook函数，他不是高阶组件。使用useMemo定义的变量，只会在useMemo的第二个依赖参数发生修改时才会发生修改。使用useMemo时，应保证第一个参数函数里所使用的变量都出现在第二个依赖参数数组中，这样可以避免一些额外的错误。 "},{"title":"typescript总结笔记(2)","date":"2023-03-08T11:24:13.000Z","url":"/2023/03/08/cxy/js/typescript2/","tags":[["typescript","/tags/typescript/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、函数类型表达式描述函数可以使用函数类型表达式。格式： 比如在接口中使用 或使用类型别名（type）定义一个函数类型 调用签名由于在js中，函数不仅可以被调用，函数本身也可以具有属性值。用函数类型表达式无法支持声明属性，这时候可以使用调用签名格式： 具体应用： 构造签名即，使用new Function时的用法，构造函数。说实话，我没看太懂 泛型函数定义一个函数，返回数组的第一个元素。由于数组的类型不一定，用any没有用泛型好。泛型和强制类型转换都是尖括号&lt;&gt;，泛型放在变量后，强制类型转换放在变量前。 二、对象类型三、泛型 四、工具类型1. Partial构造一个类型，所有的属性均为可选。 2. Required构造一个类型，所有的属性均为必选 3. Readonly构造一个类型，所有的属性均为只读 4. Record&lt;Keys, Type&gt;构造一个类型，它的所有key是Keys类型，所有value是Type类型 5. Pick&lt;Type, Keys&gt;构造一个类型，保留Type中的Keys属性。 6. Omit&lt;Type, Keys&gt;构造一个类型，从Type中过滤掉Keys属性 7. Exclude&lt;UnionType, ExcludedMembers&gt;构造一个类型，从UnionType中排除所有可以赋给ExcludedMembers的类型。其中UnionType和ExcludedMembers都是联合类型。 8. Extract&lt;Type, Union&gt;构造一个类型，从Type中提取所有可以赋给Union的类型"},{"title":"【vue3】总结","date":"2023-02-27T10:16:25.000Z","url":"/2023/02/27/cxy/framework/vue/vue3/","tags":[["vue","/tags/vue/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" Vue3和Vue2的区别 Vue3支持2的大多数写法 更好的支持Typescript 使用Proxy代替了defineProperty 重写了虚拟dom的实现，及Tree Shaking的实现。 从Option api变成Composition api setup ref和reactive computed和watch provide和inject 生命周期的更改 新组件 Fragment Teleport Suspense 其他 全局api的修改 原来的全局api转移到应用对象 模板语法修改 一、新建 或 二、Composition API（组合式API）和Options API1. Composition API带来了什么？ 代码组织的更加整齐 逻辑复用做的更加清晰 更好的类型推导 composition api可以将声明的变量和方法等放在一起，这样会使代码更整齐，也方便逻辑复用。 2. 如何选择？ 最好不要共用Options API和Compositions API 小型项目就用Options API，逻辑复杂用Composition API Compositon API 就像 Hooks在React 三、 组合式api1. refref用来定义基本数据类型的响应式。 备注：ref也可以用来定义对象或数组类型数据，它内部会自动通过 reactive 转为代理对象。 在setup中使用value去获取值，在vue模板中直接使用变量名去获取。 ref 可以用来获取dom元素在dom上绑定ref=xxx，在 setup 中定义 xxx就是dom元素。当然，绑定在组件上就可以获取组件的元素和方法。 2. reactivereactive用来定义多个对象的响应式。 3、reactive和ref的区别3.1. 定义数据角度对比：ref 用来定义：基本类型数据reactive 用来定义：引用类型，例如对象、或数组类型的数据 3.2. 原理角度对比：ref通过 Class 的 get 与 set 来实现响应式的（数据劫持）reactive 通过使用 Proxy 来实现响应式（数据劫持），并通过Reflect 操作源对象内部的数据。 3.3. 使用角度对比：ref 定义的数据：操作数据需要 .value,读取数据时模版中直接读取不需要 .valuereactive 定义的数据：操作数据与读取数据，均不需要 .value 3.4. reactive和ref的关系如果用ref对象/数组，内部会自动将对象/数组转为reactive的代理对象。 5. setup5.1. setup的执行时机在vue2的beforeCreate的生命周期之前执行，且只执行一次。setup执行时，当前组件未创建，所以没有this 5.2. setup(props,context)setup函数的第一个参数为props，props不可以解构，如果解构会导致props失去响应式。setup函数的第二个参数为context，context可以解构，解构后为 即： 或者： 都是ok的。在中，引入defineProp使用props 6. computed 7. watchwatch有三个参数，第一个是监听的变量。（如果有多个变量想同时监听，可以使用数组）第二个是函数，可以监听到旧值与新值。第三个参数可以配置deep、immediate等 8. watchEffect立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。第一个参数是一个方法，方法的参数可以用来清理无效的副作用，清理回调会在该副作用下一次执行前被调用。第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。 flush的值默认情况下，侦听器将在组件渲染之前执行。 设置 flush: &#39;post&#39; 将会使侦听器延迟到组件渲染之后再执行。在某些特殊情况下 (例如要使缓存失效)，可能有必要在响应式依赖发生改变时立即触发侦听器。这可以通过设置 flush: &#39;sync&#39; 来实现。（该设置应谨慎使用，因为如果有多个属性同时更新，这将导致一些性能和数据一致性的问题。） 所以它经常被用来： 观察反应变量的变化 允许开发者执行副作用 提供一种取消副作用的方法（以防状态无效）watch和watchEffect之间的区别： watch可用于延迟触发副作用（watchEffect总是立即的）。 watchEffect自动监视任何状态更改的更改（watch必须提供一个或多个要监视的变量）。 watch提供对当前值和先前值的访问。 watch也可以用来监听非响应式的数据，但写法比较麻烦。 vue3 的 hooks（vue2的mixin）vue3在共享数据的时候，用的是hooks的方法。比如我想实现一个方法，在鼠标移动时去获取鼠标的坐标定义一个js/ts模块，封装useMousePosition 在某个vue组件中，直接用引入的方式调用 9. toRefstoRefs 可以将每一个响应式对象变为一个普通对象，该普通对象的每一个property都是一个ref。 toRefs解决问题的场景：使用reactive去定义响应式对象的时候，如果对象层级较多，写起来会显得不简洁，而如果使用...解构赋值的话，对象的属性又会失去响应式。 为了解构赋值的时候不失去响应式，可以使用toRefs将响应式对象内部的所有变量变成响应式的。 不过这种方式现在在script setup中基本没有好的实现方法，只能在setup()里面用用。。 10. toRef()toRef(obj,&#39;propname&#39;)可以将reactive的某一个属性转换为Ref 11. isRef()检查某个值是否为ref 四、组合式api 进阶1. shallowReactive和shallowRefshallowReactive包装对象，只让对象的第一层有响应。shallowRef包装对象，是生成一个非响应式的对象，就是说将对象重新赋值是可以有响应式的，但为对象的任意属性赋值都是没有响应式的。（可是就我自己实验观察。。好像ShallowRef也可以触发第一层的响应）shallowRef包装基本类型，和Ref用法一样。shallowRef官网的例子 shallowReactive 官网的例子 因为有疑惑，所以自己的代码先不贴了。 2. triggerRef()强制触发依赖于一个浅层 ref 的副作用，这通常在对浅引用的内部值进行深度变更后使用。 3. readonly、shallowReadonly、isReadonlyreadonly()接受一个对象 (不论是响应式还是普通的) 或是一个ref，返回一个原值的只读代理。只读代理是深层的。 readonly() shallowReadonly只有表层是只读的isReadonly判断某个变量是不是只读的 shallowReadonly 4. toRaw() markRaw()toRaw 把代理的响应式对象变为了普通对象 markRaw 将一个对象标记为不可被转为代理。返回该对象本身。 5. customRef()创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。myRef接收一个值，返回customRef函数的执行 结果，这个函数接收2个参数，一个track（追踪）,一个trgger(触发)。返回一个存储器对象，有个get和set方法，取值时执行get,赋值时执行set。 官网写了一个防抖的例子。 6. Fragment（碎片）和Teleport（瞬移）Fragment：vue3不需要根标签了。Teleport：让组件的html可以在父组件外的特定标签下面插入展示。（比如body） 用 标签将子组件内的一部分内容包裹，那么这部分内容就会在body中展示。 7. Suspense比如页面里面要做一些异步操作，或者说调一些异步组件，这时候可能会出现等待的情况，那么在等待过程中，可以使用suspense渲染一些后备内容。"},{"title":"【复习整理】vue生命周期","date":"2023-02-07T03:30:34.000Z","url":"/2023/02/07/vue-smcq/","categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、vue2的生命周期vue生命周期分别有创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载利用钩子函数完成对应的项目效果 beforeCreate( 创建前 )在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据 created ( 创建后）在实例创建之后使用，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。完成了data 数据的初始化。因为未挂载，所以el不可用。 可以使用数据，更改数据，在这里更改数据不会触发updated函数。 beforeMount (挂载前)在挂载开始之前被调用,在这个阶段是获取不到dom操作的,把data里面的数据和模板生成html，完成了data等初始化,注意此时还没有挂在html到页面上 mounted (挂载后)用于挂载之后使用，这时 el 被新创建的 vm.$el 替换了。在这个时候可以获取到dom操作，也可以通过vm.$el获取元素。比如可以获取到ref等，操作dom，在这个时候只能调用一次ajax，在这个时候el和data都可以获取的到注意这个不能保证所有子元素挂载完成了！vm.$el：vue实例使用的dom根元素。 beforeUpdate (更新前)在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。 updated (更新后)在由于数据更改导致地虚拟DOM重新渲染并更新完毕之后会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，但是在服务器端渲染期间不被调用，可以用于监听某些数据的时候使用钩子 beforeDestroy（销毁前）实例销毁之前调用。在这一步，实例仍然完全可用。可以用于销毁计时器时候使用，为了防止跳转到其它页面该事件还在执行，还可以清除dom事件等 destroy（销毁后）实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。 activated被 keep-alive 缓存的组件激活时调用。 deactivated被 keep-alive 缓存的组件失活时调用。 二、vue3的生命周期大多相同，只是将beforeCreate和created合并成了setup，并且新增了renderTracked与renderTriggered，并且将destroy和beforeDestory改成了unmounted和beforeUnmounted renderTracked在一个响应式依赖被组件的渲染作用追踪后调用。这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。 renderTriggered在一个响应式依赖被组件触发了重新渲染之后调用。这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。 serverPrefetch当组件实例在服务器上被渲染之前要完成的异步函数。 Vue2————–vue3beforeCreate -&gt; setup()created -&gt; setup()beforeMount -&gt; onBeforeMountmounted -&gt; onMountedbeforeUpdate -&gt; onBeforeUpdateupdated -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed -&gt; onUnmountedactivated -&gt; onActivateddeactivated -&gt; onDeactivatederrorCaptured -&gt; onErrorCaptured 父子组件生命周期的调用顺序created：先初始化父组件，再初始化子组件mounted：先渲染子组件，再渲染父组件beforeupdated：先调用父组件，再调用子组件updated：先更新子组件，再更新父组件beforedestroy：先调用父组件，再调用子组件destroy：先调用子组件，再调用父组件 实测的图"},{"title":"【复习整理】sass简单整理","date":"2023-02-05T17:28:59.000Z","url":"/2023/02/06/cxy/css/sass/","categories":[["css","/categories/css/"]],"content":" 思维导图： 一、css拓展功能1. 嵌套规则Sass 内层的样式可以将它外层的选择器作为父选择器 编译为 2. 父选择器（&amp;） 编译为 3. 属性嵌套（：） 编译为 4. 占位符选择器（%foo）4.1 @extend比如，你有一些按钮需要设置样式。这些按钮都具有相同的特征，只是每个按钮的颜色不同。你可以创建一个 .button 类以包含按钮的所有通用代码，然后为每个类创建额外的类，为了添加背景颜色之前扩展 .button 类。 4.2 占位符选择器写法和class(.)以及id(#)是一致的，但前面的符号为%，必须配合@extend使用。它取代以前 CSS 中的基类造成的代码冗余的情形，因为 %placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码， 编译后： 5. 注释/* */与 //没啥说的多行注释会被完整输出到编译后的文件，单行注释则不会。 6. SassScript6.1 Interactive Shell用来测试SassScript的功能，在命令行中输入sass -i燃弧输入想要的测试SassScript查看输出结果 6.2 变量$ 变量有块级作用域，如果想转换为全局作用域，需要添加!global声明 编译为： 6.3 数据类型sass支持6种（喵？）数据类型 数字，1, 2, 3, 10px 字符串，&quot;foo&quot;, &#39;bar&#39;, baz 颜色，blue，#04a3f9 布尔，true，false 空值，null 数组，$list: (1.5em 1em) 或$list: (1.5em, 1em)，可以去掉括号 maps，相当于object，(key1: value1,key2: value2) 6.4 运算+ - * / %颜色也可以运算 6.5 函数sass提供了一些函数，详细看文档吧。 6.6 自定义函数 6.7 插值语句 #{}想要在选择器中使用变量的话，就可以使用插值语句。 6.8 type-of()检测数据类型可以使用type-of()检测变量的类型 7. 指令7.1 @import@import “foo.scss” 8. 控制指令8.1 @if @else if @else 编译为： 8.2 @for@for from through@for from to from…through 与 from…to 的区别: from 1 through 3 表示1/2/3from 1 to 3 表示 1/2，不包括3 8.3 @each@each in 编译为 九、输出格式1. 命令sass :style option或sass --style option 2. 常用的style值:nestedNested （嵌套）样式是 Sass 默认的输出格式，能够清晰反映 CSS 与 HTML 的结构关系。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。当阅读大型 CSS 文件时，这种样式可以很容易地分析文件的主要结构。 :expandedExpanded 输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。 :compactCompact 输出方式比起上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。 :compressedCompressed 输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。 "},{"title":"ChatGPT初探","date":"2023-01-27T06:10:51.000Z","url":"/2023/01/27/cxy/other/chatgpt/","tags":[["实用开源代码or工具","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81or%E5%B7%A5%E5%85%B7/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"],["生活","/categories/%E7%94%9F%E6%B4%BB/"]],"content":" ChatGPT官方说明： Optimizing Language Models for Dialogue We’ve trained a model called ChatGPT which interacts in a conversational way. The dialogue format makes it possible for ChatGPT to answer followup questions, admit its mistakes, challenge incorrect premises, and reject inappropriate requests. 我们训练了一个叫做ChatGPT的模型，它以对话方式进行交互。 对话格式使ChatGPT能够回答后续问题、承认错误、质疑不正确的前提和拒绝不适当的请求。 ChatGPT能做什么？我自己是随便玩了一下 写脚本 “帮我写一段nodejs发送邮件的脚本吧” 答： 写信（不太靠谱） “你朋友的手机摔坏了，写一封信安慰他吧” （ai是比我大方的） “你把朋友的手机摔坏了，写一封信安慰他吧” 你这样说话不会被揍么。。。 还有很多其他的食用方式，自己去探索拉~ vscode插件 使用该插件可以直接在vscode与chatGPT交互，相当于连接到官方web网页，这样子如果提问的是代码，那么程序员就可以快速发现代码的问题（因为我实测发现chatGPT现在写出来的代码是多多少少有问题的） 相关链接chatgpt: 点击访问openai api key:点击访问"},{"title":"【vscode】vetur插件在vue3中报错","date":"2022-12-30T03:31:49.000Z","url":"/2022/12/30/cxy/other/vscode-vetur/","tags":[["开发效率","/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" vetur是vue2支持的插件，volar(vue language features)可以支持vue3。可以直接搜索安装然后禁用vetur，重启vscode即可。 如果不想禁用vetur，又想启用volar，可以在当前项目中的.vscode文件夹的settings.json文件中配置禁用如下： 重启即可。"},{"title":"【blender】blender+pr，做史上最便宜的全息投影","date":"2022-12-25T08:23:04.000Z","url":"/2022/12/25/jianmo/bl-qxty/","tags":[["blender","/tags/blender/"],["pr","/tags/pr/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 做了一个模型嘿嘿嘿~然后本来说是想做动态捕捉的虚拟人物 做好了之后。。喝口水的功夫突然想到，诶可以拿水瓶儿做全息投影什么的！ 于是就又用pr剪好了视频，然后做了投影嘿嘿嘿具体原理就是下面酱紫~ "},{"title":"随便画画","date":"2022-11-26T10:23:38.000Z","url":"/2022/11/26/paint/paint-picture5/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 下载了一个叫画吧的软件，在里面画了一张西红柿唔，软件不太好用呢~全程不好开压感的。而且笔有延迟，幸亏只是画一个西红柿。延迟还挺严重。有点劝退。不知道有没有人一起什么的。。。。/ "},{"title":"【人像】好久不画人像了","date":"2022-11-24T05:23:38.000Z","url":"/2022/11/24/paint/paint-picture1/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 小练一下素描~过程录屏在微信视频号中 "},{"title":"【prettier】vscode + prettier自动格式化","date":"2022-11-21T15:11:49.000Z","url":"/2022/11/21/vscode-prettier/","tags":[["babel","/tags/babel/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 1. 搜索并安装prettier，并确定该插件是启用状态 2. 在项目中安装prettier 3. 在项目根目录新建.prettierrc和.prettierignore文件 .prettierrc: 配置格式化规则，如以下配置 .prettierrc更多的配置内容可以点击这里 .prettierignore: 配置不需要格式化的文件，如下： 4.打开vscode的setting(快捷键command+,)，搜索Format，并勾选Editor: Format On Save 5. 随便打开一个项目中的js文件，右键，点击使用…格式化文档 6. 在顶部点击配置默认格式化程序…，选择Prettier 配置完成，改动文件并保存就可以生效了。"},{"title":"【blender】着色器基础","date":"2022-11-11T07:21:08.000Z","url":"/2022/11/11/jianmo/bl-zhuoseqi/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 着色器部分国内文档太少，这段时间翻了很久的国外文档，请教了几位油管及discord大神，自己也做了不少东西后做出的总结。 不同颜色节点的含义首先，着色器节点固定从左向右流动。绿色节点：着色器本身如各类bsdf黄色节点：颜色信息如：基础色、次表面色表面并不是一定只能连接一个颜色。新建一个平面，切换到shading，新建一个材质槽。shift a新建一个图像纹理，添加一张图片，连接到bsdf的基础色，就可以将这张彩色图片的颜色信息显示在平面上。（其实可以直接拖进去，但不知道为什么自从我更新了3.3我就再也拖不进去了。）灰色节点：值，bsdf的很多设置都是值着色器上的值与颜色一样，很多时候表面是不想用同一个值来设置所有位置的。如糙度，很多情况下表面的材质并不是同一糙度，所以这时候需要一张描述表面糙度的图，通过0（黑色）至1（白色）之间的值，使用黑白或灰度着色，将值映射到不同的表面位置。即：pbr贴图中的粗糙度文件。如以下这张就是一张粗糙度描述图片，它黑色的地方表示完全不粗糙（0）白色的地方表示粗糙度满点（1），其余灰色的地方，灰色越深，越接近于零，也就越不粗糙。 如图，将上面的粗糙度文件连接至糙度后，可以看到表面有不同程度的粗糙纹理。紫色节点：矢量信息。 蓝色节点：表示属性，多和几何节点结合使用，不属于这里的讨论范围。 当然，不同颜色节点之间可以互相转换，只是会丢失读取不出来的信息。将粗糙度图片连接到黄色节点，如基础色，由于粗糙度图片只有黑白灰的值，基础色无法读出其他颜色信息，所以无法显示彩色。次表面：光穿透过表面后，在其下方散射发生的情况。最常见的就是人体皮肤。 透射&amp;&amp;投射粗糙度透射：决定多少光可以通过材料，而不是从材料反射光。透射值越大，透过材料的光越多。透射粗糙度：透射光的粗糙度，只有cycles下可以使用，且分布为GGX。说简单点儿，透射粗糙度的高低差别就是镜面玻璃和磨砂玻璃的区别。 自发光（发射）：从材料实际发出的光，拥有自己的颜色和强度。alpha：材料透明度。 以上这些值都是可以通过为不同位置传入不同的值来做不同的设置，就如同上述说的粗糙度设置。 法向：用于法线贴图，在不用更改网格几何形状的情况下，伪造材质的深度与阴影。 ##着色器节点 不多叙述，分为表面着色器和体积着色器两类。原理化bsdf着色器理论是可以做出所有表面着色器的效果。但使用其他的表面着色器可以更快捷的实现想实现的效果。比如玻璃、透明、半透、毛发等。以玻璃bsdf举例 折射率：当bsdf为玻璃或半透明时，物体内部可以进行折射，折射的情况就由ior设置。水、不同厚度的玻璃、塑料瓶都有不同的折射率。粗糙度：物体表面粗糙度越高，越不容易进行折射。而这两个参数都是可以在原理化bsdf中进行设置，所以理论上来说原理化bsdf可以实现玻璃的效果，但使用玻璃bdsf来制作单纯的玻璃会更加的便捷。 体积着色器可以连接至体积输出，有原理化体积、体积散射、体积吸收。原理化体积理论上是可以实现体积散射和体积吸收，且可以综合二者进行设置，但直接使用体积散射和体积吸收可以更快捷的实现对应的效果。体积吸收：表示光线穿过物体时，体积会吸收光线体积散射：更接近于雾的效果，通过体积散射，光会撞击物体体积并进行反弹。 体积着色器经常用于实现一些场景的烟雾、或者表现场景的空气透视感时会很常用。如下面这张我建立了两个立方体，对外层大一些的立方体使用了体积散射，在两边设置了两个不同颜色的光源，就会有这种透光的烟雾效果。我做的这张小场景的练习，为了表现出远处的空气透视感，也在中间加了一个体积散射的平面。 体积bsdf的实际运用也可以和噪波纹理相结合，生成不同形状的烟雾，也可以用噪波纹理增加噪点等效果。 混合bsdf：现在我将两个原理化bsdf使用混合bsdf连接，混合bsdf拥有上下两个叫混合器的插槽和一个系数插槽。我将红色bsdf放在下面的混合器插槽，蓝色bsdf放在上面的混合器插槽，若系数为0.5，即上下着色器等比混合，正常情况下物体表面应该为紫色。如下图系数越大，混合结果越偏向于下面的着色器。 若混合bsdf系数给一个灰度描述，如马氏分形纹理，那么表面就会因为不同的系数而做不同的着色器显示。将顶部着色器放在有黑色的地方（0），将底部着色器放在有白色的地方（1）。而灰色的地方进行两个着色器颜色的混合 ##纹理节点blender自带的一些材质节点，可以根据不同材质节点生成不同的灰度纹理。 以马氏分形纹理做简单说明简单说一下3d和4d的区别，4d比3d多了一个w值，w可以使纹理随时间推移改变w，一般用于设置动画。（按i可以设置关键帧，或在节点上右键 - 插入关键帧）如果将纹理直接连接着色器的基础色，那么就是灰度显示，因为材质节点本质就是生成不同位置的灰度信息。如果想让其显示彩色，可以连接一个colorRamp，也就是渐变 沃罗诺伊纹理是一种很常用的纹理，可以生成漂亮的图案及形状。就我个人而言，连接颜色时感觉很像一堆马赛克做了变换的纹理 其他像砖墙纹理、棋盘格纹理就不再多说，纹理与纹理可以相互连接，组合生成不同的有意思的图案，需要多加尝试。除了纹理与纹理之间相互连接外，还有另一种方法，使用mixRgb（混合rgb）混合rgb与混合着色器的使用方法相当像，区别是混合rgb用于颜色输出，而混合着色器用于着色器输出。混合rgb可以控制灰度的信息，所以当两个纹理连接到混合rgb时，可以通过混合rgb去控制两个纹理的强弱。混合方式可以点击自己调节，不详细介绍了，如果用过ps应该是熟悉的。 还有一些不太常用于着色器表面信息的纹理节点，比如ies纹理（用于描述灯光）环境纹理（用于描述环境）等，之后我会再整理。 ##如何将纹理映射到对象上？与几个节点息息相关。 纹理坐标节点：用不同方式告诉纹理如何在blender中进行映射，不同的用途可以有不同的输出。常用的两个是物体和生成，生成是默认的形状，物体适合生成程序化的纹理。 映射节点，可以调节纹理的位置、旋转和缩放 运算节点，可以使两个值做对应运算 "},{"title":"blender三渲二","date":"2022-10-25T19:21:02.000Z","url":"/2022/10/26/jianmo/bl-sanxuaner/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 听说了灌篮高手剧场版上映后，看片花知道是三渲二做的。不太喜欢三渲二的效果，但还是想自己尝试一下。 怎么说呢。。就是三渲二实际上也只是搭个架子，内部的阴影结构明暗交界线什么的要想细化还是得根据光源去画贴图或者顶点着色才可以。如果是普通雕刻人物也就罢了。一般来说可以固定光源在物体的一个角度进行绘画，但如果是会动的物体或者光源不固定就比较讨厌了。就比如灌篮高手剧场版，这次删掉了原本井上的硬朗排线风格。如果灌篮高手剧场版要去全部加这些细节的话，那人物一动光源就跟着被影响，那么每一帧的人物按理说阴影和明暗交界线的排线都需要重新画了。想想可能不比传统动画简便呢。。特别是打篮球本来就是要一直动的。"},{"title":"【zbrush】曲线弯折","date":"2022-10-15T02:21:49.000Z","url":"/2022/10/15/jianmo/zb-quxianwanzhe/","tags":[["zbrush","/tags/zbrush/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 做头发的时候总在想如果zbrush有类似blender的硬表面操作就好了，然后摸了一下，录了一个视频。 "},{"title":"【画画】把心血来潮想画的东西扔在这里","date":"2022-10-11T05:23:38.000Z","url":"/2022/10/11/paint/paint-pictureall/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 有段时间很流行画各类月野兔的时候画的 不知道为什么，ipad画完导入手机再看，两边色偏还是挺大的 这破玩意儿我点点点了一周。 第一次画的水彩，没学任何技法，凭感觉瞎怼，那个树叶画的还真丑。 第二次画的水彩，画完之后就再也没动过水彩了。 第一次画的彩铅第二次画彩铅第三次画彩铅第四次画彩铅，一年多前的画，结果。。到现在彩铅找不到了都还没画完"},{"title":"zbrush/blender雕刻工作流gob交互","date":"2022-10-05T02:21:49.000Z","url":"/2022/10/05/jianmo/zb-bl-gob/","tags":[["blender","/tags/blender/"],["zbrush","/tags/zbrush/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 希望下次我再看我自己讲话能听懂。 "},{"title":"【人像】人像练习","date":"2022-10-03T07:23:38.000Z","url":"/2022/10/03/paint/paint-picture2%20copy/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 这次顺带录了屏嘿嘿~其实没画完拉 "},{"title":"【人像】画个刘亦菲","date":"2022-09-19T07:23:38.000Z","url":"/2022/09/19/paint/paint-picture2/","tags":[["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 画了个刘亦菲，四五个人都说是宋祖儿hhhhh，好好好那这个画的就是宋祖儿 "},{"title":"【blender】积累的一些杂七杂八","date":"2022-09-15T04:21:08.000Z","url":"/2022/09/15/jianmo/bl-zaqizaba/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" blender3.3更新了，毛发新增了编辑模式，但我没有找到。 只有原先的雕刻模式，在雕刻模式左侧有一些工具可以操作毛发 官网写开启实验功能后的调试后，在实验特性prototypes开启new curves tools我并没有这个选项。。 low poly相关 "},{"title":"【blender】给你跳段舞？","date":"2022-08-31T08:23:08.000Z","url":"/2022/08/31/jianmo/bl-vroid/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" vroid搞得基础模型大概花了一周时间在blender加的骨架然后搞了一段小动画~ "},{"title":"【blender+scatter5插件】两分钟做好一个漂亮的地形","date":"2022-07-31T22:21:49.000Z","url":"/2022/08/01/jianmo/bl-caoping/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 想录个随风摇摆的动画视频，结果粒子系统卡死我 因为这个插件本质是生成一堆粒子系统，所以要对自己的配置有自信。所需blender版本: 3.1及以上 ##1. 安装Landscape插件 ##2. 新建地形，在网格 - Landscape中。##3. 点击后，左侧下方有一个下拉菜单，点开后可以进行地形的详细设置##4. 物体 - 应用 - 全部变换或command + a 调出应用面板，也可以选择应用变换 。##5. 下载安装 Scatter5 插件并启用下载地址：点击查看下载后解压，通过插件引入，点击安装，导入解压后文件夹内的压缩包scatter5.2.zip，点击确定。点击展开，然后进入enter manager点击install a scatter package选择解压文件夹中的另外三个文件，，点击install即可。##6.右侧n面板中，选择该插件，点击吸管，选择创建好的地形。点击后面板变为以下模样子。然后点击图片，选择想要的预设。点击Biome Scatter，点击Open Biomes选择喜欢的地形。加载完成后，会有很多粒子系统被自动导入，默认不开启。点击每一个System List中的粒子系统，在下方wind中，开启Wind Waves 加载一个天空纹理点击渲染模式并播放即可。 ###说明：&ensp; &ensp; 1. 操作项预设&ensp; &ensp; &ensp; &ensp; 可以设置一些预设的地形，比如石头、湖泊、山等。 &ensp; &ensp; 2.SubdivisionsX / Y&ensp; &ensp; &ensp; &ensp; 细分，细分自然是越高细节越多。但渲染也越慢。 &ensp; &ensp; 3. mesh SizeX / Y&ensp; &ensp; &ensp; &ensp; 设置平面的尺寸。 其他的设置也有很多，可以多尝试 ##其他积累：&ensp; &ensp; 1. scale 平面，之前只知道是按s，但不知道按下数字键可以直接按比例缩放，比如按s，向外拖，再按2，就是放大两倍。按s，向内拖，再按下2，就是缩小两倍了。"},{"title":"blender各种光源的设置","date":"2022-07-24T22:21:49.000Z","url":"/2022/07/25/jianmo/bl-guangyuan/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 场景 - 世界自带光源与hdri光源。首先，场景 - 世界中的自带光源，与hdri光源是互斥的，二者只能有一个生效。当勾选 视图着色方式 - 场景世界 时，将强度/力度调为0，且没有建立其他光源的话，则世界场景完全无光源。将强度/力度调高世界场景也会亮。所以一般如果不需要这个的话，在渲染前需要调为0。 场景世界若不勾选，可以显示hdri，世界不透明度改为0的时候就可以只显示物体上的hdri效果。hdri图有360度的场景。相当于一个懒人全景打光，将场景中物体放入了已经定义好的一个360度的环境中。 各种光源的详细介绍1. 点光源颜色：调整颜色能量：调整瓦数半径：半径越大，向周围发送的光就越散点光源离物体越近，物体越亮。点光光源半径越大，阴影越散。 注：当沿点光源像物体两边作切线，离物体越近的光源切线范围越大。所以点光光源离物体越远时，阴影反而越硬朗， 2. 日光日光本身建立在什么位置都无所谓，完全无所谓。日光的位置不会影响影子的角度、影子的强度。比如下图，日光在物体正上方，影子依旧向右。就算日光放到物体底下，影子依旧不会受日光的位置影响。 影响日光角度的只有这个调节手杆儿 手杆儿角度越大，阴影越长 角度和强度： 太阳光强度一般1-3就很亮了。角度0-180度，和手柄调节的角度不是一个概念。试下来感觉角度越大阴影越散越亮。可以观察下面两张图的角度值，同时观察墙面的投影区别。 3. 聚光灯对物体的照射方式基本像点光，但它的角度可以调节，且只朝向一部分角度。就像是360度的点光截了几十度（1）光源半径光源半径越大，光越散，投影边缘越柔和，越暗。。（2）光斑尺寸越大的光斑尺寸，越大的光斑范围。光斑尺寸不影响边缘模糊与否。 混合，数值 0 - 1，聚光灯下两个圆环数值越接近1 ， 聚光灯底部在中间的小圆的半径越小，光的边缘越模糊，不怎么影响投影的边缘。 ###4. 面光不具体说了，像一个有方向可调节大小和尺寸的太阳光。 hdri切换到world，点击颜色前面的点，点击图像纹理。 勾选hdri后，就在左图设置hdri相关。右边的设置基本就没什么用了。 渲染时如果不想有hdri背景，勾上透明就不会渲染hdri了。 用物体自发光来打光。自发光的物体相当于一个点光源在场景内新建一个球，为球指定自发光颜色及强度切换到渲染模式，就会发现球成为了一个光源照亮了周围的物体。 ####补充：在cycles模式下如何设置辉光？现在只能在渲染层设置，没办法预览，所以需要渲染后才能看到效果。 四、使用ies 纹理进行打光ies纹理概念：ies纹理用于匹配基于IES文件(IES)的现实世界的灯光。IES文件存储光源的方向强度分布。常用的ies纹理免费下载网站：点击下载 下载的ies贴图对应的能量和建议的灯光类型。 举例：第一张没有ies纹理。第二张有纹理。可以看到普通点光是均匀过度的。而用了有ies纹理的灯光是有可能不均匀的。接近现实世界的光。着色器中有一个叫黑体节点，黑体值越大，越接近原本设置的颜色，越小，颜色越暖。 黑体温度为1111111和为1的对比。 "},{"title":"【菜谱】自己做的菜合集 + 简单描述的菜谱们","date":"2022-07-23T04:33:23.000Z","url":"/2022/07/23/caipu/","tags":[["菜谱","/tags/%E8%8F%9C%E8%B0%B1/"]],"categories":[["生活","/categories/%E7%94%9F%E6%B4%BB/"]],"content":" 日记本来一直在有道云写的，因为有道云太辣鸡吞了我好多图所以当做日记一样复制过来。所以图拍的不是那么讲究，背后很多杂物，甚至很多是吃了一半才想起来拍一张。。。好多图都被有道云吃了，现在只能找回这些了，真惨。 ##香辣鸡翅尖 鸡翅尖开水焯水，加一点点盐，两三分钟捞出备用。 切葱、蒜、干辣椒段、花椒、准备一点熟白芝麻。 锅中热油，放入蒜、干辣椒段（泡水）、花椒，炒香。 倒入一点点火锅底料，炒化后倒入鸡翅。 炒出香味后，倒入鸡翅尖，翻炒均匀后加生抽、糖、蚝油、孜然等尝味道。 撒入香葱翻均匀，撒入芝麻，留一点点香葱装盘后洒在表面做点缀。 ##炸鸡翅根 鸡翅洗净剪开，露出骨头。 酱油、糖、蚝油、花椒粉、辣椒粉、孜然粉、五香粉、蒜、葱、水淀粉进行腌制，二十分钟左右可以拿出。 低筋面粉+淀粉1:1进行混合，腌好的鸡翅根放入其中粘上粉末，捏紧实。搓一搓，再次裹上粉。 如果想脆皮厚一些，可以准备一个放了清水的碗，裹好粉的鸡翅放入水中浸一下就捞出，然后再重复裹上粉，搓一搓的步骤。 油温三成热下入鸡翅，小火炸一会儿翻一下面，炸八分钟到十分钟。用筷子插鸡翅如果可以插透表示熟了。 捞出鸡翅控油，大火让让油温十成热，下入鸡翅，炸制表面金黄且完全脱水，变为脆脆的感觉即可。 ##仿南大门米糕做的桂花糕比较麻烦，快赶上烤蛋糕那么麻烦了，但很好吃。 材料：粘米粉、糯米粉、糖粉，桂花糖，干桂花，还需要准备切刀，30+目筛子，最好是60目，最好备个电子秤，模具，我的是四寸方形慕斯蛋糕模具。 比例：粘米粉：糯米粉：糖粉 = 3:1:1，我用的是四寸方形模具，粘米粉：糯米粉：糖粉 = 150g:50g:50g。还多出一些，做了两次。水：约为糯米粉or糖粉的两倍，如糯米粉五十克，则水要一百克。 详细过程： 糯米粉、粘米粉混合，然后一点一点慢慢加水，搅成一个个松散的小坨坨。 过筛成细细的粉，不要按压细粉，多过几遍筛会让口感更细腻。 蒸锅垫布，模具放入蒸锅，倒入细细的粉，千万不要按压千万不要按压千万不要按压！用刮刀把表面刮平整，，，，，小心翼翼的切分为3*3的九宫格，如果这时候不切开，蒸好后切开就容易碎不好看。 水开后转小火，放上去东西蒸20分钟左右。蒸到五分钟左右的时候其实模具就可以拿掉了，不要等最后才拿模具，因为水会聚集在底部，底部会显得很湿。 蒸完后拿出来，每一块上挤上桂花糖，撒上桂花，趁热吃吧。 ##桂花蒸鸡蛋羹 普通的蒸鸡蛋，就是鸡蛋打了之后加水到鸡蛋一倍左右，然后加盐，把表面气泡用勺子或者别的撇干净。 裹保鲜膜扎洞小火蒸，出锅后表面撒上桂花，切一半圣女果摆上去，沿碗边加上酱油即可。 蒜蓉粉丝娃娃菜 至少一颗整蒜，切末，红尖椒，切碎，切葱、准备几颗花椒。 小火加入油三四成热，油多倒一点，下入花椒炸出香味，下入尖椒翻炒一下，加入蒜末炸至金黄。 倒入生抽、白糖、蚝油、一点点孜然，尝味道合适了备用。 娃娃菜洗净铺在盘底，上面放上泡软的粉丝，倒入炒好的蒜香油。 烧开水，上蒸锅蒸二十分钟。 端出来，加入香葱点缀即可。 鸡蛋杂菜薄饼太简单了，不写做法了。 当然也可以卷了切开做鸡蛋卷，中间加了些肉松。以前的我还真讲究摆盘。。 ##杂菜饭团 米饭煮好，香菇、火腿、玉米、肉松、海苔/裙带菜切碎，切葱蒜小米辣。 小火炒香蒜小米辣，下香菇碎、火腿碎、玉米粒、裙带菜/海苔，加盐、味精调味至合适倒入米饭中搅拌。捏成团摆入盘中，芝士切片铺在饭团上，蒸锅蒸化芝士即可。 ##麻辣鸭掌 鸭掌凉水下锅焯水，焯水后大火转小火，煮四十分钟以上，想要软烂则一小时以上最好。 捞出洗净，准备四五个蒜瓣切蒜末（or蒜瓣拍碎，喜欢吃蒜可以切蒜末），稍微多一些的干辣椒，三根香葱，花椒一小把，熟白芝麻。 大火热油，加入一小块火锅底料炒化，下入蒜末、干辣椒（泡水）、花椒翻炒出香味，下入鸭掌翻炒均匀，加入一点点老抽调色，加入生抽、蚝油、糖调味，（尝一下锅铲的味道。。。合适的话），翻炒几下即可出锅了，关火后加入香葱翻一下，再加入白芝麻翻一下，可以加一点点鸡精翻均匀。 装盘再在表面撒一些香葱和白芝麻即可。 ##蛋挞蛋挞皮是现成的，蛋挞液是炼乳+蛋黄+牛奶+白糖，过筛后倒入蛋挞皮，180度预热烤箱，然后放进去烤20分钟左右就好了，反正烤箱是可以看表面状态的。下次拿出来的时候要小心烫手，我把自己手指烫了。 ##麻辣花蛤 花蛤泡的久一点让他吐沙，然后剥出来。 开水加料酒焯水两三分钟让它熟了，捞出备用。 准备干辣椒花椒小葱蒜瓣拍碎，干辣椒蒜瓣花椒大火下锅炒出香味，加入花蛤翻几下，加生抽蚝油糖翻几下，加一点点孜然翻几下，嫌颜色不够可以加一点点老抽，然后就可以出锅了。 ##年年有余 吉利丁粉在热水中一点一点加，一定要一点一点加。慢慢融化慢慢融化，加入糖，加入枸杞。 倒入模具中冷藏一小时or更长，发现凝固了就拿出来脱模就完成了。如果是很薄的塑料膜可能会沾膜，拿根牙签稍微挑一下就行了。 周围撒上枸杞。说真的真好看，但口感一般，也就果冻的味道，却没有果冻的添加剂。平时我一个人过节的时候，或者还剩吉利丁消耗不掉的时候才会做一做，我是羞于拿它的口感出来招待客人的。 ##糖葫芦 - 小番茄版 圣女果洗净两两穿好备用 糖：水=2：1，放入小锅（重要）小锅中加热，先大火将糖融化至起大泡，然后小火至起小泡，继续加热，至用筷子蘸取糖液，若能拉丝，则放入冰水中，结成块且尝起来易脆则ok。全程不要搅动。 串好的圣女果在锅中沾满糖液，小心拿起避免拉丝，然后放入冰水中浸泡至定型，放入盘中即完成。 ##冒红薯粉 红薯粉开水下锅加一点盐煮20分钟，捞出凉水洗一下。 切小米辣、蒜末（多多多）、葱末（多多多）、香菜（半根）、辣椒面、准备白芝麻大半勺、花生酱一两勺（or花生碎+芝麻酱）、孜然、白糖、蚝油，混合，倒入热油（多一些）搅拌均匀，冷一会儿后加入鸡精、生抽再搅拌。 与粉混合均匀，完成。如果想更好看些，可以再混合后加入小葱香菜在表面做点缀。 ##自制钵钵鸡汤底炖鸡汤，一部分鸡汤放盐备用素菜开水加盐焯熟，荤菜凉水加盐焯熟魔芋要先泡水之后，再煮二十分钟，魔芋不熟有毒，不泡水会去不掉碱味的炒些辣椒油（孜然/辣椒面/花椒/糖/盐/味精/炸花生米/熟白芝麻/其他，热油泼进）干辣椒多些（稍微泡水再过水），花椒多些（稍微泡水再过水），八角，辣椒面，葱段，蒜瓣拍碎锅中稍多点油，放入两勺豆瓣酱，炒出红油，放入上述干辣椒等材料片炒出香味，然后加高汤，然后大火煮沸，转小火加盐调味。五分钟左右关火，捞出那些调料扔掉，加入炒好的辣椒油（一点一点加，防溅锅），然后加大量鸡精调味。汤底倒出汤碗中，放入食材浸泡越长时间越好即可。 ##鸡胸肉饼 鸡胸肉搅碎，加玉米粒、豌豆粒、葱、小米辣、二荆条辣椒，盐、鸡精、花椒粉、生抽。 锅中放入涂上油的圆形模具，倒入油，小火加热，加入鸡肉铺好，待定型取下圆形模具，盖上锅盖焖一下，开锅翻面煎。 怕碎可以加淀粉，但我是不加的，我也没碎，只要鸡胸肉处理的够筋道就不会碎，多摔打，多搅拌，像搅饺子馅那样。 ##牛奶桂花土豆泥 土豆洗净切块蒸熟，混合白糖用料理机打成泥，加入 牛奶拌匀，倒入碗中搅拌均匀，铺上桂花，铺上桂花蜜。 ##狼牙土豆 土豆用狼牙刀切成条状，浸泡去淀粉。 锅中水烧开加盐，土豆放入水中焯熟，不要煮太久，捞出控水。 碗中放辣子面、孜然、花椒（多）花椒粉、糖（灵魂）、白芝麻、葱、蒜末（一个都不要少）、味精、盐，油烧滚泼入，搅拌至盐融化。 土豆控水后，将调料倒入即可。 ##干煸辣子鸡. 鸡腿肉去骨，剪成小块儿 花椒粉+辣椒粉+生抽+一点点老抽+白糖+五香粉+孜然粉，腌制十五分钟。 干辣椒、花椒切段泡水，蒜切片，准备一小段大葱。 锅中入油，小火加热至三分热倒入鸡腿，加入大葱葱段、花椒、蒜片一起炸，鸡腿炸去水分微金黄捞出控油，油十分热再炸一遍。 油倒掉，锅中重新加入多一点的油，倒入辣椒段、花椒、蒜片翻炒出香味，加入鸡腿肉翻炒一分钟即可出锅。特别好吃！ ##红烧后腿肉五五分的肉，比较肥，感觉还是红烧比较有味道。就是普通红烧肉的做法，不说了。##香菇炖鸡腿汤 新！鲜！的鸡全腿用剪刀剪出露出骨头，放入锅中焯水，倒些料酒，放入花椒、大葱段一小段。 捞出洗净，炖锅中倒入许多凉水，放入鸡腿，加入三两颗花椒、一片姜片，放入两三朵新鲜香菇，大火烧开转小火，炖越久肉越烂。 其实更简单的方法就是放进电饭煲按煲汤模式。。火候不用自己看，到时间了就自然好了。 ##烤口蘑 口蘑小心去蒂，放入空气炸锅160度烤十分钟。 锅中放玉米油，蒜切碎（或打成蒜泥），切小米辣、蒜苗，炒蒜蓉酱，先小火加热油，倒入蒜末，小火炒制发黄，加入小米辣碎，搅几下，关火加入白糖、盐、味精搅化。 倒在烤好的口蘑上，撒上蒜苗和葱花即可。 ##清炖狮子头 五花肉/后腿肉/前腿肉/梅花肉洗净，切碎，加入葱、蒜末（要切的很碎很碎）、马蹄碎（建议加，没有也可以不加）、淀粉，反正别用纯瘦肉。 向一个方向搅搅搅，直到感觉有那种韧劲儿了，就比饺子馅还有韧劲儿的那种感觉，然后摔打，多摔几下。 做成大丸子，凉水烧一会儿大概有温度了就下炖锅，慢慢放下去小心碎了，然后大火烧开，小火四五十分钟就可以了。 ##鸡蛋饼裹生菜太简单了都不想说了就是鸡蛋+低筋面粉加了些调味料（盐、花椒粉、糖、孜然，反正根据自己口味加。），搅拌至没有面粉沉淀，然后加入自己喜欢的配菜搅拌成均匀的糊糊，比如玉米粒、香葱、小米辣碎、火腿等等热锅凉油下入上面说的糊糊，小火小火小火，均匀撒上黑芝麻，一面定型后翻至另一面煎熟，然后拿出裹上生菜，表面挤上番茄酱即可。 ##炸香菇 一勺淀粉一勺低筋面粉一个鸡蛋，搅拌均匀，加一些花椒粉、五香粉、盐、孜然、糖。 香菇放里面裹上糊糊，然后小火加热油，油温三成热下香菇，炸至油温七成热熟了捞出。 大火加热油温到十成热，快速放入刚刚炸好的香菇，把表面水分彻底炸干，炸一会儿就捞出，然后表面撒上椒盐，就行了。 ##娃娃菜粉丝汤没啥说的，奶白色汤的秘诀是，加入的配料比如火腿或者皮蛋是要先炒一下的，用除了菜籽油之外的油炒一下然后再加水炖，就会有奶白色的汤了。菜籽油其实也可以用，但炖出来的汤是黄的~味道没有太大差别。 #油炸花生没啥说的，小火凉油倒入花生不停的翻炒，噼噼啪啪的声音出来就是好了。酥脆的秘诀就是捞出之后加入料酒然后用筷子不停的搅，加入料酒会有刺啦的声音，搅拌的时候也会冒烟 ##好看不好吃的空气炸锅杏鲍菇 一个淀粉一个鸡蛋混合均匀加入花椒粉生抽孜然粉五香粉调味调味 面包糠放入另一个碗中备用。 杏鲍菇切条，放入淀粉鸡蛋液中滚一滚，再裹上面包糠，再放入鸡蛋液滚一滚，再裹一次面包糠，放入空气炸锅刷一层油，200度烤十分钟即可。 因为是面包糠，再加上空气炸锅虽说叫炸锅实际上是烤，所以表面很干很干，并没有那么好吃。无奈我只能就这个形态又去油炸了 一遍，味道才变得好吃， 注：面包糠的特性是虽然脆，但不会像淀粉+面粉那样油炸之后边的膨胀，所以要想好看的话面包糠是要裹至少两遍的。 ##烤豆腐 - 空气炸锅版 豆腐横刀一刀，竖刀三四刀将豆腐切块。 空气炸锅平铺锡纸，豆腐摆入空气炸锅，180十分钟翻面，再烤十五分钟（或更长），考好拿出摆盘。 调酱汁，蚝油+糖（天下无双）加自己炒的特辣辣椒油和辣椒面，加一点孜然粉，加小葱和蒜和一点醋（这个料绝了，味道超级好）也可以加一点小米辣，我没加懒得切，倒在豆腐表面，完成。 ##烤苕皮酱汁：辣椒面、花椒面、孜然、熟白芝麻、韩式烧烤酱或糖各一勺，搅拌后淋上热油。炒些花生。刷上酱汁，苕皮一点油小火煎，煎至起泡，翻面刷上酱汁，煎至两面起泡，撒上香葱、韭菜、花生、榨菜，折三折，用竹签穿好即可。 ##烤五花肉片选新鲜的五花肉，新鲜的五花肉，新鲜的五花肉，腌个十来分钟，然后锅里小火煎熟就行。 ##烤鸡腿腌料腌半小时–三小时，烤二十分钟中途翻面。我的腌料：花椒粉、生抽蚝油糖、孜然粉、辣椒粉、蒜末、葱烤的时候表面刷蜂蜜 ##娃娃菜豆腐汤豆腐煎一下，加入水烧开，加入娃娃菜小火炖十几分钟，捞出撒入香葱。这个豆腐使用菜籽油煎的，所以汤变成了黄色。如果用玉米油煎就不会是黄色而是奶白色。 ##拔丝土豆简单但麻烦，麻烦的点在于，锅如果当时做完不洗干净，等锅里的糖凉了就很难洗干净。。做菜五分钟洗锅一晚上。 水糖1:2熬糖，大火冒大泡转小火，熬一会儿拉丝了加入炸好的土豆块搅拌均匀即可。 炸土豆块就不说了，土豆块焯水七八成熟控水，下入三分热油锅炸熟，大火十成热油复炸就行了。 ##圆圆的煎鸡蛋~让它圆圆的秘诀在于不要用平底锅，要用普通炒锅，因为普通炒锅打鸡蛋下去不会跑偏。平底锅就容易跑偏。 ##月饼装到盒子里也很好看啵 酸菜鱼酸菜切了，加葱姜蒜花椒泡椒炒一炒鱼片成片，加花椒粉淀粉盐腌，鱼头骨炖汤。炒后的酸菜加鱼汤煮，煮到沸腾转小火，放入鱼片煮熟（一般鱼是熟的很快的）。碗底铺焯好水的豆芽和金针菇，然后捞出鱼片放在表面，倒入汤。表面再放花椒、干辣椒段、蒜末、香葱。热油淋上去表面撒上香葱即可。"},{"title":"平面构成入门","date":"2022-07-02T05:23:38.000Z","url":"/2022/07/02/paint/paint-color%20copy/","tags":[["构成","/tags/%E6%9E%84%E6%88%90/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 先把思维导图放好，之后慢慢配图 "},{"title":"【2022-10-09】前几天在咖啡厅画速写","date":"2022-07-02T05:23:38.000Z","url":"/2022/07/02/diary/diary-1009/","tags":[["生活","/tags/%E7%94%9F%E6%B4%BB/"],["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["日记","/categories/%E6%97%A5%E8%AE%B0/"]],"content":" 还被画的小姐姐发现了，但她坐了很长时间之后，默默的走了，走之前和同行小姐姐说“看不看？”最后也没过来看。 "},{"title":"blender的cycles引擎如何使用辉光效果","date":"2022-07-01T08:23:04.000Z","url":"/2022/07/01/jianmo/bl-cycles/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 一般辉光是只在eevee引擎下如果cycles下也想用的话照我下面这样设置就可以拉"},{"title":"blender练习蜡笔工具","date":"2022-06-23T04:21:49.000Z","url":"/2022/06/23/jianmo/bl-grease/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 上上手蜡笔工具吧。挺好玩的，有点费事儿，比三渲二效果好多了。 "},{"title":"色彩构成入门","date":"2022-06-22T20:57:38.000Z","url":"/2022/06/23/paint/paint-color/","tags":[["构成","/tags/%E6%9E%84%E6%88%90/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 思维导图 1. 基本概念首先，有光线才有色彩。物体表面会吸收一部分光线，反射另一部分光线，反射的光线到达我们的眼睛，被视锥细胞（感知颜色的细胞）和视杆细胞（感知明暗的细胞）所接收，再通过神经传输到大脑，我们就产生了颜色的映像，从而具有色彩感。 我们已经知道，牛顿用三棱镜将光分成了七色，从红到紫正是我们人眼能感知到的颜色范围，从光学的角度看，就是波长从 380 纳米到 780 纳米的光线。低于 380 纳米的，叫做紫外线，高于 780 纳米的，叫做红外线，都是我们人眼无法看到的。 我们已经知道，光线具有波长和振幅，其中，光波的波长反映光波的频率，给人色彩感，光波的振幅反映光的强弱，给人明暗感。人眼中的两种细胞正是分别感知这两种参数，其中，视锥细胞感知波长，视杆细胞感知振幅。所以，我们看到的颜色，其实就是不同波长、不同振幅和不同比例的光线在人眼中的反映。 通常，我们所称的自然光都是指太阳光，物体在自然光下呈现的颜色我们称为物体的固有色。但是，自然界中还有其它的光源，比如月光、闪电、灯光、烛光等，而在其它光源的照射下，物体颜色会发生改变，所以，我们平常所看到的颜色都是物体固有色和光源色的结合。 如果照射到物体表面的全部光都被吸收，物体就呈现黑色，如果全部光都被反射，物体就呈现白色，不过，纯粹的黑白只存在于理论中，现实中没有物体可以全部反射或吸收光线。 1.1 色彩的三要素就像度量衡一样，色彩也需要一个标定体系，像红、黄、蓝、绿这样的简单命名是模糊的，不足以区分不同的色彩。色彩的标定体系就是色彩的三要素：色相（Hue）、明度（Value）、纯度（Chroma）。 色相字面上理解，就是色彩的相貌，用来区分不同的颜色，比如牛顿分解的光谱色：红、橙、黄、绿、青、蓝、紫，就是七种不同的色相。在我们后面会学到的色相环中，色相包括三原色和由它们按不同比例混合成的各种间色和复色，理论上，色相的划分是没有极限的，但是人眼的感知有极限，人眼只能分辨出大约 180 种不同色相的颜色。还要注意的是，无论色相环包含的色块有多少，每两块之间都有本质的区别，色块越多，仅仅是色差越小。 从光学意义上讲，色相的不同是由光波波长的长短和不同光线的比例决定的。 明度简单的理解，就是色彩的明暗程度。每一种色相都有自己的明暗度变化，而且都以白为最高明度，黑为最低明度。色彩的明度受两个因素影响：一是光源色的强弱，光线越强，色彩明度越高；二是黑与白的介入强度，加入黑色可以降低色彩明度，反之，加入白色可以提升色彩明度。 明度在光学角度的本质是光的振幅（即强弱），所以黑和白的介入也可以这样理解，加入黑增强了物体吸收光线的能力，因此降低了它的明度，而加入白增强了物体反射光线的能力，因此提升了它的明度。 除了色相本身的明度变化外，不同色相本身就有明度的差别，其中，黄色明度最高，紫红色明度最低。纯粹的黑白色也有明度的变化，这就是不同级别的灰色。 纯度纯度指的是色彩的鲜灰程度或纯净程度，也叫做饱和度。意思是一个色彩包含该种色素成分的多少，当该色素成分为 100% 时，就是该色相的纯色，所以加入其它任何颜色都会导致纯度的下降，不过，通常降低某色彩的纯度，都是通过混入无彩色系列的黑白灰或混入该色的补色完成的。 从物理的角度讲，一个色相的纯色就是单一波长的光。 黑白灰这三种颜色没有纯度的概念，因此叫做无彩色，其它有纯度的颜色叫做有彩色。 1.2 色彩混合大部分的色彩都可以通过混合其它的色彩得到，但是，一定有几种是最基本的颜色，是不可拆分的，这就是原色。光的三原色是红、绿、紫，颜料的三原色是红、黄、蓝。 任意两种原色混合得到的颜色叫间色，颜料的三间色是橙、绿、紫。 将间色彼此混合，就形成了复色。由于间色本身就是原色混合而成的，复色就意味着是不同比例的原色混合，原色混合的不同比例加上纯度和明度的变化，就构成了我们所看到的丰富的颜色世界。 光线彼此混合，亮度会不断提升，最后形成白色光，这叫做加色混合，计算机的显卡就属于 RGB 加色配色系统。通过改变每种原色电子光束的强度，得到深浅不同的色彩，从而合成丰富的色彩； 颜料彼此混合，亮度会不断降低，最后形成黑色，这叫做减色混合。最后一种混合叫做中性混合，是利用人眼对空间的感知产生的一种混合方式，包括两种，一种是具有运动特点的旋转混合，比如具有两种颜色的陀螺旋转会呈现这两种颜色的复色，另一种是具有静止距离特点的空间混合，例如马赛克镶嵌画和点彩画。 1.3 色相环色相环也称色环，是将色相以一定的变化规律顺序排列形成的一个环，反映了色相之间的数理关系，对色彩的使用具有很大的指导意义。常用的是 RGB 的 3 色相环、瑞士约翰内斯·伊顿的 12 色相环、德国奥斯特瓦尔德和日本色彩研究所的 PCCS 色彩体系的 24 色相环、美国孟赛尔的 100 色相环。所有的色相环都是以 120⁰ 的三原色为基础，在一个完整的圆内等量分割，形成变化均匀的等量过渡色。 下面是伊顿的十二色相环，在 120° 的位置上是 3 个原色，每对原色中间加入一个间色，每对间色中间再加入一个复色，180° 的直径两端叫做互补色。 1.4 色立体色立体是色彩理论的数学模型，是色相、明度和纯度三元素借助三维空间的表达，也是唯一区别每个颜色的标准。 目前，主要的色立体体系有美国的孟赛尔色立体、德国的奥斯瓦尔德色立体、日本色彩研究所 PCCS 色立体、国际照明委员会 CIE 色立体等。虽然各自之间有一定的区别，但是理解了其中一种，剩下的就都很容易理解了。 以如下的孟塞尔色立体为例，水平的圆环等量分成 10 份，分别是红、黄、绿、蓝、紫 5 个基色和它们的 5 个间色，共构成 10 个基础色域，每个色域再等分成 10 分，总计 100 个色相，这个圆环就是我们之前说的色相环；纯色在圆环的最外层，从最外层到圆心，纯度不断降低，直到变成圆心的灰色，纯度一共有 12 个等级；中间的轴代表无彩色，最下方是黑色，最上方是白色，黑白之间还有按明度变化的 9 个灰色，因此，纵轴就代表了明度的变化，每一种色相和纯度确定的色彩在纵向上都有明度的变化。 下面是构造出的完整孟塞尔色立体。 2. 色彩的对比色彩的对比是将两个以上的色彩放到一起，由于相互作用和相互影响而显现出差异的现象。事实上，对比是构成色彩的必要因素，如果整个世界只有一种颜色，没有彼此的对比，那也就失去了色彩的意义。 根据前面所学的一些概念，色彩的对比可以分为：明度对比、色相对比、纯度对比、冷暖对比、面积对比等。 2.1 色相对比因色相差别而形成的色彩对比称为色相对比。将不同色相的色彩并置在一起，可以使对方的特征更加突出。 根据各色相在色相环上距离远近的不同，可以形成不同的色相对比，距离越远，对比效果越强烈，相距 180° 的两个色相对比最为强烈 同类色对比：色相环上距离在 15° 以内的两个色相的对比，对比的效果一般比较弱，通常还需要拉大明度和纯度来进行区别； 邻接色对比：色相环上距离在 15°-30° 之间的两个色相的对比，这样的两个色相就有了一定的区别，对比效果一般比较统一、和谐、柔和，适合背景处理； 类似色对比：色相环上距离在 60°-90° 之间的两个色相的对比，类似色对比一般显得丰满、活泼，即保持了随和统一的优点，又克服了视觉上不够饱满的缺点； 中差色相对比：色相环上距离在 90° 的两个色相的对比，由于差别比较明确，对比效果比较明快； 对比色相：色相环上距离在 120° 左右的两个色相的对比，对比效果比较强烈、鲜明，但过于刺激易产生视觉疲劳，处理不好容易出现烦躁和不安定的感觉； 互补色相：色相环上距离在 180° 左右的两个色相的对比，是最强烈的对比关系，更富于刺激性，但是画面比较直白，不够含蓄和雅致，同意易导致视觉疲劳。 在我所阅读的几个材料中，对色相对比的分类和称呼各有不同，比如，在有的书籍中同类色指的就是距离 15° 的两个色相对比，因此，上述分类只能作为参考，唯一确定的是，距离越远，对比效果就越强烈。 除了以上的色相对比外，还有两种特殊的色相对比 全色相对比：指的是色相环上所有色相都出现，由于人的视觉系统需要全色刺激，这种对比比较协调； 有彩色和无彩色的对比：无彩色又可以称为万能色，无论什么样的有彩色，和无彩色对比都可以呈现和谐的视觉效果。 2.2 明度对比指因明度差别而形成的色彩对比。两种不同明度的色彩并列时，会使明色更亮，暗色更暗。 根据孟塞尔色立体，由黑到白等差分为 9 个等级，加上黑白两色一共 11 个等级。0 级为纯黑，明度最低，10 级为纯白，明度最高。 我们将明度在 0-3 级的色彩称为低明度，明度在 4-6 级的色彩称为中明度，明度在 7-10 级的色彩称为高明度。以低明度色彩为主的构成低明度基调，以中明度色彩为主的构成中明度基调，以高明度色彩为主的构成高明度基调。 注：“……为主” 指该色彩在画面上的面积超过 70%，占绝对优势。 同时，我们将明度差在 5 个级别以外的对比称为强对比（长调对比），将明度差在 3-5 个级别内的对比称为中对比（中调对比），将明度差在 3 个级别以内的对比称为弱对比（短调对比）。 这样，不同的基调和明度对比程度就构成了一个 9 种明度对比方案，称为明度 9 调，分别是：高长调、高中调、高短调、中长调、中中调、中短调、低长调、低中调、低短调。举个例子，高长调指的就是主色调为中明度，明度差在 5 级以上的对比。一个明度 9 调的例子如下图： 2.3 纯度对比因纯度差别形成的色彩对比叫纯度对比，不同纯度的色彩并置，鲜的更鲜，浊的更浊。 和明度相似，纯度也有 3 种色调和 3 中等级差： 高纯度色彩占 70% 左右叫鲜调（高彩对比） 中纯度色彩占 70% 左右叫中调（中彩对比） 低纯度色彩占 70% 左右叫低调（低彩对比） 纯度差为 8 级以上叫强对比 纯度差在 5-8 级叫中对比 纯度差在 4 级以内叫弱对比 因此，纯度也有九调，分别是：鲜强、鲜中、鲜弱、中强、中中、中弱、灰强、灰中、灰弱。 2.4 冷暖对比冷暖色形成的对比，关于冷暖色的定义可参考本文番外部分。根据孟塞尔色相环的十个主要色相，以最暖色橙为暖极，以最冷色蓝为冷极，可划分为 6 个冷暖区 其中，两个冷暖极的对比是最强的，剩下的分三种 强对比：冷极和暖色，暖极和冷色； 中等对比：暖极、暖色和中性微冷，冷极、冷色和中性暖色； 弱对比：暖极和暖色；冷极和冷色；暖色和中性微暖色；冷色和中性微冷色；中性微暖色和中性微冷色。 以暖色为主可构成暖色基调，以冷色为主可构成冷色基调，两者给人不同的感觉，如下表 冷 暖 阴影 阳光 透明 不透明 镇静 刺激 稀薄 稠密 空气感 土质感 远的 近的 轻的 重的 潮湿的 干燥的 理智的 感情的 流动的 静止的 冷静的 热烈的 2.5 面积位置对比形态作为视觉色彩的载体，总有一定的面积，因此面积也会对色彩的表达产生重要影响。 色彩对比与面积的关系有： 色调组合，只有相同面积的色彩次啊能比较出实际的差别，互相之间产生抗衡，对比效果强烈； 对比双方的属性不变，一方增大面积，取得面积优势，而另一方缩小面积，将会削弱色彩的对比； 色彩属性不变，随着面积的增大，对视觉的刺激力量加强，反之削弱。因此，色彩的大面积对比可造成炫目效果； 相同性质与面积的色彩，大面积色稳定性较高，在对比中对它色的错视影响大，反之受它色的错视影响小。 色彩对比和位置的关系有： 对比双方的色彩距离越近，对比效果越强，反之越弱； 双方互相呈接触、切入状态时，对比效果强烈； 一色包围另一色时，对比效果最强； 在作品中，一般将重点色彩设置在视觉中心部位，最易引入注目，如井字形构图的四个交叉点。 注意，色彩对比从不是单一方面的，而是多个方面共同作用。 3. 色彩的调和 对比是手段，调和是目的 色彩的调和是指两种或两种以上的色彩，有秩序、协调和谐的组织在一起，形成和谐统一的色彩搭配。色彩调和是色彩设计的基本法则，色彩调和有两层含义 使有明显差别的色彩经过调整，形成和谐而统一的完美整体； 合理的组织选择色彩搭配，使其形成具有目的性的美的色彩关系。 调和方式包括：同一调和、类似调和和对比调和。 3.1 同一调和同一调和指在色彩的三属性中保持一种属性相同，将另外两种属性进行变化，因此又可以分为同色相调和、同明度调和、同纯度调和，还有一种特殊的无彩色调和。 [图片上传失败…(image-b5b89-1674499821595)] 3.2 类似调和类似调和是类似要素的结合，与同一调和相比，具有稍多的变化，但并没脱离以统一为主的配色原则。 [图片上传失败…(image-518ad2-1674499821595)] 3.3 对比调和对比调和是以强调变化而组成的和谐色彩搭配。在对比调和中，明度、色相、纯度三种要素都处于对比的状态，因此色彩更富于活泼、生动、鲜明的效果。 对比调和的方法有：秩序调和、混入调和、分割调和、呼应调和和面积调和。 秩序调和指在画面组织时时多种色彩呈现一定的秩序规律，常见的有 在伊顿色相环中选择位于等腰三角形、等边三角形、长方形、正方形等几何图形顶点上的色相来组织； 对色彩的色相、明度、纯度做渐变推移处理，使最强和最弱的色彩间呈多个梯次的等差、等比关系，弱化对比强度； 九宫调和，将 9 个按顺序排列好的色块放入九宫格中，源自我国传统的「明堂九室」，是多年累积的视觉经验。 混入调和指遇到不和谐的色彩组合时，选择一个同化元素（色彩要素中的任何一个），将其加入到所有的不同色彩中，使之都含有共同的因素，从而达到和谐的目的。 对于色相，应使所有色彩都具有共同的色彩倾向，比如夕阳下的所有色彩都带有暖暖的橙色，可以看作色相混入的结果；对于纯度，可使所有色彩降低自己的纯度，形成统一的色彩饱和度，比如雨雾中的所有色彩都变得灰蒙蒙的；对于明度，可使所有色彩同时降低或提升明度。 混入调和一般用在色彩调配阶段。 分割调和指遇到不和谐的色彩组合时，在它们之间嵌入金、银、黑、白、灰任何一种颜色，或者嵌入这几种对比色的中间色，使之产生过渡，从而缓解直接对比的强度，使配色达到调和。 分割调和主要用在画面的色彩组织中。 呼应调和指将合适的色彩添加到原画面中，使新色彩和原有色彩达成彼此呼应的调和关系。呼应的内容同样可以从色彩各要素触发，最常用的是色相的呼应。 注意，呼应的色彩对象多为画面中的主体、中心色，起到呼应作用的色彩多在面积、位置、数量、形状等方面处于弱势。 面积调和使某种色彩的面积占据支配地位，可以削弱对比关系。另外，伊顿根据歌德的色彩面积研究成果提出：相等面积比例的红色和绿色能够产生中性的灰色，而黄色和紫色、橙色和蓝色则需要不同的配色比例。用数学比例来显示它们的配比关系为红色:绿色=1:1、黄色:紫色=1/4:3/4、橙色:蓝色=1/3:2/3，这也是著名的“面积对比调和色轮图”。 红色和绿色，黄色和紫色、橙色和蓝色，不论哪一方超过这个比值，都将破坏两者间的调和关系，将两者转化到对比关系中。越接近这种调和比例，对比就越强烈，最终回到最熟悉的红花与绿叶的对比关系之中。 番外冷暖色从色相环的分布看，红橙色类为暖色系，蓝紫色类为冷色系，黄绿色类为中性，黑色感觉为暖色，白色感觉为冷色。色彩明度和纯度的改变也会影响色彩的冷暖感，明亮色偏冷，深暗色偏暖，纯色保持原色的冷暖感，而纯度的降低会使冷暖感趋于中性化。对于太阳光而言，时间也是影响冷暖的因素，一般来讲，早晨的阳光色彩偏冷，傍晚的阳光色彩偏暖。各种不同的光源提供的颜色本身就有偏向，比如，白炽灯的光源色偏暖黄，荧光灯的光源色偏冷蓝。 色调我们常说一幅画、一张照片或一个场景是什么色调的，色调其实指的是占主导地位的一种视觉因素，色彩的三元素：色相、明度和纯度都可以作为色调，比如，从色相上，可以有红色调、蓝色调、黄色调、绿色调等；从色彩明度上，可以有明亮色调、暗色调等；从色彩纯度上，可以有清色调、浊色调、纯色调、灰色调；甚至从色彩的特性上，可以有暖色调、冷色调、中性色调。 一般情况下，当某种类型色彩占据超过 70% 时，就称为该色调。"},{"title":"【2022-06-12】这种试稿我再也不想参加了","date":"2022-06-12T05:23:38.000Z","url":"/2022/06/12/diary/diary-0612/","tags":[["生活","/tags/%E7%94%9F%E6%B4%BB/"],["绘画","/tags/%E7%BB%98%E7%94%BB/"]],"categories":[["日记","/categories/%E6%97%A5%E8%AE%B0/"]],"content":" 虽然都不难，按他的风格去画都是半小时内就画完的东西，画完两张试稿通过后觉得好不值得，关键画完说通过了才给合同，好家伙，一看一单抽六成，你们咋不去抢呢？？？ "},{"title":"docker安装jenkins","date":"2022-03-21T11:36:26.000Z","url":"/2022/03/21/docker%E5%AE%89%E8%A3%85jenkins%E6%95%99%E7%A8%8B/","categories":[["undefined",""]],"content":"明天写拉 docker pull jenkinsdocker run xxx"},{"title":"搭建web部署系统","date":"2022-03-21T02:55:58.000Z","url":"/2022/03/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAweb%E9%83%A8%E7%BD%B2%E7%B3%BB%E7%BB%9F/","tags":[["iv","/tags/iv/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 安装jerkins docker ，准备好代码仓库（github/gitlab）在自己的机器上跑起来 done使用jenkins将码云上的git仓库拉到服务器将代码拉到服务器后，可以手动触发构建、部署完成自动化部署开发一个自己的插件，具体做啥还没想好 在开发服务器上既部署了jenkins也部署了项目，通过不同的端口号访问，很不安全也不好。 我将Jenkins部署系统和网站运行在同一台服务器上，但它们使用的不同端口号。部署系统是8008，网站是8009 Jenkins是一款开源的自动化部署工具，可以通过插件来实现各种不同的功能。其中，SSH Remote Hosts插件允许Jenkins在远程服务器上执行命令。 先使用publish over ssh插件将内容发送到服务器上，然后再使用ssh remote hosts配置去远程执行服务器上的命令。 ssh remote hosts 的作用该插件允许Jenkins将指令发送到远程服务器，并获取执行结果。这对于自动化部署和持续集成非常有用。通过SSH Remote Hosts插件，您可以配置Jenkins与多个远程服务器之间的连接。您可以指定服务器的IP地址、用户名、密码、端口号等信息。在建立连接后，您可以在Jenkins上执行各种命令，如运行shell脚本、安装软件包、复制文件等等。 在使用SSH Remote Hosts时，需要注意以下几点： 在远程服务器上安装SSH服务，以便Jenkins可以连接到服务器。确保您在Jenkins服务器上安装了SSH插件。在SSH Remote Hosts插件的配置中，确保您提供了正确的IP地址、用户名、密码和端口号。确保您在Jenkins中的作业中使用了正确的SSH Remote Hosts插件的配置。使用SSH Remote Hosts插件时，需要小心，确保您使用了正确的权限和正确的命令。同时，要定期更改您的密码，以确保安全性。"},{"title":"【chrome调试】使用chrome调试已发布页面的文件代码","date":"2022-03-12T07:01:49.000Z","url":"/2022/03/12/cxy/other/chrome-tiaoshi/","tags":[["开发效率","/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 让这个脚本跑了一晚上，并顺便水了一个视频，骗了两个硬币。熬了一整夜剧都没掉下去 已经编译上线的代码，在需要进行浏览器调试的时候，改文件会相当不方便，有时候只是改一些小条件也需要繁杂的操作，并且浏览器一刷新就又要重新改。为了解决这个问题，可以使用chrome的snippets调试已发布页面的文件，通过拦截network 打开sources - Snippets 2. 点击Select folder for overrides，选择一个文件夹，用于存储需要调试的在线文件。 3. 上方点击“允许”，可以看见文件夹就显示在Overrides里了。 4. 比如在google首页，打开network，随便选择一张图，右键 - Save for Overrides5. 回到source，就可以在你的文件夹中看见这张图了6. 现在可以把它替换成其他logo，比如百度7. 也可以去调试代码，搞些有意思的小事情~比如很久之前有段时间很流行的b站风叶穿行游戏，我是用这种方法改脚本自动跑的成绩 使用chrome的Snippets比较省事的是，即使刷新很多次，只要勾选了Enable Local Overrides就会一直生效，有时候本地未经过编译的代码怎么测试都没有问题，但放到线上就是有奇奇怪怪的问题，如果能调试压缩后的代码也会比较直观~我是一直很喜欢这个方法拉。"},{"title":"github pages 自定义域名","date":"2022-01-26T07:01:49.000Z","url":"/2022/01/26/cxy/other/dns/","tags":[["实用开源代码or工具","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81or%E5%B7%A5%E5%85%B7/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" ping xxx.github.io找到域名 在购买域名的提供商为域名添加解析，如下设置（阿里云的） 在Github中，找到托管博客的xxx.github.io项目：setting - pages中，在Custom Domain填上刚刚添加解析的域名并保存即可。 完成，请点击"},{"title":"【github】使用my-json-server建立线上测试api库","date":"2021-11-27T14:21:49.000Z","url":"/2021/11/27/cxy/other/git-my-json-server/","tags":[["实用开源代码or工具","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81or%E5%B7%A5%E5%85%B7/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" my-json-server点击访问：my-json-server 1. 创建db.json文件并提交至master/main 2. 请求方式访问 [你的用户名]/[你的仓库名]，可以获取到api列表 比如，我的地址为： 点击页面提供的链接就可以访问到对应的api posts接口数据接口数据"},{"title":"babel配置","date":"2021-10-24T22:21:49.000Z","url":"/2021/10/25/cxy/framework/babel/","tags":[["babel","/tags/babel/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、使用安装 配置文件Babel 有两种并行的配置文件格式，可以一起使用，也可以独立使用。 全项目配置babel.config.json/babel.config.js文件 注：可以是js文件，可以是json文件 Babel在项目根目录中自动搜索babel.config.json文件，或使用受支持扩展名的等效文件 文件相关配置.babelrc.json/.babelrc.js文件 注：可以是js文件，可以是json文件Babel通过从正在编译的“文件名”开始搜索目录结构来加载.babelrc.json文件，直至找到包含package.json的目录下。 二、预设预设是指预先在babel内部设置好的插件，可以直接使用。 示例： 1. preset @babel/preset-env 用于编译 ES2015+ 语法 @babel/preset-typescript for TypeScript 编译ts，替代了ts-loader @babel/preset-react for React使用preset预设在配置文件中添加presets字段，执行顺序是从右到左。 2. targettargets 是需要兼容的浏览器版本 他的值有： android, chrome, deno, edge, electron, firefox, ie, ios, node, opera, rhino, safari, samsung 可以设置成一个string，比如 &gt; 0.5%, last 2 versions, not dead 意思是有大于百分之零点五的人使用，前两个版本，并且没有废弃 3. useBuildInsuseBuildIns需要安装corejs使用 比如： false： 默认值，不做任何语法转换 usage：Babel 将检查你的所有代码，以便查找targets环境中缺失的功能，然后只把必须的 polyfill 包含进来 entry：引入所有的polyfill包，必须在入口文件加入 import &quot;core-js/stable&quot; 才会生效 4. corejs安装的corejs版本号 ####什么是corejs?babel编译只能针对浏览器行为，es6语法规定的，如promise、async/await则无法转义。这种情况下则需要配置corejs。之前这个操作通过babel-polyfill插件，但在7.4之后该插件已被废弃。"},{"title":"坐在那里用仓颉和粤拼打字的练习","date":"2021-09-27T00:25:49.000Z","url":"/2021/09/27/other-yuewenzi/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"],["粤语","/tags/%E7%B2%A4%E8%AF%AD/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 給 kap1及 kap6吸 kap1 西 sai1 攻 gung1良 loeng4 眼5體 tai2積 zik1狼狽爲奸gaan1 跟 gan1斤 gan1 鬆sung1綁bong2 h：w珊saan瑚wu4 安on1全cyun4 染jim5 明ming4白baak6 欧au阳joeng4克hak1 戰zin3國gwok3海hoi賊caak ji极kap端dyun qi騎 ke4 海hoi2洋joeng4 契kai3機gei1 源jyun4頭tau4 蓉jung4兒ji4 終身監禁gaamgam"},{"title":"粤拼总结笔记","date":"2021-09-25T00:25:49.000Z","url":"/2021/09/25/other-yueping/","tags":[["粤拼","/tags/%E7%B2%A4%E6%8B%BC/"]],"categories":[["奇奇怪怪的积累","/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A7%AF%E7%B4%AF/"]],"content":" 粤拼教学：点击访问 七个主要元音：aa e i o u yu oe粤语可以多个韵母组合 双元音元音和元音的组合 除了元音与元音的互相组合外，元音一般可以加：m/n/p/t/k/ng 19个声母b p m f d t n l g k h gw kw w z c s j ng 七个主要元音 + maameimouyuoe 七个主要元音 + naaneinonunyunoe 不存在加n 七个主要元音 + ng iu也有后面介绍。 七个主要元音 + p 七个主要元音 + t 七个主要元音 + k iu也有后面介绍。 aa和a长aa 短a oe和eooe发音长（🤮）eo发音短 （鹅噢）eo发音类似拼音（e）粤语里的e发音和拼音e不一样 前面说要补充的ng和k的两个ing ik ung uk"},{"title":"我的喵有时候超级聪明,有时候又超级笨","date":"2021-09-23T04:00:38.000Z","url":"/2021/09/23/diary/diary-sxh%20copy/","categories":[["生活","/categories/%E7%94%9F%E6%B4%BB/"]],"content":" 可撸可抱可亲亲。怎么样都不生气。通人性，很多情况下知道我在说什么。很粘人，我上厕所因为要在浴室，总担心我淹死，只要不让它进来在我脚边蹲着，它就叫的相当凄惨。然后我站起来冲水的时候，它听见冲水的声音，就站起来往外走。明明自己超级害怕浴室。 对人如春风般和睦，对其他物种们如饿狼般凶残。我养了喵之后，屋里再也没有虫了。。自从我亲眼见到。。。算了，有些东西不能细想。 喜欢撒娇娇，我睡觉手摊在旁边，第二天起来手掌上一定会多个喵头。可以明白我的指令，如果我把它摆成一个姿势，它不喜欢就喵喵的反抗，但如果我重复五六次，它就明白了我是想让它保持这个姿势。 熟悉我的说话口气，知道我什么时候生气什么时候不生气。我普通生气的时候赶紧卖萌撒娇娇打滚滚，我生大气的时候就躲起来，可是它不知道我很生气的时候它越躲起来我越生气，特别是往特别脏的床底下钻的时候。 每天喜欢和我玩捉迷藏，它的捉迷藏理念就是我看不见你，那你肯定也看不见我。所以它总是把头藏起来，把身子露在外面，就当藏好了。唔 还有笨的情况就是可能因为从没出过门，是个路痴。我住在七楼左边，如果把它放六楼，或者五楼，或者四楼，它就会对着四五六楼左边一直喵。 每天我回来喜欢在门口迎接，以至于有一次太久不见，我半夜回来之后提着大包小包的行李，它窜到门口来接我，结果不小心给它关外面了。。我还没有意识到，然后收拾东西到四五点，听见外面一直有喵在凄惨的叫，我还想这谁家的喵大半夜的搁这儿叫，结果又收拾了一会儿才发现，吖！原来是大喵在叫。 大喵年纪比较大了，有时候我会很害怕，它的后槽牙也开始出问题了，感觉眼睛好像最近会过敏。 因为断网玩这个东西玩了半个多小时 "},{"title":"在自己的网站中集成h5音乐播放器","date":"2021-09-11T10:48:34.000Z","url":"/2021/09/11/cxy/other/aplayer/","tags":[["实用开源代码or工具","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81or%E5%B7%A5%E5%85%B7/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 简介： APlayer 是一个可爱的 HTML5 音乐播放器。（官方原话） 地址：点击访问 安装使用 npm: 使用 Yarn: 使用 使用模块管理器: 参数介绍（可见官网） 名称 默认值 描述 container document.querySelector('.aplayer') 播放器容器元素 fixed false 开启吸底模式, 详情 mini false 开启迷你模式, 详情 autoplay false 音频自动播放 theme '#b7daff' 主题色 loop 'all' 音频循环播放, 可选值: 'all', 'one', 'none' order 'list' 音频循环顺序, 可选值: 'list', 'random' preload 'auto' 预加载，可选值: 'none', 'metadata', 'auto' volume 0.7 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 audio - 音频信息, 应该是一个对象或对象数组 audio.name - 音频名称 audio.artist - 音频艺术家 audio.url - 音频链接 audio.cover - 音频封面 audio.lrc - 详情 audio.theme - 切换到此音频时的主题色，比上面的 theme 优先级高 audio.type 'auto' 可选值: 'auto', 'hls', 'normal' 或其他自定义类型, 详情 customAudioType - 自定义类型，详情 mutex true 互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器 lrcType 0 详情 listFolded false 列表默认折叠 listMaxHeight - 列表最大高度 storageName 'aplayer-setting' 存储播放器设置的 localStorage key "},{"title":"bodymovin使用","date":"2021-08-11T10:48:34.000Z","url":"/2021/08/11/cxy/other/bodymovin/","tags":[["实用开源代码or工具","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81or%E5%B7%A5%E5%85%B7/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 最近要做一个复杂嘅年度报告交互动画，年底惊喜夜又要做年度报告又要做，时间只有一晚黑。。搵了好耐终于畀我搵到一個bodymovin同埋lottie-web可以用嘅。捻住記下先la~ Bodymovin 简介Bodymovin是一个开源的JavaScript库，它用于将After Effects动画转换为可在Web上播放的HTML5动画。它使用Adobe After Effects的动画数据，将其转换为可在Web浏览器中播放的JSON文件。 使用Bodymovin的步骤： 在After Effects中创建动画，确保它们满足Bodymovin的要求：所有元素都必须使用2D变换，而不是3D变换，并且不能使用任何第三方插件。 在After Effects中安装Bodymovin插件，它可以从Github上下载。 将动画导出为JSON文件。 将JSON文件上传到您的网站，并使用Bodymovin JavaScript库在网页上播放动画。 在网页上定制动画，以获得最佳效果。 AE端：1. 官网下载bodymovin后，安装并打开github地址提示：mac m1系统请通过ZXP Installer安装。 2. 左侧选择要导出json的图层，右侧选择导出json的文件夹。完成后点击”render”即可。 提示：若遇到写入不成功的问题，请检查是否开启脚本写入文件。位置：After-Effect - 首选项 - 脚本和表达式 详细代码（js）webpack(5)中，处理图片和json webpack4用file-loader同埋url-loader处理，代码不写了。 入口文件，安装并引入bodymovin同埋json同埋图片如果图片较多，可以像我一样处理，用webpack的require.context方法，一次性引入所有图片（es6的按需引入也行，看自己呗。） require.context是webpack提供的一个函数，它可以接受三个参数：一个要搜索的文件夹目录，一个是否搜索子目录的布尔值，一个匹配文件的正则表达式。它可以返回一个函数，这个函数可以接受一个参数，这个参数是要引入的文件的相对路径，然后它就会返回这个文件的模块。require.context可以帮助我们实现按需引入模块的功能，从而减少代码体积。 扩展：(svg矢量图形转换为标签)[]完成。！。！。！。！。！。！。！。！。！。！。！。！。！。"},{"title":"【Midjourney】用ai绘画生成的图","date":"2021-08-03T07:23:38.000Z","url":"/2021/08/03/paint/paint-picture2%20copy%202/","tags":[["ai绘画","/tags/ai%E7%BB%98%E7%94%BB/"],["Midjourney","/tags/Midjourney/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 今天在discord玩了特别有意思的ai绘图，生成的图有些很糟糕，有些还是挺好看的~但基本不会生成你脑海中的图，觉得可能适合策划用吧，和设计沟通时可以更具象的去描述他自己想要的那种什么五彩斑斓的黑啥的。。。 记一下我的描述关键字There are many flowers on a skull,32k, 3D shading, Tone Mapping, elaborated, Procreate, the last of us look alike scene, Cinema 4D, ROMM RGB, color grading, retouch, blender, V-ray 下面是两张discord看到感觉比较好的。lake boat blackduck bluesky one pumpkins , intricate, elaborate, by artgerm and greg rutkowski and alphonse mucha, cinematic lighting, 32k, 3D shading, Tone Mapping, Ray Traced, Diffraction Grating, Crystalline, Lumen Reflections, Super-Resolution, gigapixel, color grading, retouch, Blender, V-ray, Procreate, zBrush, UE5, Cinema 4D, ROMM RGB, Adobe After Effects, tight shot, sharp focus –ar 16:9 –test –creative –upbeta santa claus guitarist of the death metal band , HD, ultra detailed, hyper realistic, fine detail etc, cinematic high detailed, octane render, ultra realistic, unreal engine, 8k –ar 9:16 –test –creative –upbeta a 20m-long flying dragon attacking HMS Warrior in the ocean, detailed, cinematic, 4k –ar 16:9 lake boat blackduck bluesky one pumpkins , intricate, elaborate, by artgerm and greg rutkowski and alphonse mucha, cinematic lighting, 32k, 3D shading, Tone Mapping, Ray Traced, Diffraction Grating, Crystalline, Lumen Reflections, Super-Resolution, gigapixel, color grading, retouch, Blender, V-ray, Procreate, zBrush, UE5, Cinema 4D, ROMM RGB, Adobe After Effects, tight shot, sharp focus –ar 3:5 –test –creative –upbeta –upbeta –upbeta one pumpkins , intricate, elaborate, by artgerm and greg rutkowski and alphonse mucha, cinematic lighting, 32k, 3D shading, Tone Mapping, Ray Traced, Diffraction Grating, Crystalline, Lumen Reflections, Super-Resolution, gigapixel, color grading, retouch, Blender, V-ray, Procreate, zBrush, UE5, Cinema 4D, ROMM RGB, Adobe After Effects, tight shot, sharp focus –ar 3:5 –test –creative a knight holding a longsword downward on purple wasteland, dark night with heavy rain and lightening, gloomy, dark, horror –ar 16:9 "},{"title":"【npm】常见参数的区别","date":"2021-07-17T08:01:08.000Z","url":"/2021/07/17/cxy/npm-dependencies/","tags":[["node","/tags/node/"],["npm","/tags/npm/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" dependencies 与 devDependencies的区别：dependencies：它包含的依赖包是需要发布到生产环境中的，是项目正常运行必须依赖的包。devDependencies：它包含的依赖包只在开发时使用，不用于生产环境，如果只需要项目正常运行，则不必安装这里面的包。 ## npm install packageName：安装某个包到项目中 默认情况下，不加参数。会安装包，并将依赖包的名称添加`package.json`中的`dependencies`字段。 1. --save参数 添加--save参数，与默认情况效果相同。会安装包，并将依赖包的名称添加到package.json中的dependencies字段。 2. --save-dev参数 添加--save-dev参数，会安装包，并将依赖包的名称添加到package.json中的devDependencies字段。 npm install： 初始化项目####1. 无参数： 直接初始化 我们常用npm install初始化项目，安装项目所需的依赖。但更深入的细节是：直接使用npm install时，项目package.json中dependencies字段和devDependencies字段中的依赖包都会被安装。 2. –production参数 添加--production安装项目所需的依赖时，只有dependencies字段中的依赖包会被安装，devDependencies中的依赖包不会被安装。 3. –only=dev参数 添加--only=dev安装项目所需依赖时，只有devDependencies字段中的依赖包会被安装，dependencies字段中的依赖包不会被安装。与添加--production的效果刚好相反。"},{"title":"【webpack5】进阶部分总结（一）","date":"2021-05-31T00:31:49.000Z","url":"/2021/05/31/cxy/webpack/webpack2/","tags":[["webpack","/tags/webpack/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" SourceMap1. 解决问题：报错时，报错的是编译后的代码，不好调试。 2. SourceMap是什么：源代码映射，包含源代码和构建后代码每一行每一列的代码映射关系。它会生成一个xxx.map，当构建后代码出错了，会通过xxx.map从构建后代码出错位置，找到映射后源代码出错位置。 3. 使用方法：在webpack的devTool文档中，souceMap的值有很多种情况，但实际开发只关心两种情况 · 开发环境：cheap-module-source-map只包含行映射，打包编译速度快。 · 生产环境：source-map包含行列映射，打包编译速度慢 生产环境下必须得关注列，因为生成模式下代码就压缩成一行了，不关注列根本不知道在哪里报错。 HMR：热模块替换hot module replacement：提升打包构建速度解决痛点：如果只修改了某个模块代码，webpack会将所有模块重新打包，那会很慢。当项目很大的时候，打包速度会越来越慢，所以需要更快些。配置方法：其实是默认的，不需要去写hot:true也可以。 当设置了hot: false时，那么在修改文件时（css），其实整个文件是会重新打包的（浏览器会刷新）。js即使开启了热模块替换（HMR），修改了还是会整个重新加载 one of：每个文件只能被其中一个loader处理webpack的loader会被每个文件匹配一遍，性能会很慢。当确认某个文件只会被一种loader处理时，那么设置匹配到一个loader之后，就不再处理下面的loader。这样也可以提升性能。写法： include exclude开发时会使用第三方的库或插件，比如echarts、lodash等。他们是已经编译好的，在node_modules中，所以处理js文件时，要排除node_modules的文件。 ESlint和Babel的缓存：每次打包都要重新检查eslint和babel编译会损耗性能，所以可以开启缓存。只有第一次打包需要检查eslint和编译babel，之后再次修改只检查和编译修改过的文件即可了。 Thread 多进程现在处理js文件，基本都是用eslint先检查，在用babel编译，再用terser压缩。文件大的时候会比较慢。现在的cpu都是多核的，可以启动多进程。###1. 安装threadsudo cnpm i thread-loader###2. 引入thread-loader位置放在需要处理的loader的前面，比如babel-loader前面。works: threads eslint 中 压缩代码使用的terser虽然是默认的，但如果想用多线程处理，就也需要写出来 optimization中（or plugins中） 文件少的时候没有必要开启，反而更慢的。因为进程启动也是需要时间的。 Tree Shakingtree shaking依赖js模块化，不能用于commonjs，用于描述和移除没有用到的js代码自动配置，无需手动配置。 减少Babel生成文件的体积 babel-runtime点击查看babel对一些公共方法使用了辅助代码，默认情况下辅助代码会被添加到每一个需要它的文件中，这样会使打包体积非常大。为了避免这样的情况，可以将这些辅助函数提出到一个npm包中，然后在用到的时候，再单独引入，这样就做到了复用。这个包就是@babel/runtime，之后每次需要用辅助代码转换时，require进去这个包，就可以减少代码体积。 如：下面这段代码是class语法被转译时加入的辅助代码，如果每个需要转译的class就这么长，代码体积就会很大。 下面是使用@babel/runtime包后，用require引入的方式，替代了上面的辅助代码片段，可以看到使用这种方式代码比较简洁。 但如果每个用到的地方都去手动替换这个包引入，出错几率大，所以就有了@babel/plugin-transform-runtime这个包。可以帮我们自动在需要的地方引入。@babel/plugin-transform-runtime：禁用了babel自动对每个文件的runtime注入，并且使所有辅助代码从这个包引入 压缩图片一个插件。 CodeSplit多入口1. 配置方法entry改为对象，output的filename换成[name].js 2. 提取公共模块如果所有的js都在一个文件中，体积太大了。如果只需要渲染首页js，其他文件不应该加载。所以进行代码分割，生成多个js文件，渲染哪个文件就用哪个js。 单入口： 多入口： 打包出来如图： 3. 按需加载js有些暂时不需要加载的文件，如果一出来就加载，会阻塞之后的资源。所以可以在需要的时候再加载。 我新建了一个count文件，内容如下： 在入口文件中动态加载count。 效果：原本是七个js文件####点击后加载第八个js文件 ####内容是count 如果动态导入的是函数的话，用res.函数名调用4. 为动态导入的模块在编译时重命名webpack默认是可以给动态模块命名的，但有点丑。如果想自己命名的话可以使用内联注释 具体的方法：（1） 动态引入的时候这样写 （2） 在output中配置chunkFilename （3）再次打包，名字就会变成自己的命名了 5. codesplit 统一命名对入口文件来说，可以叫main.js，为了方便开发，像chunk文件可以加一个.chunk.js，然后所有的媒体文件，如果每一个loader里面都去单独指定一遍，会比较麻烦。此时可以在output中配置 6. preload与prefetch共同点： 两者的概念都是预加载，缓存下来资源 只加载不执行 都有缓存 兼容性都很差####区别： preload：告诉浏览器立即加载资源 prefetch：告诉浏览器在空闲时加载资源 preload优先级高，prefetch优先级低。 preload只能加载当前页面用的，prefetch可以加载之后页面用的。现阶段使用preload-webpack-plugin插件 7. network cache8. Core.jsbabel可以转箭头函数、…这样的，但无法转换async、await、promise，这时就需要core.js。 1. 什么是corejs?core-js 它是JavaScript标准库的 polyfill（垫片/补丁）, 新功能的es’api’转换为大部分现代浏览器都可以支持运行的一个’api’ 补丁包集合。 2. 使用方法（1）直接引进首先安装corejs 然后在入口引入import ‘core-js’这种方法的坏处是会将core-js全部引入，会使得包体积很大。所以一般不会这样引。 （2）按需引进将需要的引进去即可。比如用promise，那么就写 安装后是有提示的，不用背。 （3）智能引进配合babel使用。在babel.config.js中配置 PWA 渐进式网络应用程序基于serviceworker实现，但也有很严重的兼容性问题点击访问官网项目离线时候也可以访问。 1. 安装 2. 在入口文件引入 3. 配置webpack插件 4. 重新打包会自动在dist目录下生成service相关文件如图 5. 看效果（1）由于service在dist目录下，所以需要在dist目录部署时才能使用。（2）使用http-server在dist目录下可以模拟启动一个服务器。（3）在network这里调成ofline，可以模拟断网，刷新后，会发现页面还是会加载。由于兼容性差，所以现在的普及率不大。 module chunk bundle的区别Module：能被import的文件，都是模块，无论是js、图片或者别的。在webpack中一切都是模块。Chunk：是多个模块组合而成的，如entry、splitChunk。entry是入口文件，入口文件中import的模块可能不止一个，所以是多个模块组合而成。splitChunk是提取公共代码，很多需要提取的代码被import，所以是多个模块组合而成的。Bundle：最终的输出文件。"},{"title":"【webpack5】基础部分总结","date":"2021-05-24T22:21:49.000Z","url":"/2021/05/25/cxy/webpack/webpack1/","tags":[["webpack","/tags/webpack/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、五大核心概念mode：开发模式development/生产模式productionentry：入口，从哪个文件开始编译output：出口plugin：插件loader：写在module中，加载器 二、基本配置固定在根目录，新建一个文件名为webpack.config.js内容如下： 新建src文件夹，在src文件夹下建立main.js，然后执行npx webpack就会自动打包。 三、处理资源注：多个loader配合使用时，处理顺序是：从下到上，从右到左 的顺序 1. css因为webpack只能识别js资源，所以要处理css需要用loader如加一个css-loader，先安装css-loader在开发环境中，然后在module中加载rules 对于一条规则，也可以使用多个loader，在use中配置。 常见的处理样式文件的loader：css-loader ：处理css文件less-loader sass-loader style-loader：处理style标签内的样式stylus-loader：使用模块化的方法去写css代码stylus：是一种写css的方式，没有花括号没有分号，用缩进的方式去代替大括号，后缀名为styl 2. 图片资源webpack4使用file-loader和url-loader处理图片file-loader:将图片转换为webpack能识别的资源。url-loader:将小于某个大小的图片转换为base64处理图片并不需要loader，webpack5自带默认处理图片，只需要在loader中配置 3. 修改打包资源的路径像输出时，默认js、图片等等都会在一个目录中，现在想要配置成其他目录。 重新npx webpack就变成了这样######图片资源路径的修改：在module/rules的对应loader中配置generator 打包效果： 4. 自动清空上次打包资源webpack不会自动删除上次打包内容，可能会造成重叠，文件很多，可以配置每次打包自动删除之前的打包结果。配置方法：clean：true 5.处理其他资源如视频、字体、excel等等，想统一处理的话，可以如下配置： 官网对于type: assert的几个值的介绍： asset/resource 发送一个单独的文件到输入目录并导出 URL。之前通过使用 file-loader 实现。asset/inline 导出一个资源的 data URI（如，base64）。之前通过使用 url-loader 实现。asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。 6. ESLINTeslint：用来检测js和jsx语法，可以管理缩进、规则是否正确，让代码更加健壮。配置文件：eslintrc.js在webpack4中使用loader处理。在webpack5中使用plugins去处理。 如何使用？根目录新建eslintrc.js，然后在webpack.config.js中配置plugin官网文档：点击查看plugins要用require引入。 简单的eslintrc.js的配置 如果有不需要检查的文件，新建eslintignore可以不检查。 7. babel还是一样，webpack官网搜babel，就会出来babel-loader的配置，复制过来根据自己的需要做修改。根目录新建babel.config.json，其中配置babel 如果不写上面的options，那么会用babel.config.json中的配置去转换代码的。@babel/preset-env：智能预设，允许使用最新的js@babel/preset-react：用来编译jsx@babel/preset-typescript：用来编译ts。 targets：需要兼容的浏览器版本，可以用这些属性 ： android, chrome, deno, edge, electron, firefox, ie, ios, node, opera, rhino, safari, samsung也可以设置成一个string，比如 &gt; 0.5%, last 2 versions, not dead 意思是有大于百分之零点五的人使用，前两个版本，并且没有废弃 useBuiltIns有几个值false：默认值，不做任何语法转换usage Babel：将检查你的所有代码，以便查找targets环境中缺失的功能，然后只把必须的 polyfill 包含进来entry：引入所有的polyfill包，必须在入口文件加入 import “core-js/stable” 才会生效 useBuiltIns 需要搭配 core-js，并且需要在配置文件里面声明。目前core-js最新版本是3.x，也可以指定2.x。npm i core-js -S “corejs”: “3.6.5” 8. 处理html点击查看首先js打包文件可能名字是动态生成的，需要自动引入js到html，才会确保不出错的所以可以自动生成index.html文件，插件为HtmlWebpackPlugin 首先插件会自动生成一个index.html，template中写的index.html意思是通过template里的这个index.html生成一个index.html到dist目录中，所以两个不是一个意思。 三、搭建开发服务器安装webpack-dev-server 四、生产模式的搭建生产模式也就是线上实际使用的代码，会被压缩。因为体积小，加载就快。一般会新建一个config/webpack.dev.js做开发环境的搭建。一般会新建一个config/webpack.prod.js做线上环境的搭建。然后建立webpack.config.js，将两个配置引入。 改动的主要地方1、如果配置文件新建一个文件夹放起来，那么需要将所有绝对路径改为上层路径。2、mode的更改3、开发模式删除output，生产模式删除devServer 常见打包命令：npx webpack：自动打包命令npx webpack serve --config ./config/webpack.dev.js ：运行./config/目录下的webpack.dev.js配置文件，并启动服务npx webpack --config ./config/webpack.prod.js ： 运行./config/目录下的webpack.prod.js配置文件 五、css处理1. css单独提取之前处理css的方法：是将css用css-loader变为webpack可识别的文件后在入口文件main.js使用imort引入css再使用style-loader将css转换为网页中的style内联标签####使用MiniCssExtractPlugin：将style-loader生成的style标签内的css单独提取为css文件，注意必须要安装style-loader 入口文件main.js中： 注： 要生成页面内style标签的形式，那么css-loader和style-loader要同时使用。 要生成单独的css文件，那css-loader和miniCssExtractPlugin.loader要同时使用。（不用style-loader）2. 兼容性处理postcss-loader：兼容性处理，需要安装postcss与postcss-loader，配置在css-loader和style-loader之后，在less和sass的前面，这个是固定的噢在package.json中，配置 然后按照官网去配置loader 3.CssMinimizerPlugin压缩css一般来说，压缩操作在webpack5中都放进optimization中，虽然放在plugins中也可以，不太规范拉。~ 常见的loader总结： raw-loader 将文件导入为字符串 url-loader 将文件作为 data URI 内联到 bundle 中 file-loader 发送一个单独的文件并导出 URL 各种css-loader postcss-loader：兼容性处理，需要安装postcss与postcss-loader，配置在css-loader和style-loader之后，在less和sass的前面，这个是固定的噢##常见的plugin总结： MiniCssExtractPlugin：将style-loader生成的style标签内的css单独提取为文件，注意必须要安装style-loader CssMinimizerWebpackPlugin: 压缩css ESLintPlugin：eslint检查 terserWebpackPlugin：压缩代码 "},{"title":"Proxy略略略略记","date":"2021-05-21T01:03:38.000Z","url":"/2021/05/21/cxy/js/js-proxy/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、proxyproxy就是一个拦截器，拦截了原来的对象之后，可以对这个对象进行自己的更改，也可以防止别人对对象进行某种更改，然后可以输出修改后的monitor，且不影响原对象。 1. proxy的声明（1）可以声明后直接在handler里面写对象 （2）下面这种声明方式 2. get/set/has/等拦截方法 二、 reflect（1） 名称和用法与proxy一样（2） ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。（3） Reflect 对象对某些方法的返回结果进行了修改，使其更合理。（4） Reflect 对象使用函数的方式实现了 Object 的命令式操作。 为什么用reflect，要尽量避免用原生的Object方法，通过Reflect方法调用会比较合理和方便。 在vue3的源码中，原先的数据驱动视图的方法Object.defineProperty被替换成了Proxy来实现，在Proxy内部操作数据时就用了Reflect去调用对象方法。"},{"title":"【github】私有仓库如何避免每次pull都要输入用户名密码","date":"2021-05-14T22:21:49.000Z","url":"/2021/05/15/cxy/other/github-siyoucangku/","tags":[["github","/tags/github/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一. 使用https提交方式：1. 使用git config命令在本地全局设置用户名和邮箱git config --global user.name &quot;username&quot;：全局添加用户名git config --global user.email “someone@mail.com”：全局添加邮箱git config --global credential.helper store： 该命令用于为credential.helper设置值，避免重复输入用户名密码 2. 执行完成以上后，运行cat ~/.gitconfig会发现.gitconfig多出了以下代码 3. 再次git pull，只需输入一次密码，之后就可以不再输入密码了。 二、使用ssh提交方式：1. 生成秘钥执行ssh-keygen。如果原本没有秘钥，就一路回车。如果有秘钥且秘钥关联了其他网站的项目，比如gitlab什么的，那就需要重新指定目录。 2. 获取公钥执行 cat 你指定的目录/id_rsa.pub获取公钥（如果没指定，就是 ~/.ssh/id_rsa.pub） 3. github中，新建ssh 4. 复制公钥粘贴保存即可。"},{"title":"【node】path.join和path.resolve的区别","date":"2021-05-11T04:01:08.000Z","url":"/2021/05/11/cxy/node-path/","tags":[["node","/tags/node/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 参数拼接 path.join([path1][, path2][, …])path.join()方法可以连接任意多个路径字符串。要连接的多个路径可做为参数传入。 path.join()方法的参数为string，可以加多个参数，最后会拼在一起形成一个地址，若不是string则报错 路径解析：path.resolve([from …], to)path.resolve()方法可以将多个路径解析为一个规范化的绝对路径。其处理方式类似于对这些路径逐一进行cd操作，但resolve在未执行时不会校验其合法性（就是可以不存在这个地址） 相当于 举例： "},{"title":"模块化之AMD和CommonJS","date":"2021-04-13T04:00:38.000Z","url":"/2021/04/13/cxy/js/js-amd/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、AMD概念：异步加载模块的规范，即，加载模块不会阻塞之后代码的执行。AMD是为浏览器环境所设计的，如requirejs。 用法：1. 定义模块AMD的模块，通过define函数定义在闭包中，格式如下： id: 模块名，可选，若不写，则模块为匿名模块。 dependencies: 所要依赖的模块列表，字符串数组类型，可选。若未指定dependencies，默认值为[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]。 factory: 模块的具体实现，类型为对象或函数。 2. 引入模块通过require引入 例子：下面通过requirejs写个例子： 1. 建立如下的目录结构： 2. 在index.html引入requirejs，并通过data-main标识入口文件要注意入口文件是唯一的。 3. 在moduleA、moduleB中定义模块moduleA.js moduleB.js main.js 也可以使用require.config去定义公用路径： 运行结果： 二、CommonJS同步加载模块的规范，即，只有加载完成，才能执行后续操作。CommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，如nodejs。 用法 CommonJS 是同步加载模块，但其实也有浏览器端的实现，其原理是将所有模块都定义好并通过 id 索引，这样就可以方便的在浏览器环境中解析了，可以参考 require1k 和 tiny-browser-require 的源码来理解其解析（resolve）的过程。 更多关于 CommonJS 规范的内容请查看 。 CommonJS的写法比AMD要简单明了很多，不举例了。"},{"title":"模块化之ES6","date":"2021-04-12T04:00:38.000Z","url":"/2021/04/12/cxy/js/js-mkh/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、export命令1. 基本使用 或 2. export也可以输出函数和类 3. as关键字 4. 下面这种写法是错的 正确写法： 二、importimport命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 三、export default1. 基本用法 export default 导出的一定是一个匿名的东西，即使接受的不是匿名函数或变量，因为从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。 2. export default的正确写法 在export default时，import导出不用大括号，除非是解构赋值。 从其他文件导入时： 四、其他注意点1. commonJS和import虽然通过babel转码，commonJS的require和import可以写在一起，可是由于import是静态解析阶段执行，所以在require引入前，import会先于它执行，这样有可能会导致错误。 2. import的简易写法当导出下面的文件时 引入可以这样写 或 3. import 和 export 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 五、import()import()用于动态加载，它返回一个 Promise 对象。下面是一个例子。 import可以用作1. 条件加载 2. 按需加载 3. 动态模块路径"},{"title":"[2021-04-07]水仙花观察日记","date":"2021-04-07T04:00:38.000Z","url":"/2021/04/07/diary/diary-sxh/diary-sxh2/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-06]水仙花观察日记","date":"2021-04-06T04:00:38.000Z","url":"/2021/04/06/diary/diary-sxh/diary-sxh4/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-05]水仙花观察日记","date":"2021-04-05T04:00:38.000Z","url":"/2021/04/05/diary/diary-sxh/diary-sxh5/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-04]水仙花观察日记","date":"2021-04-04T04:00:38.000Z","url":"/2021/04/04/diary/diary-sxh/diary-sxh7/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-03]水仙花观察日记","date":"2021-04-03T04:00:38.000Z","url":"/2021/04/03/diary/diary-sxh/diary-sxh3/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"【chrome插件】Ajax Interceptor修改 ajax 请求的响应文本","date":"2021-04-02T22:21:49.000Z","url":"/2021/04/03/cxy/other/chrome-ajax/","tags":[["开发效率","/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、介绍Ajax Interceptor是一个用于修改 ajax 请求响应的 chrome 扩展，修改ajax请求并返回结果的chrome插件。你可以用该插件修改页面上Ajax请求的返回结果。 二、安装Ajax Interceptor下载安装地址：点击跳转 三、使用 安装完成后，点击图标并展开 点击加号，在network中找到需要修改的请求 将从network获取到的地址和json数据粘贴至框中 点击JSON Editor，即可编辑需要修改的字段 刷新或重新请求后，即可生效。 ✨注意： 1. 第一次安装完，请刷新你需要使用的页面，或者重启浏览器。 2. 当你不需要使用该插件时，建议把开关关上（插件icon变为灰色），以免对页面正常浏览造成影响。 3. 该插件只会在JS层面上对返回结果进行修改，即只会修改全局的XMLHTTPRequest对象和fetch方法里的返回值，进而影响页面展现。而你在chrome的devtools的network里看到的请求返回结果不会有任何变化。"},{"title":"[2021-04-02]水仙花观察日记","date":"2021-04-02T04:00:38.000Z","url":"/2021/04/02/diary/diary-sxh/diary-sxh/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"水仙花没有任何变化"},{"title":"[2021-04-01] 水仙花观察日记","date":"2021-03-31T20:57:38.000Z","url":"/2021/04/01/diary/diary-sxh/diary-sxh6/","categories":[["水仙花观察日记","/categories/%E6%B0%B4%E4%BB%99%E8%8A%B1%E8%A7%82%E5%AF%9F%E6%97%A5%E8%AE%B0/"]],"content":"今天我种下了一朵水仙花，我为它浇了水，施了肥，把它放到了温暖的阳光下，阿~可爱的水仙花请快快长大吧！"},{"title":"react18基础知识梳理","date":"2021-03-25T05:03:49.000Z","url":"/2021/03/25/cxy/framework/react/react/","tags":[["react","/tags/react/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 思维导图 一、jsxjsx中使用js表达式在jsx中js表达式是用&#123;&#125;括起来的，和vue一样。可以调用的有1.常规变量2.原生js3.三元运算符 列表渲染：map使用Object.keys去获取obj列表，再用map循环 style: 使用\\&#123;\\&#123;\\&#125;\\&#125; 条件渲染：三元表达式模版太长时，可以使用括号包裹，并可以换行。 模板精简将重合的部分提出放入函数中，在App()中可以调用 其他注意事项 jsx标签必须闭合，只有一个根节点 jsx标签换行，必须加小括号 jsx属性名采用驼峰命名法，如class-&gt;classNamefor-&gt;htmlfor 二、组件1. 函数组件 组件名称必须首字母大写 组件必须有返回值，且返回值为jsx模板，什么jsx都不返回则为null 使用函数名作为组件标签名。 2. 类组件 类组件类组件中必须使用render()方法去返回一个jsx结构，render方法必须要有返回值 类组件必须继承React.Component，并引入react 3. 事件绑定 事件格式为on+事件，函数组件可以直接调用方法，类组件调用用this.xxx方法 传递自定义参数的话，如果同时需要使用事件对象e和自定义参数的话，需要在外层套一层箭头函数传入 三、组件状态1. 类组件中数据驱动视图的基本写法在react hook出来之前，函数组件是没有状态的，所以这里统一通过类组件来讲解。现在，类组件已经不太常用了 使用state，修改state通过setState实现，setState通过继承而来 this有指向问题，要当心。在指定onClick中的方法时，必须要用this.xxx，如果没有传，则为undefined 2. react的状态不可变不要直接去修改state，修改数组和对象要重新使用setState去整体赋值 四、表单处理（input）使用react处理表单，一般有两种方式 受控组件 非受控组件（不常用） 1. 受控表单组件 受控组件就是input框可以被react组件状态控制的组件，可以实现双向绑定 双向绑定的步骤 input绑定onChange或onInput事件 value指定某个变量 事件在类中写好，然后在事件中使用setState去将input的value赋值给变量 2. 非受控组件 组件的状态和表单控件状态不同步(只是表单控件的初值和组件的state一致)。没有双向绑定使用createRef 五、组件通信1. 父子组件通信函数子组件通过参数props，类子组件通过this.props，函数组件可以通过参数解构接收， v也可以通过props接收的。父组件上定义传入子组件的变量 props：1. 只能单向，不能反过来修改。2. 可以解构赋值 如下，现在父组件的state种有一个message变量，想传入到子组件中父组件App.js： 子组件SonF（函数组件） 子组件SonC（类组件） 2. 通过子组件传递给父组件原理：子组件调用父组件传递过来的函数，并且将想要传递的数据当成函数的实参 不管是类组件或是函数组件都是以下步骤： 在父组件建立函数，传入子组件中 子组件用props接收父组件的函数，在函数中传递参数，然后在模板中执行函数 父组件形参接收子组件的传值即可。 以类组件举例： App.js中： 3.兄弟组件通信不想写了，反正就是两兄弟会通过父组件，进行数据的传递。一个子组件将数据传给父组件，父组件再将数据props给另一个子组件。 4.跨组件通信Context父组件像任意的子孙组件传值，可以使用Context。相当于vue的依赖传值。 步骤： 新建一个组件，专门用来导出Provider和Consumer，然后让需要Provider和Consumer的组件引入该组件。不可以在需要的文件中直接用React.createContext去新建，因为在不同文件中生成的是不同实例。 根组件App.js 需要引入的组件ContextComponent 中间组件SonA的内容 子孙组件内容 六、组件进阶1. children 属性（slot）children存在于props里面，所以可以通过解构赋值，也可以通过props.children去获取使用。表示该组件的子节点，只要组件内部有子节点，props中就有这个属性。类型包括： 普通文本 普通标签 jsx 函数 2. props校验有时候从父组件传过来的props，类型会不正确，比如子组件需要一个数组，而父组件传过来一个number，那么遍历就会出现问题。这种情况下，就需要props校验。相当于vue的 支持类型： 基础类型（array、bool、func、number、object、string） react元素类型： element 必填项： isRequired，也就是传属性时不能缺少这个属性。 特定的结构对象：shape 步骤： 安装prop-types 在需要的组件中导入prop-types 对应组件.propTypes = &#123;&#125;设定规则如下，表示名为ListItem的组件有一个lists被传进来，类型必须为array 完整代码： 七、组件生命周期只有类组件才有生命周期，因为类组件要实例化，而函数组件不需要。 初始化阶段：1. 执行顺序：constructor –&gt; render –&gt; componentDidMount2. 功能：constructor：创建组件时最先执行，初始化时只执行一次，现在用的不多了。render: 每次渲染时都会触发，所以不要在里面调用setState，有可能造成死循环。componetDidMount：组件挂载（dom渲染完成）后执行，初始化的时候只执行一次。所以一般进行网络请求和dom操作。 更新阶段：1. 执行顺序：render –&gt; componentDidUpdate2. 功能：render：每次渲染都会触发componentDidUpdate：组件更新后（dom渲染完成）触发。两个钩子里面都不要调用setState() 卸载阶段：componentWillUnmount：组件卸载（从页面中消失）时触发，一般用来执行清理工作（比如：清理定时器等） 三个阶段，五個鉤子 八、React HooksHooks：使函數組件更強大，更靈活的鉤子現在hooks暫時只能在函數組件中使用。因為它的作用就是為了讓hooks擁有狀態。 1. useStateuseState提供給變量修改數據的方法。 步驟： 從react中引入useState 使用useState聲明變量，聲明修改變量的方法[變量，修改變量的方法] 使用修改變量的方法修改數據注意：不能直接修改原值，必須調用修改變量的方法，在下面的例子就是setCount 2. useState數據的讀取和修改一句話：useState生成的初始值只在初次渲染生成，之後再次生成j都是用setstate修改得到的值！注意事項： 只能出現在函數組件中 不能用於if/for等嵌套結構中，只能寫在函數組件最外層處。3. useEffect 函數副作用對於react組件來說，祝作用時根據數據渲染ui，那麼副作用就是除此之外的全部操作。 常見的组件副作用1. 數據請求ajax發送2. 手動修改dom3. localStorage操作4. 当watch用：useEffect有两个参数，第一个是函数，第二个参数是数组，用来存放变量，当数组存放变量发生改变时，第一个参数逻辑处理函数将会被执行（类似于监听）vue的watch不一定是在dom渲染完畢之後執行，而useEffect一定是在dom渲染完畢後執行。5. 可以作为生命周期钩子使用，在每次render後執行（dom渲染後觸發） + 没有第二个参数时,组件的初始话和更新都会执行 + 空数组时，初始化调用一次之后不再执行，相当于componentDidMount + 有一个值的数组时，该值有变化就执行 + 有多个值的数组时，只要有一个值有变化就执行 4. useRef 用於獲取真實dom的方法 函數組件的useRef相當於類組件的createRef綁定在元素上獲取該元素，綁定在組件上可以獲取該組件的所有屬性和方法。 步驟： 引入useRef 使用useRef新建一個變量，傳入參數為null，在其中有current可以獲取到組件信息或dom元素 將該變量通過ref綁定到元素或組件上 假設現在有一個Test組件 需要在App組件中獲取Test組件的方法和屬性 testRef可以獲取到Test組件的方法與屬性，h1Ref可以獲取到h1這個dom元素。 對比類組件的createRef的用法 4. useContext 函数组件中的通信在类组件中使用createContext进行后代组件通信。函数组件中也需要使用createContext，两者在祖先组件中的写法一致。但函数组件中Consumer的部分需要变成使用useContext 在SonB这个后代组件中，使用useContext去代替Consumer，就可以获取到App传过来的count数据 5. useCallback()九、react-router1. 安装router ###1. BrowerRouter和HashRouter作用：包裹整个应用，一个react应用只需要使用一次两种常用的router: HashRouter和BrowerRouter HashRouter相当于vue的Hash模式地址域名后面会多一个#，比如 BrowerRouter相当于vue的History（html5）模式但这种模式需要后端配合，这个地址相当于前端为了好看生成的，不是真实的地址。如果直接访问某个二次跳转的链接，有可能404 2. Link用来指定导航链接 3. Routes符合Link条件的试图会渲染到Routes里。 4. Route用于指定导航链接，完成路由匹配。相当于vue的router-view 5. 编程式导航 - 跳转***react-router的跳转可以分为用Link跳转，和用useNavigate跳转两种。这里主要说useNavigate***的用法。 useNavigate直接跳转：对应vue的$router.push()，会在地址栈留下记录，可以回退。 useNavigate添加&#123; replace: true &#125;参数：对应vue的\\$router.replace()，不会在地址栈中留下记录，无法回退到该页面，一般用于登录后的回退。 步骤： 导入useNavigate 声明一个useNavigate方法 使用该方法，传入参数，第一个参数为地址，第二个参数为补充项，如上面说的是否要使用replace模式。 完整例子： 6. 跳转传参 searchParams &amp; paramssearchParams 和 params的区别：searchParams：地址为/index?name=xxx&amp;id=xxx的形式，可以获取问号后的参数params：地址为/index/111的形式，可以获取到111 #####步骤： 首先引入useSearchParams或useParams 初始化变量 通过变量获取参数若为searchParams，则使用以下的的形式获取： 若为params，则使用一下的形式获取： 7. 二级路由在route里面再配置route，然后在需要二级页面的地方导入outletApp.js中 Layout.js中 "},{"title":"面试题整理（持续更新）","date":"2021-03-20T09:58:32.000Z","url":"/2021/03/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/","tags":[["iv","/tags/iv/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":"jscall绑定nullcall和apply第一个参数为null/undefined，函数this指向全局对象 跨域解决方案cors和jsonp jsonp为什么会自动执行？又不是请求而是script标签当然会自动执行。。 css重排(reflow)和重绘(repaint) 重绘：某些元素的外观被改变，例如：元素的填充颜色 重排：重新生成布局，重新排列元素。 重绘不一定导致重排，但重排一定会导致重绘。 如何提高dom渲染性能？减少重排次数： 集中改变dom 分离读写操作 使用display: none之后再进行 dom的修改，就会避免重排 使用absolute或fixed脱离文档流，修改子元素就不会影响父元素以上的元素重排 固定会影响父元素重排的css，再去操作子元素的重排和重绘，这样就不会影响父元素之外的其他元素 优化动画，比如translate: 1s改为更长的时间，减少帧数。 网络websockethttp缓存策略"},{"title":"【2020-11-27】大喵的表情包上线拉！","date":"2020-11-27T05:23:38.000Z","url":"/2020/11/27/diary/diary-0612%20copy/","tags":[["生活","/tags/%E7%94%9F%E6%B4%BB/"],["绘画","/tags/%E7%BB%98%E7%94%BB/"],["表情包","/tags/%E8%A1%A8%E6%83%85%E5%8C%85/"]],"categories":[["绘画","/categories/%E7%BB%98%E7%94%BB/"]],"content":" 虽然全套的动态带静态表情包是我两天就全部做好的超级赶工品。。还是希望会有人下载用用看啵~ 之后有机会的话我会认真画的！绝对！可能。大概。。。也许。。。。。"},{"title":"typescript总结笔记","date":"2020-09-10T07:20:18.000Z","url":"/2020/09/10/cxy/js/typescript/","tags":[["typescript","/tags/typescript/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 什么是typescript？typescpt是一种静态类型语言。添加了类型的js，完全兼容js，写完后可以编译为js我觉得是用另一种更为严格和规范的方式去写js##静态类型语言静态类型语言中，变量的类型必须先声明，即在创建的那一刻就已经确定好变量的类型，而后的使用中，你只能将这一指定类型的数据赋值给变量。如果强行将其他不相干类型的数据赋值给它，就会引发错误。在静态语言中，一旦声明一个变量是int类型，之后就只能将int类型的数据赋值给它，否则就会引发错误，而动态类型则没有这样的限制，你将什么类型的数据赋值给变量，这个变量就是什么类型 强类型 VS 弱类型强弱之分，体现在对类型的检查严格程度上，弱类型语言对于变量类型的检查比较宽松，容忍隐式类型转换这种事情的发生。何为隐式类型转换，一般有两种形式： 相关类型之间隐式转换 不相关类型之隐式间转换一、基础类型1. ts有哪些基础类型？布尔、数字、字符串、数组、元祖、枚举、any、void、null、undefined、never、Object2. 定义数组： 3. 定义元组： 注意：访问越界元素会报错 4. 枚举：定义类型 5. nevernever是任何类型的子类型，可以复制给任何类型，但没有类型是never的子类型或可以赋值给never类型（除了never本身），即使是any也不能复制给never。never经常用于抛出异常的函数，或是死循环。 变量也可以是never类型，当他永不为真的类型保护所约束时。 6. voidvoid表示没有任何类型。和any完全相反。函数没有返回值时可以写void void变量没有什么作用，因为void变量只能赋值null或undefined。 7. 类型断言我可能有时候比ts更了解这个变量是什么类型，这时就可以用类型断言语法有两种第一种：尖括号 第二种：as 二、变量声明ts用const、let代替了var 三、接口1. 对象类型定义一个类型，让变量按照这个类型来具体实现 2. 函数类型 上面代码意思是，一个函数类型叫Square，它应该有两个参数，一个source类型string，一个subString类型string，返回boolean类型的值。 3. 类类型 接口亦可以继承 四、类 1. public、protected、private的区别：protected：可以继承，不可以在类外部使用private：不可以继承，不可以在类外部使用public：可以继承，可以在类外部使用 2. readonly： 3. getter、setter 4. 静态属性、静态方法使用static定义，只能用类名.方法/属性使用 5. 抽象类与抽象方法 6. 抽象类和接口的区别（1）abstract类abstract类是定义用来被继承的类。抽象类中可以有抽象方法，可以有普通方法。非抽象类也可以。但抽象类不能创建对象，普通类继承抽象类必须实现其方法，或将其定义为抽象方法。抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。 1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。2）抽象类不能用来创建对象；3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。4）非抽象类中可以有抽象方法，比如继承的时候，如果子类不想实现父类的抽象方法，则必须将该方法也定义为抽象方法(2) interface接口： 是对类的补充接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误） 而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现 抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。 五、函数 六、泛型（尖括号）1. 泛型变量一个函数在公用的时候，若同一个参数可能有多个类型or可能有多种返回值的情况下，如果写成any会不严谨 用下面这个就可以保证返回值与参数相同类型 2. 泛型类、泛型接口 七、枚举 八、高级类型1. 类型别名 2. 交叉类型也就是用’&amp;‘ 3. 联合类型也就是用’|’let arg: number | string = ‘sfsdfds’###4. 类型保护和类型断言typeof和instanceof （1）typeof （2）instanceof只对类有用。 九、Symbols十、迭代器for of 与for in 十一、模块（原：外部模块） “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 ECMAScript 2015里的术语保持一致，(也就是说 module X &#123; 相当于现在推荐的写法 namespace X &#123;)。 用法和js一致。 十二、命名空间（原：内部模块） “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 ECMAScript 2015里的术语保持一致，(也就是说 module X &#123; 相当于现在推荐的写法 namespace X &#123;)。 1. 命名空间的基本用法在一个文件中，有时候有些变量是不想定义为全局的，比如有ab两个类被c类引用，如果都定义为全局的变量，不好维护容易出错，可以只对外暴露出c类接口（export class C）给该文件其他部分使用。。 2. 复用将逻辑与业务分离，可以将一个namespace用另一个namespace引入如下面，用page引入components的命名空间components.ts文件： page.ts文件： 由于这种写法很难搞懂命名空间是在哪个文件中，所以最好在path.ts头部中用三斜线指定进行指定 ###3. 子命名空间 十三、三斜线指令三斜线指令仅可放在包含它的文件的最顶端。放在其他地方则会被当做注释去解析的。包括下面几个指令，去看官网吧 tsc -w 监听，自动编译tsc init 生成tsconfig.tsconfig的配置：outFileoutDirmodulerootDirtarget 十四、声明文件使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。说人话：就是第三方库定义的一些东西直接引进来ts识别不了，ts只能识别js有的和ts已经定义的东西。所以需要另外写一份声明文件告诉ts，然后ts就知道这个第三方库有这些变量就不会报错了。文件叫*.d.ts declare 就是用在声明文件中的。 全局变量 全局函数 带属性的对象 函数重载 可重用类型（接口） 可重用类型（类型别名） 组织类型 类 十五、项目配置tsconfig.json"},{"title":"【vue】vue2和vue3分别实现数据侦听","date":"2020-08-21T10:16:25.000Z","url":"/2020/08/21/cxy/framework/vue/vue-defineProperty/","tags":[["vue","/tags/vue/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" Object.defineProperty(obj, prop, descriptor)在js原生对象中，实现数据侦听的方法就是defineProperty。 使用示例如下： vue2中使用defineProperty中实现数据侦听建立一个html文件，dom结构如下 编写侦听函数 实现侦听的函数 当数据更改时，更新视图 proxy拦截代理，拦截对应的操作后，进行处理，会新生成一个对象，然后通过proxy生产的对象去改变原对象。 使用方法："},{"title":"class总结","date":"2020-07-21T05:03:15.000Z","url":"/2020/07/21/cxy/js/js-class/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、基本写法类的方法、属性、静态方法、静态属性、私有方法、私有属性继承、接口（没有）、抽象（没有）、final（这个有） 构造函数constuctor 实例属性可以使用this.xxx写在constructor方法中，也可以写在类的顶端。 实例属性不存在于原型链上，而是存在于单个实例中。如果constructor写了赋值，在创建实例时却没有赋值，那就会变成undefined拉 原型属性（使用prototype赋值）存在于原型链，用“类.prototype.属性名”可以调用到。 类的方法是默认定义在原型链上，供所有实例共享的。但在类内部定义的变量是属于单个实例的，不存在与原型链上。如果想在类外通过赋值的方法，定义属于原型链的属性，当然所有实例也都可以共享，但一旦修改所有实例的该属性都会修改，其实没有什么意义还容易出问题。所以虽然可以在原型链上定义实例，但一般来说没必要。除非真的确定这个属性在所有的实例上都是相同的。 getter、setter方法在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。get/set方法定义的变量不需要提前定义。set方法必须要传入value name在类内部，可以使用类名.name去调用，获取类的名字 Class表达式类可以用表达式的形式定义，在类外部调用时只能用表达式调用，如下面的例子，外部只能使用MyClass调用，但MyClass的实例还是属于Me 属性表达式类的属性名可以用表达式表示 ####静态属性静态属性定义在类上，不在实例上，所以只能用类名.属性名调用。定义静态属性的方法是在class外部，用类名.属性定义该属性 es6的规定，class内只有静态方法，没有静态属性，但现在有个提案是用static在内部定义静态属性，所以也可以如下定义 静态方法的定义： 私有方法和私有属性使用#定义私有属性。只能在类的内部使用(this.#count)，无法继承，无法在外部调用。暂时没有提供私有方法。 ####静态块有时候在类内部有一部分代码，是不用每次创建实例时都去调用的，比如静态属性的赋值。所以es2022规定了静态块，在类生成时只执行一次，主要用于对静态属性的赋值，之后新建实例就不再运行了。 new.target该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令，new.target会返回undefined ##二、类的继承 super方法与super关键字1. super方法super方法可以且只能在子类构造函数中调用，用来调用父类的constructor()，在子类的构造函数中必须要调用一次super() 2. super关键字super作为对象时，在普通方法中，指向父类的原型对象（Point.prototype）；在静态方法中，指向父类。由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。因为类中定义的方法本就是定义在原型链(prototype)上，所以super可以调用到类内的方法。但super没办法调用到类内的变量，因为类中定义的变量是存在于实例的。 在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。 在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。 "},{"title":"【练字】硬笔书法","date":"2020-05-24T05:23:38.000Z","url":"/2020/05/24/paint/paint-picture3/","tags":[["练字","/tags/%E7%BB%83%E5%AD%97/"]],"categories":[["练字","/categories/%E7%BB%83%E5%AD%97/"]],"content":" 字没几个，写都写了一天而且我发现即使练了字，我正儿八经写字还是那么难看虽然看起来没几个字，其实我写了一下午 "},{"title":"blender场景练习(low poly)","date":"2020-04-19T07:21:49.000Z","url":"/2020/04/19/jianmo/bl-practice2/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 这次在渲染方面学习到了粒子系统和着色器。着色器节点之后我会写文总结。就现在的bl版本，变化太快，这个版本有的节点，到下个版本可能就会被删除了。这一点让人很头大。改天需要下载keyshot，我还是喜欢用zb。雕刻什么的最好玩了吖~！~~~~！~~~~"},{"title":"blender场景练习1","date":"2020-04-03T04:21:49.000Z","url":"/2020/04/03/jianmo/bl-practice1/","tags":[["blender","/tags/blender/"]],"categories":[["建模","/categories/%E5%BB%BA%E6%A8%A1/"]],"content":" 这是我初次学到用体积散射可以做出空气透视的效果，在场景透视中是很常用的。 c "},{"title":"jsdelivr结合github搭建cdn图片仓库t","date":"2020-01-11T06:34:08.000Z","url":"/2020/01/11/cxy/other/jsdelivr/","tags":[["jsdelivr","/tags/jsdelivr/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" jsdelivr简介jsdelivr.net是著名的CDN服务提供商，可以加速前端静态资源访问速度。 jsdelivr 使用首先在github新建仓库，然后提交一张测试图片上传，点击release 在这里新增一个版本号，点击Publish release 然后使用你的用户名/你的仓库名@版本号/就可以访问静态资源了"},{"title":"在github pages中集成Gitalk功能","date":"2019-12-11T10:48:34.000Z","url":"/2019/12/11/cxy/other/gitalk/","tags":[["实用开源代码","/tags/%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" Gitalk简介Gitalk 是一个基于 Github Issue 和 Preact 开发的评论组件，支持 MarkDown 语法。 官方地址  特性 使用 github 帐户进行身份验证 无服务器，所有评论将存储为github问题 个人和组织github项目均可用于存储评论 本地化，支持多种语言[en，zh-CN，zh-TW，es-ES，fr，ru，de] 类似于Facebook的无干扰模式（可以通过distractionFreeMode选件启用） 热键提交评论（cmd | ctrl + Enter） 安装方法有两种 links npm install 用法 首先创建一个公共的 github 存储库来存储评论。（现有的也ok，反正只是用到issue不会影响仓库代码。） 创建一个GitHub 应用程序，创建方法请单击此处注册一个新应用程序。 注意： 必须在字段中指定网站域 url Authorization callback URL（回调的地址），都写你的个人网站地址就可以了。创建成功后，跳转到此记住clientID和clientSecret，是之后要配置的。 选择如何应用到页面，如下所示： 方法：将容器添加到您的页面： 然后使用下面的Javascript代码生成gitalk插件： 其中clientID和clientSecret是上面生成的，填入你的就可以了。 选项 客户端ID String 必填。GitHub 应用程序客户端 ID。 客户秘密 String 必填。GitHub 应用程序客户端机密。 回购 String 必填。GitHub 存储库。 所有者 String 必填。GitHub 存储库所有者。可以是个人用户或组织。 行政 Array 必填。GitHub 存储库所有者和协作者。（对该存储库具有写入权限的用户） ID String 默认值：location.href. 页面的唯一标识。长度必须小于 50。 数字 Number 默认值：-1. 页面的issue ID，如果number没有定义该属性，则使用.issue定位issue id。 标签 Array 默认值：[&#39;Gitalk&#39;]. GitHub 问题标签。 标题 String 默认值：document.title. GitHub 问题标题。 身体 String 默认值：location.href + header.meta[description]. GitHub 问题正文。 语言 String 默认值：navigator.language || navigator.userLanguage. 本地化语言键，支持[ en, zh-CN, zh-TW, es-ES, fr, ru, de, pl, ko, fa, ja]。 每页 Number 默认值：10. 分页大小，最大 100。 无干扰模式 Boolean 默认值：假。 类似 Facebook 的无干扰模式。 pagerDirection String 默认值：“最后” 评论排序方向，可选值为last和first。 手动创建问题 Boolean 默认值：false. 默认情况下，当登录用户属于用户时，Gitalk 会自动为您的每个页面创建一个相应的 github 问题admin。您可以通过将此选项设置为 来手动创建它true。 代理人 String 默认值：. GitHub oauth 请求 CORS 的反向代理。为什么需要这个？ 翻转移动选项 Object 默认： 评论列表动画。参考 启用热键 Boolean 默认值：true. 启用热键 (cmd|ctrl + enter) 提交评论。 效果演示点击访问"},{"title":"axios的基本使用","date":"2019-11-12T07:20:18.000Z","url":"/2019/11/12/cxy/other/axios/","tags":[["axios","/tags/axios/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、axios的发送类型和restful api一样axios基于promise，它支持promiseapi 1. 基本用法 或 注1：还有增（post）删（delete）改（patch/put）查（get）这些，以及head和option。 注2：OPTIONS方法返回有关API 的信息（方法/内容类型）: 2. 并发axios.all(iterable)###3. axios.create()###4. axios可以拦截请求和响应在请求和响应被then或catch之前做某些操作。比如请求前加入token，响应时如果返回数据错误，可以跳转到登录页 request的config里返回的，最后可以返回data以继续下面的请求 response里面返回的，最后也是return以用于响应 5.客户端支持xsrf防御6.axios常见的配置："},{"title":"微信小程序相关","date":"2019-07-21T11:39:12.000Z","url":"/2019/07/21/cxy/review/wechat/","tags":[["微信小程序","/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 初始化项目文件 根目录：app.json：项目配置文件，可以配置页面包括：page、tabbar、window、plugin等等app.js：每个页面都会去处理的方法。比如判断当前版本是否最新，还有是否有登录信息等等。app.wxss：全局的样式文件project.config.json：项目配置文件。可以设置一些编辑器的样式，设置一些js编译为es5是否禁用严格模式、上传时是否压缩、分包分不分等，是开发时的设置，在小程序侧边可以直接打钩设置。project.private.config.json：很多时候我们需要进行开发调试，利用微信开发者工具的预览功能在真机上查看实现效果。为了方便调试，我们会设置编译模式。但是编译模式的改动会写入 project.config.json 文件的 condition 字段中，而项目只有一份 project.config.json 文件。所以在团队协作的时候，每个人都在往里加入自己的编译模式，这给团队造成了一点麻烦。解决方案如下： 在 .gitignore 文件中添加 project.config.json、project.private.config.json 为项目引入 project.config.json.example 文件作为项目配置文件统一模板 团队成员使用 project.private.config.json 作为个人配置（此配置文件会优先使用） sitemap.json：是否允许微信索引（爬虫相关）pages文件夹：存储页面。 wxss wxml jsskyline WXSS和webview：skyline的性能更好些，不支持css animation wxss的常用组件视图容器swiperswiper-item moveable-areamoveable-view scroll-viewmatch-mediaroot-portal（position: fixed）viewblock 基础内容grid-viewlist-viewiconprogressrich-texttext 表单组件buttoncheckboxcheckbox-groupforminputslidepickerpicker-viewradioradio-groupswitchtextareaimagemap 小程序框架小程序生命周期点击查看文档onLaunch：全局app.js中的，他的触发比page中的onLoad要高onLoad：页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。onShow：页面显示/切入前台时触发。onReady：页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。onHide：页面隐藏/切入后台时触发。如 [wx.navigateTo]( api/route/wx.navigateTo.html) 或底部 tab 切换到其他页面，小程序切入后台等。onUnload：页面卸载时触发。如wx.redirectTo或wx.navigateBack到其他页面时。 其他page内的事件onPullDownRefreshonReachBottomonShareAppMessageonPageScroll##事件用bind或catch绑定（catch阻止向上冒泡）capture-bind（捕获）bindtapbind:touchstartbind: longpress还有一些单独组件的事件可以看看文档，比如swiper的bindtransitionbindanimationfinish等等等吖吖吖##常用api整理this.setDatawx.request wx.navigateTo：保留当前页面，跳转到应用内的某个页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。 wx.redirectTo：重定向。使用 wx.navigateBack 不可以返回到原页面 wx.createVideoContext(‘xxx’);xxx是video标签的id wx.showToast wx.getStoragewx.setStoragewx.clearStorage() wx.showShareMenu wx.canIUse wx.hideNavigationBarLoading() //在当前页面隐藏导航条加载动画wx.stopPullDownRefresh() //停止下拉刷新 面试题1、简单描述下微信小程序的相关文件类型?2、小程序的双向绑定和vue哪里不一样?3、小程序页面间有哪些传递数据的方法?使用全局变量实现数据传递app.js中定义globalData，然后在单独的文件中使用 使用navigateTonavigateTo的url后面跟?参数也可以实现数据传递，在新页面onLoad方法中使用 在新页面中 wxs定义公共工具类，比如叫utils，可以使用import引入 wxs也可以导出模块 使用getStorage本地缓存的清理时机跟代码包一样，只有在代码包被清理的时候本地缓存才会被清理。 4、小程序的生命周期5、如何下拉刷新在app.json中，或者在对应的json中设置 在钩子函数onPullDownRefresh中，监听下拉刷新，调用setData去更新数据，设置flag，让更新不会多次给重复触发中。请求成功后，调用wx.stopPullDownRefresh去停止下拉刷新。 6、bindtap和catchtap停止冒泡 7、wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别?wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面wx.redirectTo()：关闭当前页面，跳转到新的页面（类似重定向）。但是不允许跳转到 tabbar 页面wx.switchTab()：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面wx.navigateBack():关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层wx.reLaunch()：关闭所有页面，打开到应用内的某个页面###8、登录的流程点击查看：登录流程描述 9、app.json 全局配置文件描述pages : 用于存放当前小程序的所有页面路径window : 小程序所有页面的顶部背景颜色，文字颜色配置。tabBar : 小程序底部的Tab ,最多5个，最少2个。 10、小程序运行机制热启动 ：假如用户已经打开了某个小程序，在一定时间内再次打开小程序的话，这个时候我们就不再需要重新启动了，这需要把我们的后台打开的小程序切换到前台来使用。冷启动：用户首次打开小程序或被微信主动销毁再次打开的情况，此时小程序需要重新加载启动。 11、小程序什么时候会主动销毁？小程序在进入后台之后，客户端会帮我们在一定时间内维持我们的一个状态，超过五分钟后，会被微信主动销毁. 官方也没有明确说明 什么时候销毁， 在不同机型表现也不一样， 2019年开发时：时间官方文档没有说明，但是经过询问一般指5分钟内 2020年开发时：时间官方文档没有说明，实测安卓没有固定时间，内存足够情况下，有时候一天了还在，有时候几分钟就没了。 12、小程序怎么跟随事件传值在 页面标签上通过 绑定 dataset-key = value ， 然后绑定点击通过e.currentTarget.dataset.key 来获取标签上绑定的值。 13、小程序支付小程序有一个统一下单的api接口。点击查看：微信支付点击查看：云支付 小程序或公众号调用微信云托管，在微信云托管中调用统一下单接口，参数中带上接收异步支付结果的服务名称和其所在云环境ID 统一下单接口返回的成功结果对象中有 payment 字段，该字段即是小程序端发起支付的接口（wx.requestPayment）所需的所有信息 小程序端拿到后端结果，调用 wx. requestPayment 发起支付 支付完成后，在统一下单接口中配置的云托管服务将收到支付结果通知，具体详见结果回调开发中遇到的问题热启动和冷启动的问题。 "},{"title":"restfulAPI设计规范","date":"2019-07-10T07:20:18.000Z","url":"/2019/07/10/cxy/other/restfulApi/","tags":[["api","/tags/api/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 1.协议遵守https协议2.api应该有单独域名3.加上版本号4.由于restfulapi中url表示一种资源的集合，而不再是一个功能一个url，所以网址中不能有动词，应该全是名词，且与数据库的表名一一对应，也由于是一种集合，所以api的名词尽量为复数5.用http动词去表示资源的具体操作类型，如put/patch/post/get/delete/增删改查等6.如果涉及分页这种返回结果相当多的情况，api也可以提供一些参数，如?limit=10&amp;page=27.有单独的状态码"},{"title":"npm相关","date":"2019-06-03T03:11:11.000Z","url":"/2019/06/03/cxy/other/node-n/","tags":[["node","/tags/node/"],["npm","/tags/npm/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" -S和-D的区别npm i –save-dev xxx同npm i -D xxx安装到开发环境在package.json中： npm i –save xxx同npm i -S xxx安装到正式环境在package.json中： package-lock.json的作用比如你的packgae.json的依赖是”react”: “^17.0.2”，因为有标识符^，所以如果react模块有在17大版本下更新的小版本17.0.3，npm install时候会自动安装17下的最新版本17.0.3现象：在前景情况下，你本地是”react”: “^17.0.2”，如果这时候react更新”react”: “^17.0.3”，别人npm install的时候，安装就是”react”: “^17.0.3”。这样导致你们版本不一致，可能引起一些相关错误。解决：package-lock.json：简单来说就是锁定安装模块的版本号。就是在npm install的时候，记录各个模块的版本信息和下载路径，这样别人拉项目npm install时候， 就会依据packgae-lock.json去安装”react”: “^17.0.2”，保证大家依赖一致并且安装模块速度也能提高。"},{"title":"【第10章】运行环境","date":"2019-04-16T06:06:12.000Z","url":"/2019/04/16/cxy/js/js-enviro/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、从输入url到渲染出页面的整个过程 dns解析： 域名—&gt;IP 浏览器根据IP地址向服务器发起http请求 服务器处理http请求，并返回给浏览器 根据HTML生成Domtree，根据Css生成cssom，再整合dom树和cssom整合的rendertree 根据render tree渲染页面 遇到script标签则暂停渲染，优先加载并执行js代码，完成再继续，直至渲染完成。二、window.onload 和DOMContentLoaded的区别 三、性能优化的方案比如防抖、节流、懒加载，可以把面试官往这个方向引入1. 原则（1）.多使用内存、缓存或其他方法（2）减少CPU计算量，减少网络耗时（空间换时间）2. 方法（1）让加载更快：压缩代码（webpack mode production）服务端可以做打包（2）减少访问次数：合并代码（利用webpack、雪碧图）、ssr服务器端渲染，缓存（3）使用更快的网络： cdn ，cdn 内容分发网络，根据区域去访问不同地点的服务器。。。这样就会更快些（4）让渲染更快： css放在head js放在最下面 尽早开始执行js，用DOMContentLoaded触发事件 懒加载，图片上滑加载更多，如下7 对dom查询进行缓存，如下8 避免频繁DOM操作，合并到一起插入DOM结构 节流、防抖（体验性优化） 下面几条是对上面四条的补充（5）缓存：5.1静态资源加hash后缀，根据文件内容计算hash 5.2文件内容不变，则hash不变，则url不变 5.3 url和文件不变，则会自动触发http缓存机制，返回304（6）ssr：服务器端渲染：将网页和数据一起加载，一起渲染 | 非ssr（前后端分离）：先加载网页，在加载数据，再渲染数据（7）懒加载 （8）缓存dom查询 4.防抖debouce在频繁输入时，监听输入事件会频繁触发，像google搜索时，如果每一次输入都触发请求，请求量会很大，影响性能了。所以设置一个在输入停止一小段时长后，再触发请求。会大量的减少请求量。 5.节流 封装这里用到了闭包，之前在作用域和闭包中说过：闭包是由函数以及声明该函数的词法环境组合而成的闭包的变量不会得到释放闭包会随着函数的创建而被同时创建所以下面的timer向外层查找到的是形成的闭包的词法环境中的timer 6.xss（1）. 问题：常见的web前端攻击方式有哪些？比如我写了一篇博客，博客里面有script标签，该代码执行获取用户cookie的操作，任何用户访问该博客后，就会执行该代码。被获取到cookie之后，将cookie发送到我的服务器，这样就会拿到用户的敏感信息（2）. xss预防：// 替换特殊字符（&lt; –&gt; &lt; &gt; –&gt; &gt;）前端后端都要替换。 7.xsrf（1）概念：用?带参数去访问服务器，得到服务器数据（2）预防方法： 使用post接口、增加验证：例如密码、短信验证码、指纹"},{"title":"【第9-1章】http缓存策略","date":"2019-04-14T04:23:21.000Z","url":"/2019/04/14/cxy/js/js-http11/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 懒得重写了，直接从笔记截图过来。"},{"title":"【第9-2章】http协议","date":"2019-04-14T04:23:21.000Z","url":"/2019/04/14/cxy/js/js-http22/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 懒得重写了，直接从笔记截图过来。"},{"title":"【第9章】http与restfulAPI","date":"2019-04-12T07:33:35.000Z","url":"/2019/04/12/cxy/js/js-http/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" const { get } = require(“http”); 状态码类型 1xx 服务器收到了请求 2xx请求成功 如200 3xx重定向 如302 4xx客户端错误 5xx服务端错误，如500 常见状态码：200 请求成功301 永久重定向（配合location，浏览器记住了该网址返回了301，然后浏览器之后会永久自动处理到新的网站，如域名到期换新域名的情况）302 临时重定向（配合location，浏览器记住了该网址返回了302，但下次访问浏览器还是会访问到旧地址，如百度首页搜索的二级跳转、短网址等）点击链接：为什么百度需要二级跳转重定向？简单说，是为了打点。点击链接：短网址的作用 简单说，微博字数那么长，再来个那么长的网址真心hold不住。304 资源未被修改（缓存了）请求过来的数据没有改变404 资源未找到401 用户未授权 比如密码错误、用户名错误403 用户得到授权，但访问时禁止的500 服务器错误504 网关超时 (服务器端的操作有超时) 新method可以写的状态码/* 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - []：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - []：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - []：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。*/// “幂等性”指的是 1 次或 N 次的副作用(对系统造成的影响)相同，而不是返回结果相同，因此 GET 请求总是幂等的。// 无论一个操作被执行一次还是多次，执行后的效果都相同。比如对某资源发送GET请求，如果访问一次和访问十次获得的数据一样，那么就说这个请求具有幂等性。 http methods1. 传统methodsget获取服务器数据post向服务器提交数据 2. 现在的methods点击链接：restful api 的设计方法（1）get获取服务器数据 ()（2）head 和get类似，但服务器在响应中只返回头部，不返回实体的主体部分，这就允许客户端在没获取资源时对资源首部进行检查（3）post新建数据 (新建blog)（4）patch/put更新数据 （更新blog）patch:局部更新资源，比如只更新某一字段 put：完整更新资源，对带宽会有影响 （5） delete删除数据 （删除blog）（6）options 获取信息，关于资源的哪些属性是客户端可以修改的的。 restfulApirestfulApi 是一种新的api设计方法。 1. 概念：RESTful API 就是REST风格的API。现在终端平台多样，移动、平板、PC等许多媒介向服务端发送请求后，如果不适用RESTful API，需要为每个平台的数据请求定义相应的返回格式，以适应前端显示。但是RESTful API 要求前端以一种预定义的语法格式发送请求，那么服务端就只需要定义一个统一的响应接口，不必像之前那样解析各色各式的请求。 2. restfulapi的设计（1）传统API 把每个url当做一个功能（2）restful api 把每个url当做一个唯一的资源(^o^)/~就比如获取博客和更新博客 /api/blog/create 创建博客 /api/blog/update?blog=100 更新博客 这是一种功能// 而新的restfulapi，获取博客、更新博客、创建博客，都可以用/api/blog去表示，唯一不同的是method，这是一种资源集合（3）在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 附：URI：Uniform Resource Identifier，统一资源标识符URL：Uniform Resource Location统一资源定位符 URL是URI的子集。点击链接：URI 和 URL 3. 如何把每个url设计成一个资源？（1）不使用url参数 ，即问号后面的部分，然后做一个url的唯一标识传统： /api/list?pageIndex=2restful api: /api/list/2 （2）使用method表示操作类型传统： restful api： 下面以动物园为例子： http headers1. 常见的request headers（客户端像服务端发送的）Accept: image/avif,image/webp,image/apng,text/html浏览器可接受的数据格式 Accept-Encoding: gzip, deflate, br浏览器可接受的压缩算法 Accept-Language: zh-CN,zh;q=0.9浏览器可接受的语言 Connection: keep-alive连接方式keep-alive：一次tcp连接可以重复使用 Cookie: BIDUPSID=8B5F551B8E92D363D2BF09A17F1787F0; BAIDUID=5ccc19b28fd87ed0af236b203e83021a什么是cookie：Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 [1] 。 Host: m.baidu.com域名 Content-type: application/json text-plain客户端像服务端请求时，告诉服务端我发送数据的格式，一般只有post请求有，get是获取数据一般没有 User-Agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.193 Mobile Safari/537.36浏览器信息 Cache-Control 2. 常见的response headers（服务端像客户端返回的）连接方式 Connection: keep-alive返回数据的大小 Content-Length: 0返回的数据的格式 Content-Type: text/plain; charset=utf-8返回的数据的压缩算法 Content-Encoding服务端改cookie的时候，需要发送 Set-Cookie: __bsi=10004501327375333328_00_32_N_R_10_0303_c02f_Y; max-age=3600; domain=m.baidu.com; path=/ 3. 缓存相关的headerscache-control （响应头，缓存时间）expires (响应头中，已被cache-control代替，有这个属性和cache-control一起兼容写法的情况)last-modified（响应头，资源的最后修改时间） if-modified-since （请求头，协商缓存时浏览器再次请求会带着这个值，这个值和响应头的laast-modified相同）etag （资源的唯一标识）if-none-match (请求头，值和响应头的etag相同，协商缓存中的唯一标识) header也可以自定义,axios插件就可以自定义header除了以上之外，可以自定义header，如果在客户端自定义在request中加，如果在服务端中自定义要后端在response中加常用场景：如服务端需要前端加上一个验证header做非法请求的验证 总结一下restful api的设计模式1.协议遵守https协议2.api应该有单独域名3.加上版本号4.由于restfulapi中url表示一种资源的集合，而不再是一个功能一个url，所以网址中不能有动词，应该全是名词，且与数据库的表名一一对应，也由于是一种集合，所以api的名词尽量为复数5.用http动词去表示资源的具体操作类型，如putpatchpostgetdelete增删改查等6.如果涉及分页这种返回结果相当多的情况，api也可以提供一些参数，如?limit=10&amp;page=27.有单独的状态码8.4xx错误时要返回出错信息，用统一的error作为键值9.返回结果应符合规范 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档10.Hypermedia API 返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 http缓存(见有道云)1. 什么是缓存？网页第二次访问时，有相同资源可以不用重新请求一遍。 2. 为什么需要缓存为了让页面加载更快，网络请求加载相比cpu计算等等会比较慢，所以要尽量减少网络请求的数量和体积，可以让加载更快一些 3. 哪些资源可以被缓存 —— 静态资源（js css img）html一般是不被缓存的，网页的业务数据（比如留言板列表、博客列表）一般也不能被缓存，因为有可能随时会更新。 2. http缓存策略(见有道云)（1）强制缓存 cache-control比如请求一个js资源浏览器初次请求服务器，服务器返回资源和cache-control，若服务端感觉这个资源可以被缓存，则加入cache-control（在response-headers中，因为在响应头中，所以客户端无法控制，服务端控制）如：cache-control：max-age=5184000 单位为秒浏览器再次请求时，之前服务端的cache-control本地缓存会缓存下js的内容，如果cache-control没过期，浏览器就请求本地缓存，不通过网络，由本地缓存返回资源。 （2）协商缓存服务端去判断客户端资源是否和服务端一致，一致则返回304（服务端判断客户端资源未改动），否则返回200和最新的资源。浏览器初次请求，服务端返回资源和资源标识给浏览器。浏览器再次请求会带上资源标识，服务端判断该资源标识的资源是否和服务端最新资源一致，则返回304，否则返回新资源和新资源标识。资源标识：在response-header中（因为是服务端返回的呗）last-Modified 资源的最后修改时间Etag资源的唯一标识（一个字符串，类似人类指纹） （3）刷新方式对缓存的影响https协议(见有道云)一、 http面试题 http常见状态码 http常见header 什么是restful 描述一下http缓存机制 "},{"title":"【第8章】localStorage、sessionStorage、cookie","date":"2019-04-12T07:33:35.000Z","url":"/2019/04/12/cxy/js/js-storage/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 内容：localStorage sessionStorage cookie 一、cookie1. 什么是cookie？cookie用来server端和浏览器端通信，并不是用来做本地存储，只是因为原先html5不普及所以借用来本地存储 2. 前端修改cookie的方式：document.cookie后端也可以修改cookie。 3. cookie的缺点：（1）存储大小最大只有4k（2）每次发送http请求，cookie都会被发送到服务端，会增加请求的数据量（3）只能用document.cookie来修改，很麻烦。 二、.localStorage和sessionStorage1. 优点：（1）localStorage和sessionStorage是html5专门为存储设计，最大存储5m（2）api简单易用（3）不会随着http请求被发送。 localStorage和sessionStorage可以在控制台application查看 2. api:getItem(key)setItem(key,value) 3. localStorage和sessionStorage、cookie区别(1) localStorage会永久存储，sessionStorage只存在于当前会话，如果浏览器关闭，该网站的sessionStorage会立即清除。 (2) cookie每次都会随着浏览器请求发送到服务端，localStorage和sessionStorage只存在于本地 (3) localStorage和sessionStorage的api简单，cookie只能通过document.cookie设置。"},{"title":"【第7章】ajax","date":"2019-04-11T04:13:35.000Z","url":"/2019/04/11/cxy/js/js-ajax/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、手写一个ajax promise ajax的写法 二、跨域1. 同源协议、域名、端口必须一致，叫做同源同源策略：ajax请求时，浏览器要求当前网页和服务器端必须同源 2. img、link、script 可以无视同源策略，即可以跨域由于img可以无视同源策略，所以可以用于使用第三方统计服务，如打点link script 可使用cdn，cdn一般是外域服script可以实现jsonp 3. 如何用jsonp实现跨域？上面说了script可以实现jsonp。现在假设我需要在下访问的文件，由于端口不一致所以跨域了。（1）首先，需要服务器进行配合。因为服务器可以拼接任意字段返回给服务器，所以让服务器将数据包装为js函数返回。 假设服务器给前端的数据为，该文件的内容让后端包装为callback方法，参数为真实要传递的数据，如： （2）然后，前端使用script标签引入该index文件 这样，在页面中就引入了一个名为callback的函数，因为是script全局引入，所以该方法位于window下。（3）再使用另一个script标签，处理数据： 4. cors实现跨域CORS 是纯服务器端操作，服务器端可以设置header根据下面方法设置响应头字段服务器端可以直接设置header，去允许某个地址的跨域访问。 5. 常用的ajax插件fetch() axios "},{"title":"【第6章】事件捕获与冒泡相关","date":"2019-04-10T04:13:35.000Z","url":"/2019/04/10/cxy/js/js-event/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 描述事件冒泡的流程事件冒泡基于树形dom结构，事件可以一级一级的向上冒泡，若有多个事件，先响应内层，再响应外层。若一个事件在最外层绑定的，在最内层上依旧能监听到。 事件冒泡和事件捕获事件冒泡：事件可以一级一级的向上冒泡，若有多个事件，先响应内层，再响应外层。 事件捕获：从外向内触发事件，很少用于开发。xxx.addEventListener(‘xxx’,function(){},true) 第三个参数为true时，则触发事件捕获。 事件代理像瀑布流，无限加载图片，由于元素太多不好每一个元素都绑定事件，所以就将事件绑定在这些图片的父元素上，通过事件冒泡去相应事件好处是代码简洁，减少浏览器占用，但不要滥用。 面试题编写一个通用的事件监听函数为了解决事件代理（如瀑布流需要每个图片都有一个点击事件）将瀑布流事件绑定在父元素上，当点击父元素时，可以激发子元素的事件 "},{"title":"【第4-3章】async await","date":"2019-04-06T09:01:05.000Z","url":"/2019/04/06/cxy/js/js-await/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、generator的基本用法 1. for…of循环可以自动遍历generator函数运行时生成的iterator对象，且此时不需要调用next()方法。 3. g.throw(err) 在generator函数内部排除一个错误4. g.return() 可以返回特定的值，并且终结generator函数。5. yield* gen() 若是在generator函数内部需要调用其他generator函数，需要手动遍历，或直接使用yield*表达式。6. 如果一个对象的属性是generator函数，则可以简写，generator的返回值是iterator遍历器 二、async、await· async 可以用同步的方式写异步的代码，async返回的是promise对象，如果返回了普通变量则会被包装成promise· await后面一般追加异步操作，相当于promise.then()，如promise对象、其他async函数 1. async/await和Promise的关系，为什么要使用async async/await是消灭异步回调的方法，有了async/await，就可以使用同步的写法去写异步的程序，不需要再用回调函数，写起来也比promise简便。相当于promise.then promise.catch，但二者并不冲突promise捕获错误只能用promise.catch的方法，没办法用try…catch，但async/await可以，写法上会规范许多 2. async返回一个promise，可以用.then方法，await相当于promise.then(重点！)，但用法又有所不同async函数内部return语句返回的值，会成为then方法回调函数的参数。async自动执行、async函数返回一个 Promise 对象，可以使用then方法添加回调函数。await 后面跟promise对象或一个一个async 函数，相当于promise.then()async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 3. 正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。async函数return的则是一个promise对象 4. await后面可以跟promise或async函数，如果跟的是一个普通函数，那加不加await都是一样的 ###5. async内的catch相当于promise.catch() 若await后面的promise状态为reject，则之后代码均不执行 5.异步的本质：遵循event-loopasync/await只是语法糖，从语法层面将代码变为同步的写法，但实质是异步的，依旧基于event-loop去执行await 后面的内容全部都理解为放在回调函数中，所以他们都是异步操作，所以要放在同步操作的后面去执行（event-loop原理） 6.await后面加不加promise，很很很重要不加promise相当于一个同步函数，后面的代码也是同步代码了。 ```javascriptfunction timeout(ms) { return setTimeout(()=&gt;{}, ms); } async function asyncPrint(value, ms) { await timeout(ms); console.log(value); } asyncPrint(‘hello world’, 5000); console.log(1)// 立刻打1 hello world"},{"title":"【第4章】同步和异步","date":"2019-04-06T05:20:03.000Z","url":"/2019/04/06/cxy/js/js-progre/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 单线程和异步js是单线程语言，只能同时做一件事情，两段js不能同时执行，.原因就是避免DOM渲染的冲突（都修改DOM就冲突了）浏览器和nodejs已经支持js启动进程 如 web serverjs和dom渲染共用一个县城，所以可以操作dom##异步为了解决什么问题？因为js是单线程，异步为了解决遇到等待时，等待过程中不可能像alert一样阻塞程序进行，因此所有的“等待情况”都需要异步。 异步应用场景：定时任务：setTimeout、setInterval、网络请求：Ajax请求、动态加载、事件绑定：图片加载如onload，不用等待onload完毕再去执行onload后面的代码 回调地狱callback hell回调函数： 将一个函数作为参数传递给另个函数回调地狱用promise来解决 再如请求太多的时候，回调函数套回调函数 如果用promise去写，就会简洁很多。 常见的面试题：图片加载 单线程是什么前端使用异步的场景有哪些"},{"title":"【第4-2章】promise","date":"2019-04-05T08:22:15.000Z","url":"/2019/04/05/cxy/js/js-promise/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、promise的三种状态fuifilling reject pending，在没有获取到reject或者fulfilling时一直都是pending，直到有reject或resolve返回promise变为fufilling或reject之后，状态不可逆。pending状态，不会触发then和catch，resolved会触发then，reject会触发catch 二、then(res,rej)方法then(res,rej)方法的两个参数，第一个是resolve方法，第二个是reject方法，reject方法可以在后面用catch的方法调用then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 直接获取resolve状态或reject状态的方法： 三、then和catch的状态改变 then正常返回resolve，内部有报错（或throw err）则返回rejected。 catch正常返回resolved，内部有报错则返回rejected。 resolve触发then回调，rejected后续触发catch回调，注意resolve是不会触发catch回调的。 promise.resolve()和promise.reject()只要内部没报错，后续还是触发then回调。 最后的状态靠最后返回的结果为定 第五点我要单独说一下：最后的状态靠最后返回的结果为定在下面的代码中，promiseA本身是反悔了resolve，但由于它引入了另一个promiseB，而promiseB返回reject，所以最终执行结果会到catch方法中。 四. resolve和fufilledpromiseA如果resolved到了另一个promiseB中，那它不一定是pendding fulfilled reject,它的状态由promiseB执行完毕才决定。上面有代码示例。 (1) nothing happened yet(2) “locked in”to another promise(3) fulfilled(4) rejeted(1)(2) pedding (3)(4)settled (2)(3)(4)resolved (1)unresolved ##五. Promise.resolve() 和 Promise.reject() 如果Promise.resolve()有参数:（1）. 参数为promise，原封不动的返回该promise （2）参数为有then方法的对象，会立即执行then方法，并将执行结果封装为promise对象 （3）参数没有then方法，或根本就不是对象，则将值包装为promise对象并返回到then中，状态为resolved 六、promise定义时立即执行，而then相当于异步，所以执行完promise内的内容跳出去执行同步代码，再执行then 面试题：以下代码的执行结果？ "},{"title":"【第3-2章】作用域和闭包","date":"2019-04-05T04:00:00.000Z","url":"/2019/04/05/cxy/js/js-context/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、作用域和自由变量作用域:作用域就是一个变量的合法使用范围。作用域分为全局作用域、函数作用域及块级作用域（es6新增）。 函数作用域 块级作用域（es6新增） 自由变量：一个变量在当前作用域没有定义，（注意是当前作用域，哪怕上级作用域定义了只要当前作用域没定义就不行）但被使用了，沿上级作用域一级一级找，若到全局作用域还没有找到，就报错。 二、闭包·闭包就是作用域应用的一个特殊情况，闭包让开发者可以从内部函数访问外部函数的作用域，有两种情况：（1）函数作为参数被传递（2）函数作为返回值·自由变量的查找是在函数定义的地方！（重点，函数定义的地方是指函数体在哪里），向上级作用域查找注意：闭包中的变量会常驻在内存，得不到释放，因为判断不了闭包内的变量未来是否会用到闭包是由函数以及声明该函数的词法环境组合而成的。 （1）函数作为参数被传递 （2）函数作为返回值 （3）自执行函数 function 里可没传参数，看好了是data后面有参数，其实就算传了也没什么影响，因为i的值已经在调用时决定是3了，虽然函数定义时决定了变量所在的作用域，但调用时才能决定变量在该作用域实际的值。 重要！！！变量在定义时就确定了上级作用域，但需要在调用时才能确定变量定义时所在的上级作用域或当前作用域该变量的值，比如这里i在调用时的值为3，即使外部定义了i = 10，最终查找还是在定义时的当前作用域查找i，当前作用域的i为3，所以输出全为3 改进方法：形成自己的封闭的块级作用域。改进方法1：for内的var变为let，因为let具有块级作用域，它形成了三个私有作用域相互不会干扰。 改进方法2：自执行函数和闭包匿名函数定义也是在匿名函数声明的地方，这里即return后，有名字的函数定义就在有名字的函数那里，然后一层一层向上查找 自由变量的查找是在函数定义的地方，向上级作用域查找 ，而不是在执行的地方。 三、this详见3-1this取值是在函数执行的时候决定的，而不是函数定义的时候决定的。 箭头函数的this取值是取他的上级作用域的值（静态作用域），普通function的this取值是在函数执行时确认的。 分为以下几种情况：（1）作为对象方法被执行，this指向该对象。（2）class的this表示它当前的实例，在构造函数（函数用new调用）中，this指向要被constructed的新对象。（3）普通函数的this，在调用时才知道this的作用域。（4）箭头函数的this固定指向上级作用域（5）call apply函数内的this和函数在什么环境中定义没有关系，而只和自己的主体有关。 ####call、apply、bind的区别和使用：作用是在一个对象中调用另一个对象的方法和属性。 call、apply、bind的第一个参数均为需要调用属性或方法的对象，区别是apply的第二个参数为数组，而bind、apply参数不放入数组而是直接列出。 bing会返回一个函数，执行函数后才改变this，而call、apply会立即执行。 bind的执行： call的执行： apply的执行： 面试题：手写bind、call、apply闭包的实际使用场景"},{"title":"【第3-1章】this","date":"2019-04-05T04:00:00.000Z","url":"/2019/04/05/cxy/js/js-this/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、作用域与thisES5只有全局作用域和函数作用域，没有块级作用域作用域分为静态/词法作用域和动态作用域 0. 声明提升和暂时性死区(1).声明提升(var) (2).暂时性死区(let) 注意：在es5 strict mode，赋值给未声明的变量将报错。 1.静态作用域静态作用域指的是一段代码，在它执行之前就已经确定了它的作用域，简单来说就是在执行之前就确定了它可以应用哪些地方的作用域(变量)首先let和const声明的全局变量不再属于window变量的作用域，除了this以外，全部遵循词法作用域的原则。即JS引擎总会从最近的一个域，向外层域查找； 二、动态作用域动态作用域–函数的作用域是在函数调用的时候才决定的。在 JavaScript 中的仅存的应用动态作用域的地方：this 引用。动态作用域，作用域是基于调用栈的，而不是代码中的作用域嵌套；作用域嵌套：有词法作用域一样的特性，查找变量时，总是寻找最近的作用域； 三、声明函数的方法（1）.函数声明function a (a,b,c) { return a+b+c;}（2）.函数表达式var a = function (a,b,c) { return a+b+c;}（3）.Function构造函数语法： new Function(参数1, 参数2, 参数3, 方法体)var a = new Function(‘a’,’b’,’c’,’return a+b+c’) 四、变量进入作用域的方法1.Language-defined：所有的作用域默认都会给出 this 和 arguments 两个变量名（global没有arguments2.Formal parameters（函数形参）：函数有形参，形参会添加到函数的作用域中;3.Function declarations（函数声明）：如 function foo() {}4.Variable declarations（变量声明）：如 var foo，包括_函数表达式_ 除了上下文顺序声明之外，若声明提升符合。函数声明和变量声明总是会被移动到它们所在的作用域的顶部。而变量的解析顺序（优先级），与变量进入作用域的4种方式的顺序一致。 关于上下文： 五、this每个作用域都会有this。在全局上下文（任何函数以外），this指向全局对象。 this在具体位置的具体指向： 在函数内部时，this由函数怎么调用来确定。简单调用，即独立函数调用。由于this没有通过call来指定，且this必须指向对象，那么默认就指向全局对象。 严格模式下，this保持进入execution context时被设置的值。如果没有设置，那么默认是undefined。它可以被设置为任意值（包括null/undefined/1等等基础值，不会被转换成对象）。 在箭头函数中，this由词法/静态作用域设置（set lexically）。它被设置为包含它的execution context的this，并且不再被调用方式影响（call/apply/bind）。 当函数作为对象方法调用时，this指向该对象。 原型链上的方法根对象方法一样，作为对象方法调用时this指向该对象。 在构造函数（函数用new调用）中，this指向要被constructed的新对象。 Function.prototype上的call和apply可以指定函数运行时的this。 ES5引进了Function.prototype.bind。f.bind(someObject)会创建新的函数（函数体和作用域与原函数一致），但this被永久绑定到someObject，不论你怎么调用。它说创建新函数，可不是覆盖原函数，！！！！ 闭包中的this（挺绕的，但无论下次看到理不理解，都要记住闭包套的闭包有可能返回window，需要分析有没有自执行函数）为什么下面这段代码的结果是”The Window”？ object.getNameFunc是对象调用的方法，里面的this是指向object，但object里面return的闭包，有自己的this和arguments。在《Javascript高级程序设计》中有写 为什么匿名函数没有取得其包含作用域（外部作用域）的this对象呢？每个函数被调用时，其活动对象都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。 在作用域和闭包说过，闭包的情况有函数作为返回值及函数作为参数被传递。同样的，还有像操作dom函数的闭包。 再深层一些，比如clickEvent这个函数返回的也是闭包，那么无论多少层，只要执行了，都是window。 注意：当用call和apply而传进去作为this的不是对象时，将会调用内置的ToObject操作转换成对象。所以4将会装换成new Number(4)，而null/undefined由于无法转换成对象，全局对象将作为this。 六、JavaScript采用Lexical Scope。（静态范围作用域）于是，我们仅仅通过查看代码（因为JavaScript采用静态范围作用域），就可以确定各个变量到底指代哪个值。另外，变量的查找是从里往外的，直到最顶层（全局作用域），并且一旦找到，即停止向上查找。所以内层的变量可以覆盖外层的同名变量。 七、Function vs. Block Scope上面的内容有意无意似乎应该表明了，JS没有Block Scope。除了Global Scope，只有function可以创建新作用域（Function Scope）。 不过这已经是老黄历了，ES6引入了Block Scope。另外，with和try catch都可以创建Block Scope。"},{"title":"【第2章】原型和原型链","date":"2019-04-04T06:13:15.000Z","url":"/2019/04/04/cxy/js/js-prototype/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、原型的简单描述在一个类中：实例的隐式原型，指向类的显式原型类的方法定义于prototype中。son.__proto__ = Son.prototype 在继承关系中：子类的显式原型的隐式原型指向父类的显式原型，查找时就顺着这个链去查找，类的最顶端为object子类也有隐式原型，指向的是父类。Son.prototype.__proto__ = Parent.prototypeSon.__proto__ = Parent call、apply、bind的区别和使用：作用是在一个对象中调用另一个对象的方法和属性。 call、apply、bind的第一个参数均为需要调用属性或方法的对象，区别是apply的第二个参数为数组，而bind、apply参数不放入数组而是直接列出。 bing会返回一个函数，执行函数后才改变this，而call、apply会立即执行。 bind的执行： call的执行： apply的执行： class说白了还是语法糖，如果不用class，用原型链当然也可以定义继承关系。比如我现在有一个类A，有一个子类B 补充：in和hasOwnproperty的区别两个方法都是判断对象中是否存在某个key，但hasOwnproperty不判断原型链上的属性和方法。所以，依据上面的例子：‘aa’ in b // truejavascriptb.hasOwnProperty(‘aa’) // false"},{"title":"【第5章】dom、bom","date":"2019-04-03T05:03:15.000Z","url":"/2019/04/03/cxy/js/js-explore/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、dom前言：dom的本质html是一种特定的xml，html规定了语法，而xml可以自己规定标签dom的本质是一个树形的数据结构 1. document对象（1）document对象集合 all[]所有元素的集合anchors[]对所有href链接的引用，非常简单地返回文档中具有name属性值的所有锚点的集合。已被web标准删除。applets对所有applets（小应用程序）对象的引用forms[]对所有forms的引用images[]对所有img的引用links[]对所有area的href的引用，href （2）document对象属性 （3）document对象方法 2. document.element（1）节点操作 （2）节点属性操作 （3）节点属性 3.attribute 在属性节点上的可用的属性或方法 4.event（1）基本写法 （2）事件类型 二、bom（1）window下 history location以举例 Navigator：Navigator下的属性基本是浏览器的各种信息，如userAgent返回由客户机发送服务器的 user-agent 头部的值。 其他常用的： 面试题：如何提高dom性能？(1) 避免频繁的dom操作(2) 对dom查询做缓存(3) 将dom频繁操作改为一次性操作"},{"title":"【第1章】变量类型和计算","date":"2019-04-03T05:03:15.000Z","url":"/2019/04/03/cxy/js/js-let/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 一、值类型和引用类型1.js的类型一共六种数字（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（Object）。 其中对象类型包括：数组（Array）、函数（Function） 还有两个特殊的对象：正则（RegExp）和日期（Date） 值类型: number、string、boolean、undefined 引用类型: null、object(array function regexp date) 新类型：BigInt 是一种内置对象，它提供了一种方法来表示大于 253 - 1 的整数。 BigInt和Number的区别：不能用于 Math 对象中的方法；不能和任何 Number 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 BigInt 变量在转换成 Number 变量时可能会丢失精度。 2. 深入分析值类型和引用类型在内存中的存储方式值类型和引用类型有什么区别值类型在栈中存储，引用类型在堆中存储，值类型赋值多少就是多少，引用类型会被指针影响。 3. typeof能判断那些类型？typeof返回结果为字符串 4. 何时使用===何时使用==？除了 == null之外，全部用 === 先说 “===”，这个比较简单。下面的规则用来判断两个值是否===相等： 1、如果类型不同，就不相等 2、如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断） 3、如果两个都是字符串，每个位置的字符都一样，那么相等；否则不相等 。 4、如果两个值都是true，或者都是false，那么相等。 5、如果两个值都引用同一个对象或函数，那么相等；否则不相等。 6、如果两个值都是null，或者都是undefined，那么相等。 再说 “==” 如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： a、如果一个是null、一个是undefined，那么相等。 b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。像-1既不等于false也不等于true，2既不等于false也不等于true2 &gt; true, -1 &lt; false 都是成立的 d、如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。 js核心内置类，会尝试valueOf先于toString; e、任何其他组合，都不相等。 5. 手写深拷贝:递归,什么是深拷贝:浅拷贝如果遇到的是一个引用类型，那么拷贝的实际上是变量的地址，更改的时候会更改拷贝的原变量，深拷贝则会生成一个新地址方法1： 方法2： 改良 手写isEquals()函数 6. truly变量和falsely变量两步非运算为true，则为truly变量，两步非运算为false，则为falsely变量，即 以下为falsely变量，其他都为truly变量 if判断时的truly变量和falsely变量，若为falsely变量直接无法走入if循环 强制类型转换和隐式类型转换(1) 强制类型转换parseInt()和parseFloat() (2) 隐式类型转换 if 逻辑运算 == +、*拼接字符串//字符串和数字相加会转为字符串，字符串和数字相乘/除/减会转为数字 补：hasOwnProperty:对象方法，返回一个boolean，判断是否拥有此对象，且不是继承来的对象，也就是沿着原型链上查找到的。 map weakmap set weakset 区别:1.weakset值只能是对象2.weakset是弱引用，即如果其他对象都不引用该对象，那么垃圾回收机制会立即回收。weakmap键只能是对象，值可以任意。WeakMap的键名所指向的对象，不计入垃圾回收机制。WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。set方法：has() add() delete() clear() entries() keys() values() sizemap方法：add() delete() set(key,value) get()（增删改查） entries() keys() values() size settimeout(fun,ms,arg1,arg2…argN) 第三个-最后一个参数会作为传递参数传给fun"},{"title":"【闭包的典型运用】防抖与节流","date":"2019-03-17T04:13:35.000Z","url":"/2019/03/17/cxy/js/js-bibao-debounce&throttle/","tags":[["js","/tags/js/"]],"categories":[["程序员的自我修养","/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"]],"content":" 闭包的典型应用就是函数防抖和节流，本文详细介绍函数防抖和节流的应用场景和实现。 函数防抖（debounce） 函数防抖，就是指触发事件后，在 n 秒后只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数的执行时间。 简单的说，当一个动作连续触发，只执行最后一次。 打个比方，坐公交，司机需要等最后一个人进入才能关门。每次进入一个人，司机就会多等待几秒再关门。 函数节流（throttle） 限制一个函数在一定时间内只能执行一次 举个例子，乘坐地铁，过闸机时，每个人进入后3秒后门关闭，等待下一个人进入。 常见的应用场景 函数防抖（debounce）的应用场景 连续的事件，只需触发一次的回调场景有： 搜索框搜索输入。只需要用户最后一次输入完再发送请求 手机号、邮箱格式的输入验证检测 窗口大小的 resize 。只需窗口调整完成后，计算窗口的大小，防止重复渲染。 函数节流（throttle）的应用场景 间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚动到底部监听 谷歌搜索框，搜索联想功能 高频点击提交，表单重复提交 省市信息对应字母快速选择 实现原理 函数防抖（debounce） 简单实现： 函数防抖在执行目标方法时，会等待一段时间。当又执行相同方法时，若前一个定时任务未执行完，则 清除掉定时任务，重新定时。 封装： 绑定事件解释：addEventListener 第一个参数是监听的事件，第二个参数是对应事件的回调函数。将 debounce 函数作为回调函数，这个 debounce 回调函数返回一个防抖之后的函数，因此实现了防抖的功能。 防抖解释：当 按下某个键的时候触发 keydown 事件，并执行回调。timer 默认为 null，在 return 的函数中定时器 timer 被赋值，如果在 delay 延迟之内再次触发了 keydown 事件，那么 timer 就会被重置为null...，当用户输入完成之后（delay 时间已过），那么就会触发 debounce 中的回调函数，也就是 keydown 最终要执行的事件。 函数节流（throttle） 简单实现 函数节流的目的，是为了限制函数一段时间内只能执行一次。因此，通过使用定时任务，延时方法执行。在延时的时间内，方法若被触发，则直接退出方法。从而实现一段时间内只执行一次。 封装： 解释：如果 timer 存在，那就直接返回，不再往下执行了。这样就实现了一段时间内执行一次的目的。 异同比较 相同点： 都可以通过使用 setTimeout 实现 目的都是，降低回调函数的执行频率，节省计算资源 不同点： 函数防抖，是在一段连续操作结束之后，处理回调，利用 clearTimout 和 setTimeout 实现。函数节流，是在一段连续操作中，每一段时间只执行一次，在频率较高的事件中使用来提高性能。 函数防抖关注一段时间内连续触发，只在最后一次执行；而函数节流侧重于在一段时间内只执行一次。 节流其实还有另一种不用定时器的方法。新的时间戳 - 旧的时间戳 &gt; delay时间的话，执行方法。否则将此时的时间戳赋值为旧的时间戳 "},{"title":"删了改，改了删","date":"2018-03-28T03:36:08.000Z","url":"/2018/03/28/npm%E5%8F%91%E5%B8%83%20copy/","tags":[["乱七八糟","/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"]],"categories":[["乱七八糟","/categories/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"]],"content":"放一些突然的灵感，或者想法，或者未整理的东西，或者todo，或者计划，总之什么都可以放在这里。记得实现一条删一条。"}]